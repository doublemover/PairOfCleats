# Map Pipeline Performance Notes

This document describes the code map pipeline and performance considerations for map artifacts
generated by the `report map` tooling.

## Pipeline overview
1. Load map inputs from index artifacts (`repo_map`, `file_relations`, `graph_relations`,
   `chunk_meta`, `file_meta`).
2. Hydrate chunk metadata with `file_meta` when needed.
3. Build members from `repo_map` and `chunk_meta`, tracking aliases and source rank.
4. Build file nodes and edges (imports, exports, calls, usages, dataflow, aliases), spilling to temp files when limits are exceeded.
5. Apply scope filters and collapse rules; enforce limits and optional top-K by degree.
6. Sort nodes and edges deterministically; assemble the map model, edge aggregates, section hashes, and viewer settings.
7. Cache the model under `.pairofcleats/maps/cache/<cacheKey>.json` unless `--refresh` is set.

## Inputs and outputs
Inputs (index artifacts):
- `repo_map` (symbols by file)
- `file_relations` (file-level import edges)
- `graph_relations` (call/usage graphs; optional)
- `chunk_meta` (chunk metadata + relations)
- `file_meta` (file id to path/ext mapping)

Outputs:
- Map model JSON (default output for `report map`).
- Optional render formats: `dot`, `svg`, `html`, `html-iso`.
- Optional node list JSON via `--node-list-out`.
- Optional precomputed `edgeAggregates` and `sectionHashes` fields in the map model.

## Determinism constraints
- File nodes are sorted by `node.path`.
- Members are sorted by `member.name` and `member.range.startLine`.
- Edges are sorted by `type:from->to:label` string keys.
- Section hashes are computed from the deterministic ordering above for nodes/symbols/edges/aggregates.
- Cache keys are derived from `buildId` plus normalized map options via `stableStringify`.

## Performance considerations
- The pipeline uses spill sorters for nodes/edges when inputs exceed in-memory thresholds,
  which caps peak heap while preserving deterministic ordering.
- Large repos should rely on `maxFiles`, `maxMembersPerFile`, `maxEdges`, and `topKByDegree`
  to cap output size.
- `graph_relations` is the fastest edge source; if missing, the pipeline falls back to
  per-chunk relations which is more expensive.
- The cache avoids repeated model generation when inputs and options do not change.
- The map model includes `edgeAggregates` so the viewer can skip per-frame aggregation.
- `sectionHashes` provide a stable fingerprint for nodes/symbols/edges/aggregates across runs.

## Error behavior
- Missing artifacts are recorded as warnings and the map is generated with reduced coverage.
- Missing `chunkUid` is a hard error in strict mode; otherwise the member is skipped and
  a warning is emitted.
- If `graph_relations` cannot be loaded, the pipeline falls back to chunk-level call/usage
  relations when present.

## Compatibility and versioning
- The map model version is `MAP_MODEL_VERSION` (`1.0.0`).
- New fields must be additive. Consumers should ignore unknown fields.

## Code touchpoints
- `src/map/build-map.js`
- `src/map/build-map/io.js`
- `tools/reports/report-code-map.js`
- `src/map/dot-writer.js`
- `src/map/html-writer.js`
- `src/map/isometric-viewer.js`

## Related docs
- `docs/specs/map-artifact.md`
- `docs/guides/code-maps.md`

## Benchmarks
- `node tools/bench/map/build-map-streaming.js --repo <repoRoot> --json`
- `node tools/bench/map/build-map-memory.js --repo <repoRoot> --json`
- Bench harness:
- `node tools/bench/bench-runner.js --suite sweet16-ci --json .testLogs/bench-sweet16.json --quiet`
