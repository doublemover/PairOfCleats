#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';
import seedrandom from 'seedrandom';
import { createCli } from '../src/shared/cli.js';
import { loadChunkMeta } from '../src/shared/artifact-io.js';
import { sha1 } from '../src/shared/hash.js';
import { getIndexDir, loadUserConfig } from './dict-utils.js';

const argv = createCli({
  scriptName: 'bench-query-generator',
  options: {
    repo: { type: 'string' },
    mode: { type: 'string', default: 'code' },
    count: { type: 'number', default: 50 },
    out: { type: 'string' },
    seed: { type: 'string' },
    json: { type: 'boolean', default: false },
    'index-root': { type: 'string' }
  }
}).parse();

const root = argv.repo ? path.resolve(argv.repo) : process.cwd();
const userConfig = loadUserConfig(root);
const mode = String(argv.mode || 'code').toLowerCase();
const indexRoot = argv['index-root'] ? path.resolve(argv['index-root']) : null;
const indexDir = getIndexDir(root, mode, userConfig, indexRoot ? { indexRoot } : {});
const chunks = await loadChunkMeta(indexDir);
if (!Array.isArray(chunks) || !chunks.length) {
  console.error(`No chunk metadata found at ${indexDir}`);
  process.exit(1);
}

const count = Math.max(10, Math.min(200, Number(argv.count) || 50));
const defaultSeed = sha1(`${indexDir}:${mode}:${chunks.length}`);
const seed = argv.seed || defaultSeed;
const rng = seedrandom(seed);

const pick = (list) => list[Math.floor(rng() * list.length)];
const uniq = (list) => Array.from(new Set(list.filter(Boolean)));
const formatQueryValue = (value) => {
  if (!value) return null;
  const cleaned = String(value).replace(/\s+/g, ' ').trim();
  if (!cleaned) return null;
  const escaped = cleaned.replace(/"/g, '\\"');
  return /\s/.test(escaped) ? `"${escaped}"` : escaped;
};
const tokensFromDoc = (text) => {
  if (!text) return [];
  return text.split(/\s+/).map((t) => t.replace(/[^\w-]/g, '')).filter((t) => t.length >= 4);
};

const names = uniq(chunks.map((c) => c.name));
const signatures = uniq(chunks.map((c) => c.docmeta?.signature || c.metaV2?.signature));
const kinds = uniq(chunks.map((c) => c.kind || c.metaV2?.kind));
const returnTypes = uniq(chunks.map((c) => c.docmeta?.returnType || c.metaV2?.returns));
const docs = uniq(chunks.flatMap((c) => tokensFromDoc(c.docmeta?.doc || c.metaV2?.doc)));
const riskTags = uniq(chunks.flatMap((c) => c.docmeta?.risk?.tags || c.metaV2?.risk?.tags || []));

const strategies = [
  () => (names.length ? formatQueryValue(pick(names)) : null),
  () => (signatures.length ? formatQueryValue(pick(signatures)) : null),
  () => (names.length && kinds.length ? formatQueryValue(`${pick(names)} ${pick(kinds)}`) : null),
  () => (returnTypes.length ? formatQueryValue(pick(returnTypes)) : null),
  () => (docs.length ? formatQueryValue(pick(docs)) : null),
  () => (riskTags.length ? formatQueryValue(pick(riskTags)) : null)
];

const seen = new Set();
const queries = [];
let attempts = 0;
while (queries.length < count && attempts < count * 20) {
  attempts += 1;
  const query = pick(strategies)();
  if (!query) continue;
  if (seen.has(query)) continue;
  seen.add(query);
  queries.push(query);
}

const payload = {
  generatedAt: new Date().toISOString(),
  seed,
  indexDir,
  mode,
  count: queries.length,
  queries
};

if (argv.json) {
  const outPath = argv.out ? path.resolve(argv.out) : path.join(root, 'docs', 'benchmarks-queries.json');
  await fs.writeFile(outPath, JSON.stringify(payload, null, 2));
  console.log(`Wrote ${queries.length} queries to ${outPath}`);
  process.exit(0);
}

const outPath = argv.out
  ? path.resolve(argv.out)
  : path.join(root, 'benchmarks', 'queries', `generated-${mode}.txt`);
const lines = [
  '# Generated by bench-query-generator',
  `# seed: ${seed}`,
  `# mode: ${mode}`,
  ...queries
];
await fs.mkdir(path.dirname(outPath), { recursive: true });
await fs.writeFile(outPath, lines.join('\n'));
console.log(`Wrote ${queries.length} queries to ${outPath}`);
