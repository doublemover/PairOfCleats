#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';

const parseArgs = () => {
  const out = { before: null, after: null, json: false };
  const argv = process.argv.slice(2);
  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    if (arg === '--before') {
      out.before = argv[i + 1] || null;
      i += 1;
      continue;
    }
    if (arg === '--after') {
      out.after = argv[i + 1] || null;
      i += 1;
      continue;
    }
    if (arg === '--json') {
      out.json = true;
      continue;
    }
    if (arg === '--help' || arg === '-h') {
      out.help = true;
      continue;
    }
  }
  return out;
};

const pickNumber = (metrics, keys) => {
  if (!metrics || typeof metrics !== 'object') return null;
  for (const key of keys) {
    const value = metrics[key];
    if (Number.isFinite(Number(value))) return Number(value);
  }
  return null;
};

const resolveDurationMs = (entry) => {
  const metrics = entry?.parsed?.current?.metrics || entry?.parsed?.baseline?.metrics || null;
  return pickNumber(metrics, ['duration', 'total', 'ms', 'totalMs']);
};

const main = async () => {
  const argv = parseArgs();
  if (argv.help) {
    console.log(
      [
        'bench-diff',
        '',
        'Usage:',
        '  node tools/bench/bench-diff.js --before <report.json> --after <report.json> [--json]',
        '',
        'Notes:',
        '- Reports are generated by tools/bench/bench-runner.js.',
        '- For each script, we compare parsed current duration when available.'
      ].join('\n')
    );
    return;
  }

  if (!argv.before || !argv.after) {
    console.error('bench-diff: missing --before or --after.');
    process.exit(2);
  }

  const beforePath = path.resolve(argv.before);
  const afterPath = path.resolve(argv.after);
  const before = JSON.parse(await fs.readFile(beforePath, 'utf8'));
  const after = JSON.parse(await fs.readFile(afterPath, 'utf8'));

  const indexResults = (report) => {
    const out = new Map();
    const results = Array.isArray(report?.results) ? report.results : [];
    for (const entry of results) {
      if (!entry?.script) continue;
      out.set(String(entry.script), entry);
    }
    return out;
  };

  const beforeMap = indexResults(before);
  const afterMap = indexResults(after);

  const scripts = Array.from(new Set([...beforeMap.keys(), ...afterMap.keys()])).sort();
  const diffs = [];
  for (const script of scripts) {
    const beforeEntry = beforeMap.get(script) || null;
    const afterEntry = afterMap.get(script) || null;
    const beforeMs = resolveDurationMs(beforeEntry);
    const afterMs = resolveDurationMs(afterEntry);
    const deltaMs = (beforeMs !== null && afterMs !== null) ? (afterMs - beforeMs) : null;
    const deltaPct = (beforeMs !== null && afterMs !== null && beforeMs !== 0)
      ? (deltaMs / beforeMs) * 100
      : null;
    diffs.push({
      script,
      beforeMs,
      afterMs,
      deltaMs,
      deltaPct
    });
  }

  if (argv.json) {
    process.stdout.write(`${JSON.stringify({ diffs }, null, 2)}\n`);
    return;
  }

  for (const row of diffs) {
    const beforeMs = row.beforeMs === null ? 'n/a' : row.beforeMs.toFixed(1);
    const afterMs = row.afterMs === null ? 'n/a' : row.afterMs.toFixed(1);
    const deltaMs = row.deltaMs === null ? 'n/a' : row.deltaMs.toFixed(1);
    const deltaPct = row.deltaPct === null ? 'n/a' : `${row.deltaPct.toFixed(1)}%`;
    console.log(`${row.script}: ${beforeMs}ms -> ${afterMs}ms (delta ${deltaMs}ms, ${deltaPct})`);
  }
};

main().catch((err) => {
  console.error(err?.stack || err?.message || String(err));
  process.exit(1);
});

