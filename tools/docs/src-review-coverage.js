#!/usr/bin/env node
import fsPromises from 'node:fs/promises';
import path from 'node:path';
import yargs from 'yargs/yargs';
import { hideBin } from 'yargs/helpers';
import { toPosix } from '../../src/shared/files.js';

const DEFAULT_MARKDOWN = 'docs/tooling/src-review-unreviewed-batches-2026-02-10.md';
const DEFAULT_JSON = 'docs/tooling/src-review-coverage.json';
const DEFAULT_MANIFEST = 'docs/tooling/dupemap-migration-manifest.json';
const DEFAULT_SOURCES = ['All_Findings.md', 'DUPEMAP.md'];

const extractSrcRefs = (text) => {
  const refs = new Set();
  const regex = /src\/[A-Za-z0-9._/-]+\.js/g;
  let match;
  while ((match = regex.exec(text)) !== null) {
    refs.add(match[0]);
  }
  return refs;
};

const listSrcFiles = async (dir) => {
  const entries = await fsPromises.readdir(dir, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...await listSrcFiles(fullPath));
      continue;
    }
    if (entry.isFile() && fullPath.endsWith('.js')) {
      files.push(fullPath);
    }
  }
  return files;
};

const readTextIfExists = async (filePath) => {
  try {
    return await fsPromises.readFile(filePath, 'utf8');
  } catch {
    return '';
  }
};

const normalizeSrcPath = (value) => {
  const raw = toPosix(String(value || '').trim());
  return raw.startsWith('src/') ? raw : '';
};

const mergeSet = (target, values) => {
  for (const value of values) {
    const normalized = normalizeSrcPath(value);
    if (normalized) target.add(normalized);
  }
};

const parseArgs = () => yargs(hideBin(process.argv))
  .scriptName('pairofcleats src-review-coverage')
  .option('root', { type: 'string', default: process.cwd() })
  .option('markdown', { type: 'string', default: DEFAULT_MARKDOWN })
  .option('json', { type: 'string', default: DEFAULT_JSON })
  .option('manifest', { type: 'string', default: DEFAULT_MANIFEST })
  .option('source', { type: 'string', array: true, default: DEFAULT_SOURCES })
  .option('min-coverage', { type: 'number', default: 1 })
  .option('check', { type: 'boolean', default: false })
  .help()
  .alias('h', 'help')
  .strictOptions()
  .parse();

const toSorted = (setLike) => Array.from(setLike).sort();

const ratio = (covered, total) => (
  total > 0 ? covered / total : 1
);

const normalizeMarkdownForCheck = (text) => String(text || '').replace(
  /^Generated at:\s+.+$/m,
  'Generated at: <generated-at>'
);

const normalizeJsonForCheck = (text) => {
  try {
    const parsed = JSON.parse(String(text || '{}'));
    if (parsed && typeof parsed === 'object') {
      parsed.generatedAt = '<generated-at>';
    }
    return `${JSON.stringify(parsed, null, 2)}\n`;
  } catch {
    return String(text || '');
  }
};

const renderMarkdown = ({
  generatedAt,
  srcFiles,
  baselineRefs,
  currentLedgerRefs,
  currentUncovered,
  minCoverage
}) => {
  const lockedRefs = new Set([...baselineRefs, ...srcFiles]);
  const baselineUncovered = srcFiles.filter((file) => !baselineRefs.has(file));
  const currentLockedRefs = new Set([...baselineRefs, ...currentLedgerRefs]);
  const currentCovered = srcFiles.length - currentUncovered.length;
  const currentCoverage = ratio(currentCovered, srcFiles.length);
  const minPercent = (minCoverage * 100).toFixed(2);
  const currentPercent = (currentCoverage * 100).toFixed(2);

  const lines = [
    '# src/** review coverage lock',
    '',
    'This file is generated by `node tools/docs/src-review-coverage.js`.',
    '',
    `Generated at: ${generatedAt}`,
    '',
    '## Coverage summary',
    `- src files total: ${srcFiles.length}`,
    `- Baseline findings references (without ledger): ${baselineRefs.size}`,
    `- Current ledger references: ${currentLedgerRefs.size}`,
    `- Current locked coverage: ${currentCovered}/${srcFiles.length} (${currentPercent}%)`,
    `- Required minimum coverage: ${minPercent}%`,
    `- Baseline gaps before ledger backfill: ${baselineUncovered.length}`,
    `- Locked coverage after regeneration target: ${lockedRefs.size}/${srcFiles.length} (100.00%)`,
    '',
    '## Coverage lock gate',
    '- CI/test gate runs: `node tools/docs/src-review-coverage.js --check`.',
    '- Any new `src/**` file must be captured here before CI passes.',
    '',
    '## Explicit coverage ledger (`src/**`)',
    ...srcFiles.map((file) => `- \`${file}\``),
    '',
    '## Current uncovered set (before regeneration)',
    ...(currentUncovered.length
      ? currentUncovered.map((file) => `- \`${file}\``)
      : ['- none']),
    ''
  ];

  return `${lines.join('\n')}\n`;
};

const main = async () => {
  const argv = parseArgs();
  const root = path.resolve(argv.root);
  const sourcePaths = (argv.source || []).map((source) => path.resolve(root, source));
  const manifestPath = path.resolve(root, argv.manifest);
  const markdownPath = path.resolve(root, argv.markdown);
  const jsonPath = path.resolve(root, argv.json);
  const srcRoot = path.join(root, 'src');
  const minCoverage = Number(argv['min-coverage']);
  if (!Number.isFinite(minCoverage) || minCoverage < 0 || minCoverage > 1) {
    throw new Error('min-coverage must be a finite number between 0 and 1.');
  }

  const srcFiles = (await listSrcFiles(srcRoot))
    .map((filePath) => toPosix(path.relative(root, filePath)))
    .sort();
  const srcSet = new Set(srcFiles);

  const baselineRefs = new Set();
  const sourceRefCounts = {};
  for (const sourcePath of sourcePaths) {
    const text = await readTextIfExists(sourcePath);
    const refs = extractSrcRefs(text);
    sourceRefCounts[toPosix(path.relative(root, sourcePath))] = refs.size;
    mergeSet(baselineRefs, refs);
  }

  try {
    const raw = await fsPromises.readFile(manifestPath, 'utf8');
    const manifest = JSON.parse(raw);
    const manifestRefs = new Set();
    for (const entry of manifest.migrations || []) {
      for (const key of ['oldPathOrSymbol', 'newPathOrSymbol']) {
        mergeSet(manifestRefs, extractSrcRefs(String(entry?.[key] || '')));
      }
    }
    sourceRefCounts[toPosix(path.relative(root, manifestPath))] = manifestRefs.size;
    mergeSet(baselineRefs, manifestRefs);
  } catch {
    sourceRefCounts[toPosix(path.relative(root, manifestPath))] = 0;
  }

  const currentLedgerText = await readTextIfExists(markdownPath);
  const currentLedgerRefs = new Set();
  mergeSet(currentLedgerRefs, extractSrcRefs(currentLedgerText));

  const currentLockedRefs = new Set([...baselineRefs, ...currentLedgerRefs]);
  const currentUncovered = srcFiles.filter((file) => !currentLockedRefs.has(file));
  const currentCovered = srcFiles.length - currentUncovered.length;
  const currentCoverage = ratio(currentCovered, srcFiles.length);

  const generatedAt = new Date().toISOString();
  const markdown = renderMarkdown({
    generatedAt,
    srcFiles,
    baselineRefs,
    currentLedgerRefs,
    currentUncovered,
    minCoverage
  });

  const targetLockedRefs = new Set([...baselineRefs, ...srcSet]);
  const targetUncovered = srcFiles.filter((file) => !targetLockedRefs.has(file));
  const report = {
    generatedAt,
    generatedBy: 'node tools/docs/src-review-coverage.js',
    root: toPosix(root),
    minCoverage,
    sources: {
      baseline: sourcePaths.map((sourcePath) => toPosix(path.relative(root, sourcePath))),
      manifest: toPosix(path.relative(root, manifestPath)),
      coverageLedger: toPosix(path.relative(root, markdownPath)),
      referenceCounts: sourceRefCounts
    },
    current: {
      srcFilesTotal: srcFiles.length,
      referencedCount: currentLockedRefs.size,
      uncoveredCount: currentUncovered.length,
      uncovered: currentUncovered,
      coverageRatio: currentCoverage
    },
    target: {
      srcFilesTotal: srcFiles.length,
      referencedCount: targetLockedRefs.size,
      uncoveredCount: targetUncovered.length,
      uncovered: targetUncovered,
      coverageRatio: ratio(srcFiles.length - targetUncovered.length, srcFiles.length)
    },
    baseline: {
      referencedCount: baselineRefs.size,
      uncoveredCount: srcFiles.filter((file) => !baselineRefs.has(file)).length
    },
    srcFiles
  };
  const reportText = `${JSON.stringify(report, null, 2)}\n`;

  if (argv.check) {
    const [existingMarkdown, existingJson] = await Promise.all([
      readTextIfExists(markdownPath),
      readTextIfExists(jsonPath)
    ]);
    const coverageTooLow = currentCoverage < minCoverage;
    const markdownMismatch = normalizeMarkdownForCheck(existingMarkdown) !== normalizeMarkdownForCheck(markdown);
    const jsonMismatch = normalizeJsonForCheck(existingJson) !== normalizeJsonForCheck(reportText);
    if (coverageTooLow || markdownMismatch || jsonMismatch) {
      console.error('src-review coverage lock failed.');
      if (coverageTooLow) {
        console.error(`Current coverage ${(currentCoverage * 100).toFixed(2)}% is below required ${(minCoverage * 100).toFixed(2)}%.`);
        const preview = toSorted(currentUncovered).slice(0, 25);
        if (preview.length) {
          console.error('Uncovered sample:');
          for (const file of preview) console.error(`- ${file}`);
          if (currentUncovered.length > preview.length) {
            console.error(`...and ${currentUncovered.length - preview.length} more.`);
          }
        }
      }
      if (markdownMismatch || jsonMismatch) {
        console.error('Run: node tools/docs/src-review-coverage.js');
      }
      process.exit(1);
    }
    console.log('src review coverage lock check passed');
    return;
  }

  await fsPromises.mkdir(path.dirname(markdownPath), { recursive: true });
  await fsPromises.mkdir(path.dirname(jsonPath), { recursive: true });
  await Promise.all([
    fsPromises.writeFile(markdownPath, markdown, 'utf8'),
    fsPromises.writeFile(jsonPath, reportText, 'utf8')
  ]);

  console.log(`Wrote ${toPosix(path.relative(root, markdownPath))}`);
  console.log(`Wrote ${toPosix(path.relative(root, jsonPath))}`);
};

main().catch((error) => {
  console.error(error?.message || String(error));
  process.exit(1);
});
