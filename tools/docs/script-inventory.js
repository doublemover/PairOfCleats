#!/usr/bin/env node
import fsPromises from 'node:fs/promises';
import path from 'node:path';
import yargs from 'yargs/yargs';
import { hideBin } from 'yargs/helpers';
import {
  SERVICE_INDEXER_OPTIONS,
  resolveCliOptionFlagSets
} from '../../src/shared/cli-options.js';

const parseArgs = () => {
  const parser = yargs(hideBin(process.argv))
    .scriptName('pairofcleats script-inventory')
    .option('json', { type: 'string', default: 'docs/tooling/script-inventory.json' })
    .option('markdown', { type: 'string', default: 'docs/guides/commands.md' })
    .help()
    .alias('h', 'help')
    .strictOptions();
  return parser.parse();
};

const categoryFor = (name) => {
  if (name === 'lint' || name === 'format') return 'lint';
  if (name.startsWith('test')) return 'test';
  if (name.startsWith('bench')) return 'bench';
  if (name.startsWith('config')) return 'config';
  if (name.startsWith('ci-') || name.startsWith('release')) return 'release';
  if (name.includes('install') || name.includes('download')) return 'tooling';
  if (name.includes('index') || name.includes('search')) return 'indexing';
  return 'tooling';
};

const ciAllowlist = new Set([
  'lint',
  'format',
  'config:budget',
  'env:check',
  'test',
  'test:pr',
  'test:nightly',
  'test:ci',
  'verify'
]);

const CLI_ENTRYPOINTS = Object.freeze([
  Object.freeze({
    command: 'pairofcleats service api',
    summary: 'Run local HTTP JSON API service.'
  }),
  Object.freeze({
    command: 'pairofcleats service indexer',
    summary: 'Run indexer service queue/worker.'
  }),
  Object.freeze({
    command: 'pairofcleats ingest ctags',
    summary: 'Ingest ctags JSONL symbols into normalized records.'
  }),
  Object.freeze({
    command: 'pairofcleats ingest gtags',
    summary: 'Ingest GNU Global symbols into normalized records.'
  }),
  Object.freeze({
    command: 'pairofcleats ingest lsif',
    summary: 'Ingest LSIF dumps into normalized records.'
  }),
  Object.freeze({
    command: 'pairofcleats ingest scip',
    summary: 'Ingest SCIP indexes into normalized records.'
  })
]);

const readPhaseSpecs = async (root) => {
  const phaseDir = path.join(root, 'docs', 'phases', 'phase-3');
  try {
    const entries = await fsPromises.readdir(phaseDir, { withFileTypes: true });
    return entries
      .filter((entry) => entry.isFile() && entry.name.endsWith('.md'))
      .map((entry) => `docs/phases/phase-3/${entry.name}`)
      .sort();
  } catch {
    return [];
  }
};

const main = async () => {
  const argv = parseArgs();
  const root = process.cwd();
  const pkg = JSON.parse(await fsPromises.readFile(path.join(root, 'package.json'), 'utf8'));
  const scripts = pkg.scripts || {};
  const inventory = Object.keys(scripts).sort().map((name) => ({
    name,
    category: categoryFor(name),
    ciAllowed: ciAllowlist.has(name) || name.startsWith('test:'),
    replacement: null
  }));
  const { optionNames: serviceIndexerFlags, valueOptionNames: serviceIndexerValueFlags } = resolveCliOptionFlagSets(
    SERVICE_INDEXER_OPTIONS
  );
  const phaseSpecs = await readPhaseSpecs(root);

  const jsonPath = path.resolve(root, argv.json);
  await fsPromises.mkdir(path.dirname(jsonPath), { recursive: true });
  await fsPromises.writeFile(
    jsonPath,
    `${JSON.stringify({
      generatedAt: new Date().toISOString(),
      scripts: inventory,
      cliCommands: CLI_ENTRYPOINTS
    }, null, 2)}\n`
  );

  const markdownPath = path.resolve(root, argv.markdown);
  const lines = [
    '# Script Inventory',
    '',
    'This file is generated by `node tools/docs/script-inventory.js`.',
    '',
    '## Phase 3 specs',
    ...phaseSpecs.map((spec) => `- \`${spec}\``),
    '',
    '## CLI entrypoints',
    ...CLI_ENTRYPOINTS.map((entry) => `- \`${entry.command}\` - ${entry.summary}`),
    '- `pairofcleats service indexer` flags:',
    `  - allowed: ${serviceIndexerFlags.map((flag) => `--${flag}`).join(', ')}`,
    `  - requires values: ${serviceIndexerValueFlags.map((flag) => `--${flag}`).join(', ')}`,
    '',
    '## Stable entrypoints',
    '- `node tests/run.js` (repo-local test runner)',
    '- `node tools/ci/run-suite.js --mode ci` (CI suite)',
    '- `node tools/ci/run-suite.js --mode nightly` (nightly suite)',
    '- `npm run lint`',
    '- `npm run format`',
    '- `npm run config:budget`',
    '- `npm run env:check`',
    '',
    'Prefer `pairofcleats search`, `pairofcleats index build`, and `pairofcleats index watch` for user-facing workflows.',
    'Index build/watch SCM flags: `--scm-provider <auto|git|jj|none>`, `--scm-annotate`, `--no-scm-annotate`.',
    'See `docs/guides/mcp.md` for MCP server modes, capabilities, and error codes.',
    '',
    '| Script | Category | CI Allowed | Replacement |',
    '| --- | --- | --- | --- |',
    ...inventory.map((entry) => `| \`${entry.name}\` | ${entry.category} | ${entry.ciAllowed ? 'yes' : 'no'} | ${entry.replacement || ''} |`),
    ''
  ];
  await fsPromises.mkdir(path.dirname(markdownPath), { recursive: true });
  await fsPromises.writeFile(markdownPath, `${lines.join('\n')}\n`);
};

main().catch((error) => {
  console.error(error?.message || String(error));
  process.exit(1);
});
