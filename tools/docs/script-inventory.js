#!/usr/bin/env node
import fsPromises from 'node:fs/promises';
import path from 'node:path';
import { createCli } from '../../src/shared/cli.js';
import {
  SERVICE_INDEXER_OPTIONS,
  resolveCliOptionFlagSets
} from '../../src/shared/cli-options.js';
import { listDispatchManifest } from '../../src/shared/dispatch/manifest.js';

const parseArgs = () => createCli({
  scriptName: 'pairofcleats script-inventory',
  options: {
    json: { type: 'string', default: 'docs/tooling/script-inventory.json' },
    markdown: { type: 'string', default: 'docs/guides/commands.md' },
    'phase-spec-dir': { type: 'string' }
  }
})
  .strictOptions()
  .parse();

const categoryFor = (name) => {
  if (name === 'lint' || name === 'format') return 'lint';
  if (name.startsWith('test')) return 'test';
  if (name.startsWith('bench')) return 'bench';
  if (name.startsWith('config')) return 'config';
  if (name.startsWith('ci-') || name.startsWith('release')) return 'release';
  if (name.includes('install') || name.includes('download')) return 'tooling';
  if (name.includes('index') || name.includes('search')) return 'indexing';
  return 'tooling';
};

const ciAllowlist = new Set([
  'lint',
  'format',
  'config:budget',
  'env:check',
  'test',
  'test:pr',
  'test:nightly',
  'test:ci',
  'verify'
]);

const resolveCliEntrypoints = () => {
  const entries = listDispatchManifest()
    .map((entry) => ({
      command: `pairofcleats ${entry.commandPath.join(' ')}`,
      summary: String(entry.description || '').trim() || 'No summary available.'
    }))
    .sort((a, b) => a.command.localeCompare(b.command));
  return Array.from(
    new Map(entries.map((entry) => [entry.command, entry])).values()
  );
};

const discoverPhaseSpecDir = async (root, explicitDir) => {
  if (explicitDir && String(explicitDir).trim()) {
    return path.resolve(root, String(explicitDir).trim());
  }
  const phasesRoot = path.join(root, 'docs', 'phases');
  try {
    const entries = await fsPromises.readdir(phasesRoot, { withFileTypes: true });
    const candidates = entries
      .filter((entry) => entry.isDirectory() && /^phase-\d+$/i.test(entry.name))
      .map((entry) => ({
        name: entry.name,
        order: Number((/^phase-(\d+)$/i.exec(entry.name) || [])[1] || 0)
      }))
      .sort((a, b) => b.order - a.order || a.name.localeCompare(b.name));
    if (!candidates.length) return null;
    return path.join(phasesRoot, candidates[0].name);
  } catch {
    return null;
  }
};

const readPhaseSpecs = async (root, requestedPhaseDir = null) => {
  const phaseDir = await discoverPhaseSpecDir(root, requestedPhaseDir);
  if (!phaseDir) {
    return { phaseDir: null, specs: [] };
  }
  const relPhaseDir = path.relative(root, phaseDir).replace(/\\/g, '/');
  try {
    const entries = await fsPromises.readdir(phaseDir, { withFileTypes: true });
    return {
      phaseDir: relPhaseDir,
      specs: entries
        .filter((entry) => entry.isFile() && entry.name.endsWith('.md'))
        .map((entry) => `${relPhaseDir}/${entry.name}`)
        .sort()
    };
  } catch {
    return { phaseDir: relPhaseDir, specs: [] };
  }
};

const main = async () => {
  const argv = parseArgs();
  const root = process.cwd();
  const pkg = JSON.parse(await fsPromises.readFile(path.join(root, 'package.json'), 'utf8'));
  const scripts = pkg.scripts || {};
  const inventory = Object.keys(scripts).sort().map((name) => ({
    name,
    category: categoryFor(name),
    ciAllowed: ciAllowlist.has(name) || name.startsWith('test:'),
    replacement: null
  }));
  const { optionNames: serviceIndexerFlags, valueOptionNames: serviceIndexerValueFlags } = resolveCliOptionFlagSets(
    SERVICE_INDEXER_OPTIONS
  );
  const phaseSpecInfo = await readPhaseSpecs(root, argv['phase-spec-dir']);
  const cliEntrypoints = resolveCliEntrypoints();

  const jsonPath = path.resolve(root, argv.json);
  await fsPromises.mkdir(path.dirname(jsonPath), { recursive: true });
  await fsPromises.writeFile(
    jsonPath,
    `${JSON.stringify({
      generatedAt: new Date().toISOString(),
      scripts: inventory,
      cliCommands: cliEntrypoints,
      phaseSpecDir: phaseSpecInfo.phaseDir
    }, null, 2)}\n`
  );

  const markdownPath = path.resolve(root, argv.markdown);
  const lines = [
    '# Script Inventory',
    '',
    'This file is generated by `node tools/docs/script-inventory.js`.',
    '',
    '## Active phase specs',
    ...(phaseSpecInfo.phaseDir ? [`- directory: \`${phaseSpecInfo.phaseDir}\``] : ['- directory: _none detected_']),
    ...phaseSpecInfo.specs.map((spec) => `- \`${spec}\``),
    '',
    '## CLI entrypoints',
    ...cliEntrypoints.map((entry) => `- \`${entry.command}\` - ${entry.summary}`),
    '- `pairofcleats service indexer` flags:',
    `  - allowed: ${serviceIndexerFlags.map((flag) => `--${flag}`).join(', ')}`,
    `  - requires values: ${serviceIndexerValueFlags.map((flag) => `--${flag}`).join(', ')}`,
    '',
    '## Stable entrypoints',
    '- `node tests/run.js` (repo-local test runner)',
    '- `node tools/ci/run-suite.js --mode ci` (CI suite)',
    '- `node tools/ci/run-suite.js --mode nightly` (nightly suite)',
    '- `npm run lint`',
    '- `npm run format`',
    '- `npm run config:budget`',
    '- `npm run env:check`',
    '',
    'Prefer `pairofcleats search`, `pairofcleats index build`, and `pairofcleats index watch` for user-facing workflows.',
    'Index build/watch SCM flags: `--scm-provider <auto|git|jj|none>`, `--scm-annotate`, `--no-scm-annotate`.',
    'See `docs/guides/mcp.md` for MCP server modes, capabilities, and error codes.',
    '',
    '| Script | Category | CI Allowed | Replacement |',
    '| --- | --- | --- | --- |',
    ...inventory.map((entry) => `| \`${entry.name}\` | ${entry.category} | ${entry.ciAllowed ? 'yes' : 'no'} | ${entry.replacement || ''} |`),
    ''
  ];
  await fsPromises.mkdir(path.dirname(markdownPath), { recursive: true });
  await fsPromises.writeFile(markdownPath, `${lines.join('\n')}\n`);
};

main().catch((error) => {
  console.error(error?.message || String(error));
  process.exit(1);
});
