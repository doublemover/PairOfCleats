#!/usr/bin/env node
import fs from 'node:fs';
import fsPromises from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';
import yargs from 'yargs/yargs';
import { hideBin } from 'yargs/helpers';
import { collectSchemaEntries } from './config-inventory/schema.js';
import { INDEX_BUILD_OPTIONS } from '../src/shared/cli-options.js';

const normalizeEnum = (value) => {
  if (!Array.isArray(value) || !value.length) return '';
  return ` enum=${value.join('|')}`;
};

const normalizeType = (value) => (value ? ` (${value})` : '');

const detectLineEnding = (text) => (text.includes('\r\n') ? '\r\n' : '\n');

const detectBom = (text) => text.startsWith('\uFEFF');

const stripBom = (text) => (detectBom(text) ? text.slice(1) : text);

const collectDefaults = (schema, prefix = '', entries = []) => {
  if (!schema || typeof schema !== 'object') return entries;
  const properties = schema.properties && typeof schema.properties === 'object'
    ? schema.properties
    : null;
  if (properties) {
    for (const [key, child] of Object.entries(properties)) {
      const pathKey = prefix ? `${prefix}.${key}` : key;
      if (Object.prototype.hasOwnProperty.call(child, 'default')) {
        entries.push({ path: pathKey, value: child.default });
      }
      collectDefaults(child, pathKey, entries);
    }
  }
  return entries;
};

const extractSearchFlags = (source) => {
  const startToken = 'const options = {';
  const startIndex = source.indexOf(startToken);
  if (startIndex === -1) return [];
  const slice = source.slice(startIndex + startToken.length);
  const endIndex = slice.indexOf('};');
  if (endIndex === -1) return [];
  const block = slice.slice(0, endIndex);
  const regex = /^\s*['"]?([A-Za-z0-9-]+)['"]?\s*:\s*\{/gm;
  const flags = new Set();
  let match;
  while ((match = regex.exec(block))) {
    flags.add(match[1]);
  }
  return Array.from(flags).sort();
};

const extractEnvMappings = (source) => {
  const mappings = new Map();
  const mappingRegex = /^\s*([a-zA-Z0-9]+):\s*[^\n]*env\.([A-Z0-9_]+)/gm;
  let match;
  while ((match = mappingRegex.exec(source))) {
    const key = match[1];
    const envVar = match[2];
    const existing = mappings.get(envVar) || new Set();
    existing.add(key);
    mappings.set(envVar, existing);
  }
  if (source.includes('const mcpMode')) {
    const envVars = ['PAIROFCLEATS_MCP_MODE', 'MCP_MODE'];
    for (const envVar of envVars) {
      const existing = mappings.get(envVar) || new Set();
      existing.add('mcpMode');
      mappings.set(envVar, existing);
    }
  }
  const envVarRegex = /env\.([A-Z0-9_]+)/g;
  const envVars = new Set();
  while ((match = envVarRegex.exec(source))) {
    envVars.add(match[1]);
  }
  return { envVars: Array.from(envVars).sort(), mappings };
};

const renderEnvList = (envVars, mappings) => {
  if (!envVars.length) return ['- (none)'];
  return envVars.map((name) => {
    const mapped = mappings.get(name);
    if (!mapped || mapped.size === 0) return `- ${name}`;
    const targets = Array.from(mapped).sort();
    return `- ${name} -> ${targets.join(', ')}`;
  });
};

export const buildConfigContractDoc = (options = {}) => {
  const root = options.root ? path.resolve(options.root) : process.cwd();
  const schemaPath = options.schemaPath
    ? path.resolve(root, options.schemaPath)
    : path.join(root, 'docs', 'config', 'schema.json');
  const envPath = options.envPath
    ? path.resolve(root, options.envPath)
    : path.join(root, 'src', 'shared', 'env.js');
  const searchArgsPath = options.searchArgsPath
    ? path.resolve(root, options.searchArgsPath)
    : path.join(root, 'src', 'retrieval', 'cli-args.js');
  const eol = options.lineEnding || '\n';
  const includeBom = options.includeBom === true;

  const schemaRaw = fs.readFileSync(schemaPath, 'utf8');
  const schema = JSON.parse(schemaRaw);
  const entries = collectSchemaEntries(schema);
  const defaults = collectDefaults(schema);
  const topLevel = Object.keys(schema.properties || {}).sort();

  const envSource = fs.readFileSync(envPath, 'utf8');
  const envInfo = extractEnvMappings(envSource);
  const runtimeEnv = envInfo.envVars.filter((name) => !name.startsWith('PAIROFCLEATS_TEST_') && name !== 'PAIROFCLEATS_TESTING');
  const testEnv = envInfo.envVars.filter((name) => name.startsWith('PAIROFCLEATS_TEST_') || name === 'PAIROFCLEATS_TESTING');

  const buildFlags = Object.entries(INDEX_BUILD_OPTIONS)
    .map(([key, value]) => ({ key, alias: value?.alias }))
    .sort((a, b) => a.key.localeCompare(b.key));

  const searchSource = fs.readFileSync(searchArgsPath, 'utf8');
  const searchFlags = extractSearchFlags(searchSource);

  const lines = [];
  lines.push('# Config Contract');
  lines.push('');
  lines.push('This file is generated by `node tools/config-contract-doc.js`.');
  lines.push('Sources:');
  lines.push('- `docs/config/schema.json` (config keys + enums)');
  lines.push('- `src/shared/env.js` (env overrides)');
  lines.push('');
  lines.push('## Top-level namespaces');
  lines.push('');
  for (const key of topLevel) {
    lines.push(`- ${key}`);
  }
  lines.push('');
  lines.push('## Config keys (full list)');
  lines.push('');
  lines.push('```');
  const sortedEntries = entries.slice().sort((a, b) => a.path.localeCompare(b.path));
  for (const entry of sortedEntries) {
    const type = normalizeType(entry.type);
    const enums = normalizeEnum(entry.enum);
    lines.push(`${entry.path}${type}${enums}`.trim());
  }
  lines.push('```');
  lines.push('');
  lines.push('## Defaults');
  lines.push('');
  if (!defaults.length) {
    lines.push('- (no defaults declared in schema)');
  } else {
    for (const entry of defaults.sort((a, b) => a.path.localeCompare(b.path))) {
      lines.push(`- ${entry.path} = ${JSON.stringify(entry.value)}`);
    }
  }
  lines.push('');
  lines.push('## Env overrides (runtime)');
  lines.push('');
  lines.push(...renderEnvList(runtimeEnv, envInfo.mappings));
  lines.push('');
  lines.push('## Env overrides (test-only, require PAIROFCLEATS_TESTING=1)');
  lines.push('');
  lines.push(...renderEnvList(testEnv, envInfo.mappings));
  lines.push('');
  lines.push('## CLI flags');
  lines.push('');
  lines.push('### build_index / pairofcleats index build');
  lines.push('');
  for (const entry of buildFlags) {
    const alias = entry.alias
      ? ` (alias: ${Array.isArray(entry.alias) ? entry.alias.join(', ') : entry.alias})`
      : '';
    lines.push(`- --${entry.key}${alias}`);
  }
  lines.push('');
  lines.push('### search / pairofcleats search');
  lines.push('');
  for (const flag of searchFlags) {
    lines.push(`- --${flag}`);
  }
  lines.push('');
  lines.push('Notes:');
  lines.push('- Boolean flags accept `--no-<flag>` unless a command overrides negation behavior.');
  lines.push('- Search options list is derived from `src/retrieval/cli-args.js`.');

  const docBody = lines.join(eol) + eol;
  return includeBom ? `\uFEFF${docBody}` : docBody;
};

const parseArgs = () => {
  const parser = yargs(hideBin(process.argv))
    .scriptName('pairofcleats config-contract-doc')
    .option('schema', { type: 'string', default: 'docs/config/schema.json' })
    .option('env', { type: 'string', default: 'src/shared/env.js' })
    .option('search-args', { type: 'string', default: 'src/retrieval/cli-args.js' })
    .option('out', { type: 'string', default: 'docs/config/contract.md' })
    .help()
    .alias('h', 'help')
    .strictOptions();
  return parser.parse();
};

const main = async () => {
  const argv = parseArgs();
  const root = process.cwd();
  const outPath = path.resolve(root, argv.out);
  let lineEnding = '\n';
  let includeBom = false;
  try {
    const existing = await fsPromises.readFile(outPath, 'utf8');
    lineEnding = detectLineEnding(existing);
    includeBom = detectBom(existing);
  } catch {}

  const doc = buildConfigContractDoc({
    root,
    schemaPath: argv.schema,
    envPath: argv.env,
    searchArgsPath: argv['search-args'],
    lineEnding,
    includeBom
  });

  await fsPromises.mkdir(path.dirname(outPath), { recursive: true });
  await fsPromises.writeFile(outPath, doc);
};

const isCli = pathToFileURL(process.argv[1] || '').href === import.meta.url;
if (isCli) {
  main().catch((error) => {
    console.error(error?.message || String(error));
    process.exit(1);
  });
}
