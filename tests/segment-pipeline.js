#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';
import { discoverSegments, chunkSegments } from '../src/index/segments.js';
import { extractComments, normalizeCommentConfig } from '../src/index/comments.js';
import { buildLineIndex } from '../src/shared/lines.js';

const root = process.cwd();
const fixtureRoot = path.join(root, 'tests', 'fixtures', 'segments');

const assert = (condition, message) => {
  if (condition) return;
  console.error(message);
  process.exit(1);
};

const mdPath = path.join(fixtureRoot, 'docs', 'guide.md');
const mdText = fs.readFileSync(mdPath, 'utf8');
const mdSegments = discoverSegments({
  text: mdText,
  ext: '.md',
  relPath: 'docs/guide.md',
  mode: 'prose',
  segmentsConfig: { inlineCodeSpans: true }
});
assert(mdSegments.some((seg) => seg.type === 'config' && seg.meta?.frontmatter), 'Expected markdown frontmatter segment.');
const fencedSegments = mdSegments.filter((seg) => seg.type === 'embedded' && seg.meta?.fenceInfo);
assert(fencedSegments.some((seg) => String(seg.meta.fenceInfo).includes('js')), 'Expected markdown JS fenced segment.');
assert(fencedSegments.some((seg) => String(seg.meta.fenceInfo).includes('json')), 'Expected markdown JSON fenced segment.');
const inlineSegments = mdSegments.filter((seg) => seg.meta?.inlineCode);
assert(inlineSegments.length === 2, `Expected 2 inline code segments, got ${inlineSegments.length}.`);

const mdChunks = chunkSegments({
  text: mdText,
  ext: '.md',
  relPath: 'docs/guide.md',
  mode: 'prose',
  segments: mdSegments,
  lineIndex: buildLineIndex(mdText),
  context: {}
});
let lastStart = -1;
for (const chunk of mdChunks) {
  assert(chunk.start >= 0 && chunk.end <= mdText.length, 'Markdown chunk range invalid.');
  assert(chunk.segment, 'Markdown chunk missing segment metadata.');
  assert(chunk.start >= lastStart, 'Markdown chunks are out of order.');
  lastStart = chunk.start;
}

const vuePath = path.join(fixtureRoot, 'src', 'component.vue');
const vueText = fs.readFileSync(vuePath, 'utf8');
const vueSegments = discoverSegments({
  text: vueText,
  ext: '.vue',
  relPath: 'src/component.vue',
  mode: 'code'
});
assert(vueSegments.some((seg) => seg.meta?.block === 'template'), 'Expected Vue template segment.');
assert(vueSegments.some((seg) => seg.meta?.block === 'script' || seg.meta?.block === 'scriptSetup'), 'Expected Vue script segment.');
assert(vueSegments.some((seg) => seg.meta?.block === 'style'), 'Expected Vue style segment.');

const sveltePath = path.join(fixtureRoot, 'src', 'widget.svelte');
const svelteText = fs.readFileSync(sveltePath, 'utf8');
const svelteSegments = discoverSegments({
  text: svelteText,
  ext: '.svelte',
  relPath: 'src/widget.svelte',
  mode: 'code'
});
assert(svelteSegments.some((seg) => seg.meta?.block === 'script'), 'Expected Svelte script segment.');
assert(svelteSegments.some((seg) => seg.meta?.block === 'style'), 'Expected Svelte style segment.');
assert(svelteSegments.some((seg) => seg.meta?.block === 'template'), 'Expected Svelte template segment.');

const astroPath = path.join(fixtureRoot, 'src', 'page.astro');
const astroText = fs.readFileSync(astroPath, 'utf8');
const astroSegments = discoverSegments({
  text: astroText,
  ext: '.astro',
  relPath: 'src/page.astro',
  mode: 'code'
});
assert(astroSegments.some((seg) => seg.meta?.block === 'frontmatter'), 'Expected Astro frontmatter segment.');
assert(astroSegments.some((seg) => seg.meta?.block === 'template'), 'Expected Astro template segment.');
assert(astroSegments.some((seg) => seg.meta?.block === 'style'), 'Expected Astro style segment.');

const commentPath = path.join(fixtureRoot, 'src', 'comments.js');
const commentText = fs.readFileSync(commentPath, 'utf8');
const commentConfig = normalizeCommentConfig({ extract: 'all', includeLicense: false });
const commentData = extractComments({
  text: commentText,
  ext: '.js',
  languageId: 'javascript',
  lineIndex: buildLineIndex(commentText),
  config: commentConfig
});
assert(commentData.comments.some((comment) => comment.type === 'doc'), 'Expected doc comment extracted.');
assert(commentData.comments.some((comment) => comment.type === 'inline'), 'Expected inline comment extracted.');
assert(commentData.comments.some((comment) => comment.type === 'block'), 'Expected block comment extracted.');
assert(commentData.comments.some((comment) => comment.type === 'license'), 'Expected license comment extracted.');
assert(!commentData.comments.some((comment) => comment.text.includes('eslint-disable')), 'Expected linter comment to be skipped.');
assert(!commentData.comments.some((comment) => comment.text.includes('generated by')), 'Expected generated comment to be skipped.');
assert(commentData.configSegments.some((segment) => segment.languageId === 'json' && segment.meta?.source === 'comment'), 'Expected JSON config segment from comment.');

console.log('segment pipeline tests passed');
