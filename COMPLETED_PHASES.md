# Completed Phases 

Any time a phase is fully completed, AFTER it has been merged into main:
  - The numbering and ordering of phases does not matter whatsoever
  - Remove the phase from the current roadmap
  - Append the Title and a brief, single item summary 
  - Some phase numbers are reused 
  - Nothing in this document should be treated as authoritative, refer to code for truth

Completed phase snapshots are archived here after being removed from GIGAROADMAP.md. 

---

- Phase R -- Make Monoliths Modular, My Man

## Phase R -- Refactor MegaCut 

---

### R.0 Refactor playbook (applies to every subtask)

**Goal:** Split “fat” modules into cohesive, testable, side-effect-minimized modules **without changing behavior**.

**Hard rules**
- **No behavior changes** unless explicitly called out in the task’s “Behavior deltas” section.
- **Preserve public entrypoints.** If you move code, keep a tiny compatibility shim at the old path that re-exports the same names.
- **Keep ESM import style** (repo is `"type": "module"`; keep `.js` extensions on relative imports).
- **No new global state**; prefer pure helpers and dependency injection (pass `log`, `signal`, configs, caches).
- **Avoid circular imports** by extracting shared primitives to `src/shared/**` and keeping “leaf” modules free of imports from high-level orchestrators.

**PR checklist**
- [x] New modules have a single responsibility and minimal export surface.
- [x] All call sites updated (or compatibility re-export added).
- [x] All relevant tests pass:
  - `node tests/run.js --lane pr` (preferred) or `npm run test:pr`
  - plus any targeted tests called out per task.
- [x] `npm run lint` passes.
- [x] File sizes: prefer < ~500 LOC for “leaf” modules; orchestrators may be larger but should be mostly glue.

---

### R.1 Script surface policy + docs (package.json sprawl)

**Spec conflict (resolved):** The original Phase R.1 demanded `package.json` scripts be reduced to <10.  
The current repo has already adopted a **policy-based approach** instead:
- `tools/script-inventory.js` generates `docs/tooling/script-inventory.json` and `docs/guides/commands.md`.
- `tests/indexing/policy/script-surface-policy.test.js` enforces that the inventory matches `package.json`.

This is a better trade-off than “<10 scripts” because:
- Many scripts are intentionally “debuggable entrypoints” for specific tests/tools.
- The repo has explicit policy + inventory tooling already; rewriting the entire script surface would be noisy and high-churn.

#### R.1.1 Script inventory + policy enforcement
- [x] Keep `tools/script-inventory.js` as the single generator for:
  - `docs/tooling/script-inventory.json`
  - `docs/guides/commands.md`
- [x] Keep `tests/indexing/policy/script-surface-policy.test.js` enforcing inventory ↔ package parity.

**Callouts**
- Generator: `tools/script-inventory.js`
- Inventory: `docs/tooling/script-inventory.json`
- Policy test: `tests/indexing/policy/script-surface-policy.test.js`

#### R.1.2 Fix doc drift: commands.md must be reproducible
- [x] Resolve the current mismatch where `docs/guides/commands.md` contains a “Phase 3 specs” section that **is not emitted** by `tools/script-inventory.js`.
  - **Best choice:** make `commands.md` purely generated; either:
    1) Update generator to also emit a “Phase specs” section (recommended), or  
    2) Remove the non-generated section from `commands.md` and move it to a separate doc (less ideal; increases doc surface).
- [x] Add a policy test to prevent future drift:
  - New test file: `tests/indexing/policy/script-inventory-docs.test.js`
  - It should run the generator in-memory and compare against `docs/guides/commands.md` OR at minimum assert:
    - the “generated by” header is present
    - the “Stable entrypoints” block matches the generator’s output
    - the script table contains the same script names as inventory

**Why option (1) is recommended:**  
The repo already treats `commands.md` as generated. Making the generator responsible for *all* its sections is the only way to keep it deterministic and enforceable.

#### R.1.3 Tighten the “stable entrypoints” contract
- [x] Document (and keep stable) the following script entrypoints:
  - `test`, `test:pr`, `test:nightly`, `lint`, `format`, `config:budget`, `env:check`, `verify`
- [x] Update any user-facing docs / error messages that reference non-stable scripts to prefer:
  - `pairofcleats ...` CLI entrypoints (preferred for users)
  - or `node <script>` for internal tools
- [x] Add a lightweight test that fails if “stable entrypoints” are removed/renamed without updating docs/tooling/script-inventory.json.

---

### R.2 Repo hygiene + drift-proofing

#### R.2.1 AGENTS.md coverage
- [x] Ensure `AGENTS.md` lists the primary docs to read and how to run tests/lint.
- [x] Add an explicit pointer to the script policy docs:
  - `docs/tooling/script-inventory.json`
  - `docs/guides/commands.md`
  - The enforcement test: `tests/indexing/policy/script-surface-policy.test.js`

#### R.2.2 Drift-proofing for docs ↔ code contracts
- [x] Keep the existing “policy tests” approach (see `tests/policy/**`) for anything that otherwise drifts silently.

#### R.2.3 Optional: sweep stale files (low-risk cleanup)
- [x] Add a non-destructive report script (no deletions) that inventories:
  - orphan docs (not referenced by any “Docs to read” list)
  - orphan tools (not referenced by any script/CLI)
  - orphan scripts (not referenced by docs/CI/tests)
- Suggested location: `tools/repo-inventory.js`
- Output: `docs/tooling/repo-inventory.json`
- [x] Add a policy test that only checks the file exists + JSON schema sanity (don’t gate PRs on the contents yet).

---

### R.3 Shared primitives (extract early, reuse everywhere)

These have landed and should be used as the canonical helpers.

#### R.3.1 Backoff/retry helper
- [x] `src/shared/retry.js` exports `retryWithBackoff({ attempts, minDelayMs, maxDelayMs, factor, jitter, shouldRetry, operation, signal })`
- [x] Used by `src/index/build/watch/lock.js` to implement `acquireIndexLockWithBackoff(...)`.
- Tests (existing): `tests/indexing/watch/watch-lock-backoff.test.js`

**Follow-up**
- [x] Add a small direct unit test for `retryWithBackoff` itself (optional but improves locality):
  - New: `tests/shared/concurrency/retry-with-backoff.test.js`
  - Cover: abort signal, shouldRetry false, jitter bounds, attempts=1 behavior.

#### R.3.2 Debounce scheduler
- [x] `src/shared/scheduler/debounce.js` exports `createDebouncedScheduler({ delayMs, maxDelayMs, onFlush })`
- [x] Used by watch pipeline (via `src/index/build/watch.js`).
- Tests (existing): `tests/indexing/watch/watch-debounce.test.js`

#### R.3.3 Ignore matcher helper (path + chokidar semantics)
- [x] `src/shared/fs/ignore.js` exports `buildIgnoredMatcher({ root, ignoreMatcher })` for chokidar-compatible ignores.
- [x] Add a dedicated test for “directory ignore vs file ignore” semantics:
  - New: `tests/indexing/ignore/ignore-matcher.test.js`
  - Cases:
    - ignoreMatcher matches a directory: should ignore descendants (simulate `stats.isDirectory()` true)
    - ignoreMatcher matches a file path: should ignore only that path
    - Windows path normalization (`\` → `/`) must not break matching
  - Import the helper directly from `src/shared/fs/ignore.js`.

#### R.3.4 Filter list merge helper
- [x] `src/shared/filter/merge.js` exports `mergeFilterLists(a, b)`
- [x] Used by `src/retrieval/filters.js` (`mergeExtFilters`, `mergeLangFilters`) and tested via:
  - `tests/retrieval/filters/lang-filter.test.js`

---

### R.4 Core indexing + build pipeline refactors

#### R.4.1 Watch pipeline split
- [x] `src/index/build/watch.js` is now an orchestrator that delegates to:
  - `src/index/build/watch/args.js` (args normalization)
  - `src/index/build/watch/chokidar-backend.js` / `polling-backend.js`
  - `src/index/build/watch/watch-event-queue.js`
  - `src/index/build/watch/stability.js` (stability guard)
  - `src/index/build/watch/lock.js` (index lock + backoff)
  - `src/index/build/watch/rebuild.js` (rebuild trigger)
- Tests (existing):
  - `tests/indexing/watch/watch-backend-selection.test.js`
  - `tests/indexing/watch/watch-debounce.test.js`
  - `tests/indexing/watch/watch-lock-backoff.test.js`
  - `tests/indexing/watch/watch-stability-guard.test.js`
  - (plus several watch E2E/atomicity tests)

**Remaining (optional)**
- [x] If `watch.js` grows again, prefer extracting additional “pure helpers” to `src/index/build/watch/*.js` rather than re-introducing large inline blocks. Note this in the docs for watch/build

#### R.4.2 Integrations/core split (spec drift fix)

**Spec drift:** The old roadmap targeted `src/integrations/core/index.js` as a 700+ LOC monolith.  
In the current codebase, `src/integrations/core/index.js` is a tiny re-export facade, and the largest module is now:

- **Current monolith target:** `src/integrations/core/build-index.js` (~735 LOC)

##### R.4.2.1 Keep the facade pattern
- [x] `src/integrations/core/index.js` should remain a small re-export surface for:
  - `buildIndex`, `buildSqliteIndex` (from `build-index.js`)
  - `search` (from `search.js`)
  - `status` (from `status.js`)
- [x] Other integration helpers already live in `src/integrations/core/*.js`

##### R.4.2.2 Split build-index integration logic
- [x] Refactor `src/integrations/core/build-index.js` into a folder:
  - `src/integrations/core/build-index/index.js` (orchestrator; exports `buildIndex`, `buildSqliteIndex`)
  - `src/integrations/core/build-index/progress.js` (overall progress aggregation; current inline “overallProgress” logic)
  - `src/integrations/core/build-index/compatibility.js` (compat key computation)
  - `src/integrations/core/build-index/runtime.js` (runtime bootstrap/teardown helpers)
  - `src/integrations/core/build-index/stages.js` (stage1/stage2 planning + dispatch)
  - `src/integrations/core/build-index/sqlite.js` (the `buildSqliteIndex` implementation)

**Compatibility requirements**
- Keep exports stable from `src/integrations/core/index.js`.
- Keep the existing `buildIndex(repoRoot, options)` and `buildSqliteIndex(repoRoot, options)` signatures intact.

**Callers**
- `bin/pairofcleats.js` (via integration layer)
- `tools/mcp/tools.js` uses `coreBuildIndex` / `coreBuildSqliteIndex`
- Tests that invoke `build_index.js` script (various E2E tests)

**Tests to run**
- `node tests/run.js --match build-index --match index-lock --match watch-atomicity` (minimum)
- `node tests/run.js --lane pr` (recommended)

#### R.4.3 Runtime refactor
- [x] Runtime has been split into:
  - `src/index/build/runtime/config.js`, `policy.js`, `stage.js`, `workers.js`, `hash.js`, etc.
- [x] `src/index/build/runtime/runtime.js` remains large (~680 LOC) but is primarily orchestrator + normalization.

**Optional follow-up**
- [x] Extract “option normalization” helpers from `runtime.js` into `runtime/normalize.js` if `runtime.js` continues to grow.
- [x] Add a unit test for “caps/policy merges” if regressions occu.

#### R.4.4 Validate split
- [x] `src/index/validate.js` delegates to `src/index/validate/*` modules (`manifest`, `sqlite`, `lmdb`, etc.)
- Tests (existing): search for `validate` lane/scripts in `tests/script-coverage` actions.

#### R.4.5 Artifacts build split
- [x] `src/index/build/artifacts.js` delegates into `src/index/build/artifacts/*` (filter-index, postings, bundles, etc.)
- Ensure any new artifact type also updates:
  - `docs/contracts/artifact-contract.md`
  - `src/contracts/schemas/artifacts.js` (if schema is used)
  - relevant validation in `src/index/validate/*`

#### R.4.6 Worker pool split
- [x] Worker pool logic is now under `src/index/build/workers/*`
- `src/index/build/worker-pool.js` is a facade.

#### R.4.7 File processor split (CPU + chunk processing)

**Current state**
- [x] `src/index/build/file-processor/cpu.js` is ~586 LOC and already delegates chunking to:
  - `src/index/build/file-processor/cpu/chunking.js`
- **New monolith candidate:** `src/index/build/file-processor/process-chunks.js` (~650 LOC)

**Plan**
- [x] Keep `cpu.js` as the “single-file CPU orchestration” entrypoint (export `processFileCpu(...)`), but extract:
  - tokenization setup / caching → `cpu/tokenizer.js`
  - AST/tree-sitter analysis pass wrappers → `cpu/analyze.js`
  - metadata v2 enrichment steps → `cpu/meta.js`
  - keep `cpu/chunking.js` as-is

- [x] Split `process-chunks.js` into:
  - `file-processor/process-chunks/index.js` (orchestrator)
  - `file-processor/process-chunks/enrichment.js` (enrich + merge docmeta)
  - `file-processor/process-chunks/dedupe.js` (dedupe + normalization)
  - `file-processor/process-chunks/limits.js` (chunk limits + truncation policy)
  - `file-processor/process-chunks/ids.js` (chunk id assignment + stability rules)

**Callers**
- `src/index/build/indexer/steps/process-files.js`
- any tests building indexes (`tests/smoke/e2e-smoke.test.js`, etc.)

**Tests to run**
- `node tests/run.js --match segment-pipeline --match chunking-limits --match metadata-v2`
- plus at least one full index build smoke (`tests/smoke/e2e-smoke.test.js` or `tests/cli/build-index/build-index-all.test.js` if present)

#### R.4.8 Piece assembly split
- [x] `src/index/build/piece-assembly.js` is still ~500 LOC; helpers exist at `src/index/build/piece-assembly/helpers.js`.

**Remaining extraction (recommended)**
- [x] Extract the IO-heavy loader to `src/index/build/piece-assembly/load.js`
  - Move `loadIndexArtifacts(...)` and any “find pieces / read manifest / read artifacts” logic.
- [x] Extract merge logic to `src/index/build/piece-assembly/merge.js`
  - “merge postings / merge bundles / merge filter index / merge relations” helpers
- [x] Keep `assembleIndexPieces(...)` in `piece-assembly.js` as orchestrator (or move to `piece-assembly/index.js` with a facade).

**Callers**
- `tools/assemble-pieces.js` (CLI tool)
- `tests/indexing/contracts/index-compatibility-key-federation-block.test.js`

**Tests to run**
- `node tests/run.js --match compact-pieces --match index-compatibility-key-federation-block`

---

### R.5 Retrieval refactors

#### R.5.1 `filterChunks` split (`src/retrieval/output/filters.js`)

**Current state**
- [x] `src/retrieval/output/filters.js` now delegates to `src/retrieval/output/filters/*` helpers; `filterChunks` remains the orchestrator.
- [x] Candidate selection helpers already extracted:
  - `src/retrieval/output/filters/candidates.js` exports `createCandidateHelpers(...)`
- The file implements:
  - meta filters (`meta.*`, risk fields, etc.)
  - structural filters (`structPack`, `structRule`, `structTag`)
  - file/path/ext/lang prefiltering using `filterIndex` chargrams + roaring bitmaps
  - relation filters (`uses`, `imports`, `calls`) via `fileRelations`

**Specs to follow**
- File prefilter semantics: `docs/guides/search.md` (“File Filter Prefilter (Substring/Regex)”)
- Search filter contract: `docs/contracts/search-contract.md` + `docs/contracts/search-cli.md`
- Structural filter doc: `docs/guides/structural-search.md`

**Public entrypoint**
- Keep: `export function filterChunks(meta, filters = {}, filterIndex = null, fileRelations = null)`

**Callers**
- `src/retrieval/output.js` re-exports it
- `src/retrieval/pipeline.js` calls it
- Many tests import from `src/retrieval/output.js`

**Refactor plan (safe + incremental)**
- [x] **Step 1: fix formatting drift** in `filters.js` (indentation currently broken in destructuring blocks).
- [x] **Step 2: extract pure predicates** to `src/retrieval/output/filters/predicates.js`
  - `matchList`, `matchAny`, `truthy`, and any “normalize list” helpers.
- [x] **Step 3: extract structural matching** to `src/retrieval/output/filters/structural.js`
  - `matchStructural(chunk, { structPack, structRule, structTag })`
  - Must match semantics verified by `tests/tooling/structural/structural-filters.test.js`.
- [x] **Step 4: extract meta matching** to `src/retrieval/output/filters/meta.js`
  - `matchMetaFilters(chunk, metaFilters, riskFilters, options)`
  - Preserve support for:
    - `meta` (k/v string or regex) and `caseMeta`
    - risk selectors: `risk`, `riskTag`, `riskCategory`, `riskSource`, `riskSink`, `riskFlow`
    - inferred types: `inferredType`, `returnType`, `param`
- [x] **Step 5: extract file/path filter evaluation** to `src/retrieval/output/filters/file.js`
  - Build final exact predicate for:
    - `file`/`caseFile` (substring or regex; supports list)
    - `ext`, `lang`
  - Keep **final exact match** always enforced even when prefilter narrows candidates.
- [x] **Step 6: extract file prefilter (chargram/roaring)** to `src/retrieval/output/filters/file-prefilter.js`
  - `collectFilePrefilterMatches({ filterIndex, fileMatchers, caseFile, fileChargramN, roaring })`
  - Must implement doc semantics:
    - longest stable literal from regex; skip if none
    - case-insensitive prefilter; exact match still checks case when `caseFile` is true
- [x] **Step 7: keep filterChunks orchestrator** in `filters.js` (or move to `filters/index.js` and re-export from `filters.js`)
  - It should:
    - normalize filters once
    - construct candidate sets using `createCandidateHelpers`
    - loop candidates and apply exact predicates
    - handle `fileRelations` expansion for `uses/imports/calls` filters

**Tests to run (existing, must pass unchanged)**
- `tests/retrieval/filters/filter-index.test.js`
- `tests/retrieval/filters/filter-strictness.test.js`
- `tests/filter-structural.js` / `tests/tooling/structural/structural-filters.test.js`
- `tests/file-case-sensitive.js`
- `tests/filters-file.js`
- `tests/retrieval/filters/lang-filter.test.js`

*(Search for additional filter tests in `/tests` prefixed with `filter-` and run them too.)*

#### R.5.2 Search CLI split (`src/retrieval/cli.js`)
- [x] `runSearchCli(...)` now delegates inline helpers and run-config normalization to `src/retrieval/cli/*`; `cli.js` is orchestration glue.

**Refactor goal**
- Keep `runSearchCli(...)` export stable (callers: `src/integrations/core/search.js`).
- Reduce `cli.js` to “parse → normalize → run session → render/persist” glue.

**Plan**
- [x] Extract inline helpers inside `runSearchCli` to `src/retrieval/cli/runner.js`:
  - `inferJsonOutputFromArgs`
  - `emitError` / `bail`
  - `throwIfAborted`
- [x] Extract the giant `normalized` destructuring + derived flags into:
  - `src/retrieval/cli/resolve-run-config.js`
  - Return a single `runConfig` object (typed by convention / JSDoc) consumed by `runSearchSession`.
- [x] Keep `src/retrieval/cli.js` as the orchestrator that wires modules together.

**Tests to run**
- `node tests/run.js --match search-cli --match sqlite-fts-eligibility --match search-symbol-boost`

#### R.5.3 Language registry split
- [x] `src/index/language-registry/registry.js` is now small; data lives in `registry-data.js`.
- Ensure any future registry edits update:
  - `src/index/language-registry/registry-data.js`
  - tests that validate language ids / aliases (search for `language-registry` in tests)

#### R.5.4 Search pipeline split (`src/retrieval/pipeline.js`)

**Current state**
- [x] `src/retrieval/pipeline.js` now delegates query-AST, ANN backend normalization, and fusion helpers to `src/retrieval/pipeline/*`.
- `src/retrieval/pipeline.js` still mixes:
  - query-AST phrase checks
  - backend selection (ANN, sqlite FTS, etc.)
  - scoring logic (RRF, blend, symbol boosts, phrase boosts)
  - context-expansion

**Specs to follow**
- `docs/contracts/search-contract.md`
- `docs/guides/search.md`
- `docs/contracts/search-cli.md`

**Public entrypoint**
- Keep: `export function createSearchPipeline(context = {})`

**Callers**
- `src/retrieval/cli/run-search-session.js`
- tests: `tests/cli/search/search-symbol-boost.test.js`, `tests/retrieval/backend/sqlite-fts-eligibility.test.js`, and others

**Refactor plan**
- [x] Extract query-AST helpers to `src/retrieval/pipeline/query-ast.js`
  - move `matchesQueryAst(...)`
  - move `getPhraseMatchInfo(...)`
  - keep the exact signatures to avoid churn
- [x] Extract ANN backend normalization to `src/retrieval/pipeline/ann-backends.js`
  - move `normalizeAnnBackend(...)`, `resolveAnnOrder(...)`
- [x] Extract score fusion to `src/retrieval/pipeline/fusion.js`
  - a pure function that takes ranked sparse list, ranked dense list, config → fused list + breakdowns
  - keep existing behavior: default RRF, optional normalized blending via `search.scoreBlend.*`
- [x] Keep `pipeline.js` as orchestrator:
  - loads providers (BM25, sqlite fts, ann, minhash)
  - delegates to extracted helpers
  - keeps `createSearchPipeline` signature stable

**Tests to run**
- `tests/cli/search/search-symbol-boost.test.js`
- `tests/retrieval/backend/sqlite-fts-eligibility.test.js`
- `tests/search-rrf-parity.js` (if present)
- `tests/search-explain-schema.js` (if present)
- plus `node tests/run.js --lane pr`

#### R.5.5 JSON stream split
- [x] `src/shared/json-stream.js` is a facade over `src/shared/json-stream/*`

#### R.5.6 Filter merge module
- [x] `src/retrieval/filters.js` uses `src/shared/filter/merge.js`

---

### R.6 Tooling & services refactors

#### R.6.1 MCP tool dispatcher split (`tools/mcp/tools.js`)

**Current state**
- [x] `tools/mcp/tools.js` now delegates to `tools/mcp/tools/handlers/*` with a handler map.
- Helpers already extracted to: `tools/mcp/tools/helpers.js`

**Specs to follow**
- Tool defs + schemas are the source of truth:
  - `src/integrations/mcp/defs.js`
- Tests that enforce handler coverage:
  - `tests/services/mcp/tools-registry.test.js`
  - `tests/services/mcp/tools-normalize-meta.test.js`

**Public entrypoints (must remain exported)**
- `buildIndex`
- `runSearch`
- `downloadModels`, `downloadDictionaries`, `downloadExtensions`, `verifyExtensions`
- `buildSqliteIndex`, `compactSqliteIndex`
- `cacheGc`, `cleanArtifacts`, `runBootstrap`, `reportArtifacts`
- `triageIngest`, `triageDecision`, `triageContextPack`
- `handleToolCall`
- `normalizeMetaFilters` (re-export)

**Refactor plan**
- [x] Create folder: `tools/mcp/tools/handlers/`
  - `index-status.js` → `indexStatus`, `configStatus` (or keep in `tools/mcp/repo.js` if already there)
  - `indexing.js` → `buildIndex`, `buildSqliteIndex`, `compactSqliteIndex`
  - `search.js` → `runSearch`
  - `downloads.js` → `downloadModels`, `downloadDictionaries`, `downloadExtensions`, `verifyExtensions`
  - `artifacts.js` → `cleanArtifacts`, `reportArtifacts`, `cacheGc`
  - `bootstrap.js` → `runBootstrap`
  - `triage.js` → `triageIngest`, `triageDecision`, `triageContextPack`
- [x] Replace the `handleToolCall` switch with a map:
  - `const TOOL_HANDLERS = new Map([ ['search', runSearch], ... ])`
  - `handleToolCall(name, args, ctx)` looks up handler and throws unknown tool error if missing.
- [x] Update `tests/services/mcp/tools-registry.test.js` accordingly:
  - Instead of parsing switch cases, assert:
    - every tool name in `getToolDefs({ ... })` has a handler in the map
    - no extra handlers exist for undefined tools

**Compatibility requirements**
- Preserve handler behavior (progress callbacks, env resolution, JSON parsing errors).
- Keep error messages stable enough for tests (if tests assert substrings, keep them).

#### R.6.2 API router split
- [x] `tools/api/router.js` already delegates to `tools/api/router/*`

#### R.6.3 build-embeddings split
- [x] `tools/build-embeddings/run.js` delegates to `tools/build-embeddings/*`

#### R.6.4 build-sqlite-index split
- [x] `tools/build-sqlite-index/run.js` delegates to `tools/build-sqlite-index/*`

#### R.6.5 config-inventory split
- [x] `tools/config-inventory.js` delegates to `tools/config-inventory/*`

#### R.6.6 dict-utils split
- [x] `tools/dict-utils.js` is the public facade; internal helpers live in `tools/dict-utils/*`

---

### R.7 UI refactors

#### R.7.1 Map isometric edge assembly split (`src/map/isometric/client/edges.js`)

**Current state**
- [x] `edges.js` now delegates to `edges/aggregate.js`, `edges/endpoints.js`, `edges/style.js` plus existing helpers.
  - `src/map/isometric/client/edges/resolvers.js` (`createEdgeResolvers`)
  - `src/map/isometric/client/edges/routing.js` (`createRoutingHelpers`)
- Remaining in `edges.js`: aggregation + rendering shape logic.

**Public entrypoint**
- Keep: `export function buildEdges({...})`

**Refactor plan**
- [x] Extract edge aggregation to `src/map/isometric/client/edges/aggregate.js`
  - logic that builds per-edge segments + dedupes
- [x] Extract “endpoint dots” to `src/map/isometric/client/edges/endpoints.js`
- [x] Extract styling/resolution to `src/map/isometric/client/edges/style.js`
  - color/opacity decisions based on selection, hover, depth, etc.
- [x] Keep `edges.js` as orchestrator that wires:
  - resolvers + routing + aggregation + endpoints + style

**Tests (missing today)**
- [x] Add a small unit test suite under `tests/indexing/map/edges.test.js`:
  - route helper produces deterministic paths given fixed nodes
  - edge resolver consistently assigns inbound/outbound per node orientation
  - aggregation is stable (same input → same output ordering)

---

### R.8 Post-refactor follow-ups

- [x] Update `docs/guides/architecture.md` if module boundaries materially change (filters/pipeline/tools).
- [x] Update `docs/guides/commands.md` and `docs/tooling/script-inventory.json` if any script entrypoints changed.

---

### R.9 Current monolith snapshot (2026-01-30)

Top refactor candidates by size/complexity (non-generated, behavior-heavy):
1. `src/integrations/core/build-index.js` (~735 LOC) → split per **R.4.2.2**
2. `src/retrieval/cli.js` (~719 LOC) → reduce glue per **R.5.2**
3. `src/index/build/watch.js` (~703 LOC, but already modular) → optional further extraction
4. `src/index/build/runtime/runtime.js` (~683 LOC, mostly orchestrator) → optional normalize split
5. `src/index/build/file-processor/process-chunks.js` (~650 LOC) → split per **R.4.7**
6. `tools/mcp/tools.js` (~650 LOC) → split per **R.6.1**
7. `src/retrieval/pipeline.js` (~638 LOC) → split per **R.5.4**
8. `src/retrieval/output/filters.js` (~570 LOC) → split per **R.5.1**
9. `src/index/build/piece-assembly.js` (~500 LOC) → split per **R.4.8**
10. `src/map/isometric/client/edges.js` (~500 LOC) → split per **R.7.1**

---


## Phase 6 -- Finalization

> **Important:** A meaningful portion of this phase may already be implemented in this repo.  
> Before writing new code, **audit the referenced files/tests** and only add/modify what’s missing or incorrect.

### Goals

1. **Determinism & portability:** VFS virtual paths and “call_sites” output must be stable across runs/OSes.
2. **Artifact correctness:** VFS manifest and metaV2 must be correct, schema-valid, and consistent with post-processing.
3. **Noise reduction:** Improve call/usage heuristics and tokenization so keyword noise is controlled without losing queryability.
4. **CI completeness:** CI lanes must always run schema/validator coverage; long tests must be runnable in a dedicated lane.

---

## 6.0 Audit checklist (do this first)

- [x] Confirm these Phase 6 tests already exist and are green:
  - `tests/indexing/vfs/virtual-path-stability.test.js`
  - `tests/indexing/vfs/vfs-manifest-roundtrip.test.js`
  - `tests/indexer/call-sites/call-sites-determinism.test.js`
  - `tests/indexer/metav2/metav2-recompute-equivalence.test.js`
- [x] Confirm VFS manifest is actually produced during an index build:
  - Collection: `src/index/build/file-processor/process-chunks.js` → `buildVfsManifestRowsForFile()`
  - State aggregation: `src/index/build/indexer/steps/process-files.js` → `state.vfsManifestRows`
  - Emission: `src/index/build/artifacts/writers/vfs-manifest.js` → `enqueueVfsManifestArtifacts()`
  - Manifest wiring: `src/index/build/artifacts.js` adds piece `vfs_manifest`
- [x] Confirm metaV2 finalization happens *after* any mutation steps:
  - Cross-file inference: `src/index/build/indexer/steps/relations.js` → `runCrossFileInference()` mutates `chunk.docmeta` / `chunk.codeRelations`
  - Finalization: `src/index/build/indexer/steps/write.js` → `finalizeMetaV2({ chunks })` **before** writing artifacts
- [x] Confirm GitHub Actions PR CI runs `ci-lite` (and thus includes contracts + validate coverage):
  - Workflow: `.github/workflows/ci.yml`
  - Test command: `npm run test:ci-lite`
  - Source of truth list: `tests/ci-lite/ci-lite.order.txt`

If any item above is missing, fix it as part of Phase 6 (details below).

---

## 6.1 VFS hardening: stable virtual paths + manifest roundtrip

### 6.1.1 VFS Virtual Path specification (source of truth)

**Primary implementation:** `src/index/tooling/vfs.js`

- `VFS_PREFIX` is `".poc-vfs"`.
- `buildVfsVirtualPath({ containerPath, segmentUid, ext, effectiveExt })` must be:
  - **Pure & deterministic** (same inputs → same output across runs/OS).
  - **Path-safe for LSP/tooling** (no OS separators except `/`).
  - **Stable across host paths**: uses `normalizeRelPath()` and `encodeContainerPath()`:
    - `encodeContainerPath()` base64url-encodes the normalized relative path.
    - `decodeContainerPath()` reverses it.
  - **Segment addressing is explicit**:
    - If `segmentUid` is present: suffix is `"#seg:<segmentUid>"`.
    - Otherwise, no segment suffix.
  - **Extension selection rules**:
    - `effectiveExt` (if non-empty) takes precedence over `ext`.
    - Both are normalized to include a leading dot when present.
    - If neither exists, no extension suffix is added.

**Disk path mapping for tooling (not “virtual path”):**
- `resolveVfsDiskPath({ baseDir, virtualPath })`:
  - Splits the virtual path on `/` into components.
  - Encodes Windows-illegal characters in each component via `encodeURIComponent()` for `[:*?"<>|]`.
  - Joins using `path.sep` and roots at `baseDir`.

The **stable spec** is: *virtual paths are posix-style with `/`, disk paths are OS-safe via escaping.*

---

### 6.1.2 Task: Virtual path stability test

**Test file (must exist and pass):** `tests/indexing/vfs/virtual-path-stability.test.js`

**Must validate:**
- [x] Determinism: multiple invocations with identical inputs are string-equal.
- [x] Segment switching: changing `segmentUid` changes output only in the `#seg:` suffix.
- [x] Effective extension: `effectiveExt` overrides `ext`.
- [x] Cross-platform invariants:
  - The returned string always starts with `".poc-vfs/"`.
  - It never contains `\` (backslash), even on Windows.
  - It does not include raw absolute paths.

**Key implementation references:**
- `src/index/tooling/vfs.js`:
  - `buildVfsVirtualPath()`
  - `encodeContainerPath()`, `decodeContainerPath()`
  - `normalizeRelPath()` (imported from `../../shared/paths.js`)

If the existing test doesn’t cover the invariants above, extend it.

---

### 6.1.3 Task: VFS manifest roundtrip test (unsharded + sharded)

**Test file (must exist and pass):** `tests/indexing/vfs/vfs-manifest-roundtrip.test.js`

**Manifest schema reference (authoritative):**
- `src/contracts/schemas/artifacts.js` → `vfsManifestRow` schema
- Manifest writer uses:
  - `src/index/build/artifacts/writers/vfs-manifest.js`
  - `VFS_MANIFEST_SCHEMA_VERSION` from `src/index/tooling/vfs.js`

**Roundtrip requirements:**
- [x] **Unsharded mode**: writing `vfs_manifest.jsonl` and reading it back returns identical rows.
- [x] **Sharded mode**: forcing shard split via `maxJsonBytes` writes:
  - `vfs_manifest.meta.json`
  - `vfs_manifest.parts/…`
  - reading back yields the same rows.
- [x] Ordering:
  - Writer sorts rows with `sortVfsManifestRows()` so output is deterministic.
- [x] Row trimming:
  - Writer enforces `MAX_ROW_BYTES` (32 KB). Oversized rows must be trimmed in a deterministic way (`maybeTrimRow()`).

**Key implementation references:**
- Writer: `src/index/build/artifacts/writers/vfs-manifest.js`
  - `createVfsManifestRows()`
  - `sortVfsManifestRows()`
  - `buildManifestRow()` / `maybeTrimRow()`
  - `enqueueVfsManifestArtifacts()`
- Reader: `src/index/tooling/vfs.js`
  - `readVfsManifestRowsFromDisk()`
  - `readVfsManifestFromIndexRoot()`

---

### 6.1.4 Task: Add a minimal VFS disk-path safety test (recommended)

**Why:** `resolveVfsDiskPath()` is used on Windows, macOS, Linux. It must not create illegal filename components.

**New test (add):**
- `tests/indexing/vfs/vfs-disk-path-safety.test.js`

**Test cases:**
- [x] A virtual path containing illegal Windows characters in a component (e.g. `":"`, `"*"`, `"?"`, `"|"`) is converted to a disk path where those characters are percent-encoded.
- [x] Returned disk path is under `baseDir` (no traversal).
- [x] `virtualPath` containing `..` as a segment is treated as a literal component (still joined under baseDir), not as traversal.
  - If you consider `..` unsafe, then explicitly encode it or reject it; document the decision and test accordingly.

**Key implementation reference:** `src/index/tooling/vfs.js` → `resolveVfsDiskPath()`.

---

## 6.2 CI coverage: schema validation + clearer CI OS lanes

### 6.2.1 Task: Ensure schema & index validation always run in PR CI

**Goal:** If artifact schemas or validators break, PR CI must fail.

**What must be covered by the PR CI lane (`ci-lite`):**
- [x] **Contract/schema tests** (minimum):
  - `tests/indexing/contracts/schema-registry-single-source.test.js`
  - `tests/indexing/contracts/public-artifact-surface-doc.test.js`
  - `tests/indexing/contracts/artifact-surface-version.test.js`
- [x] **Index validator tests** (minimum):
  - `tests/indexing/validate/index-validate-strict.test.js`
  - `tests/indexing/validate/index-validate-load-manifest.test.js`
  - `tests/indexing/validate/index-validate-missing-pieces.test.js`
  - `tests/indexing/validate/index-validate-unknown-piece.test.js`

**Source of truth for what runs in `ci-lite`:**
- `tests/ci-lite/ci-lite.order.txt`  
  CI-lite is special-cased in `tests/run.js` and uses this order file verbatim.

**Acceptance criteria:**
- The list above is present in `ci-lite.order.txt`.
- `npm run test:ci-lite` fails when you intentionally break a schema or validator check.

**Implementation references:**
- Workflow: `.github/workflows/ci.yml`
- Test runner: `tests/run.js` (ci-lite order-file logic)

---

### 6.2.2 Task: Refine GitHub Actions CI job naming and OS coverage

**Workflow file:** `.github/workflows/ci.yml`

**Problems to address:**
- Job name `test` is ambiguous (it is really **Ubuntu**).
- Windows job is named `test-windows` but uses different OS runner (`windows-2022`) than nightly (`windows-latest`).
- macOS is covered in nightly, but not PR CI.

**Required changes:**
- [x] Rename job ids + display names:
  - `test` → `ubuntu`
  - `test-windows` → `windows`
- [x] Add a `macos` job running `npm run test:ci-lite`:
  - Runner: `macos-latest`
  - Keep it blocking if it’s fast enough; otherwise make it non-blocking but visible.
- [x] Align Windows runner choice with nightly unless you have a reason:
  - Prefer `windows-latest` unless a specific toolchain requires `windows-2022`.

**Acceptance criteria:**
- PR CI UI clearly shows `ubuntu`, `windows`, and `macos`.
- All jobs run the same Node version and `npm run test:ci-lite`.

**Related workflow:** `.github/workflows/nightly.yml` (already includes macOS).

---

## 6.3 Determinism + metaV2 correctness after post-processing

### 6.3.1 Task: call_sites determinism test

**Test file (must exist and pass):** `tests/indexer/call-sites/call-sites-determinism.test.js`

**What the test must guarantee:**
- [x] Two consecutive builds of the same fixture repository produce `call_sites.jsonl` output that is **line-identical**.
- [x] The fixture repo must be stable and self-contained (no network).
- [x] The test must not depend on wall-clock timestamps:
  - Compare content files, not meta `generatedAt` timestamps.

**Key implementation references:**
- Writer: `src/index/build/artifacts/writers/call-sites.js`
  - Determinism is primarily controlled by `sortCallSites(rows)`.
- Call detail production:
  - Call details are stored on `chunk.codeRelations.callDetails`.
  - Cross-file inference may add `targetChunkUid`/`targetDocId`/`targetCandidates`.

If determinism fails on Windows, inspect any path normalization differences and ensure ordering sort keys use normalized file paths (posix style `src/...`) rather than OS paths.

---

### 6.3.2 Task: Ensure metaV2 is finalized after cross-file inference mutations

**Why:** `metaV2` is a “flattened” structure derived from `chunk` + `chunk.docmeta` + `chunk.codeRelations`.  
Cross-file inference **mutates** those, so stale metaV2 would be a correctness bug.

**How it currently must work:**
- First metaV2 build (per-chunk) happens during assembly:
  - `src/index/build/file-processor/assemble.js` → `buildMetaV2(chunk)`
- Mutations happen later:
  - `src/index/build/indexer/steps/relations.js` → `runCrossFileInference()` (calls `applyCrossFileInference()`)
- Final metaV2 rebuild must happen at the end:
  - `src/index/build/indexer/steps/write.js` → `finalizeMetaV2({ chunks })`

**Acceptance criteria:**
- `finalizeMetaV2()` is invoked for every write mode (`code`, `prose`) **after** all mutation steps.
- Any artifact that includes `chunk.metaV2` is written after this finalization.

**Add/extend an integration assertion (recommended):**
- Update `tests/indexing/type-inference/crossfile/crossfile-output.integration.test.js` to also assert:
  - `buildWidget.metaV2.docmeta.inferredTypes.returns` includes `{ type: "Widget", source: "flow" }`
  - `buildWidget.metaV2.codeRelations.callLinks` includes the link to `createWidget`
  - `buildWidget.metaV2.codeRelations.usageLinks` includes the link to `Widget`
- This specifically catches stale metaV2 after inference.

---

## 6.4 Heuristic noise reduction: reserved words + code dictionaries + token classification

This subsection affects:
- Call/usage extraction in heuristic parsers (C-like, Go, Java, Kotlin, C#, Lua, Perl, PHP, Ruby, Shell, TypeScript).
- Tokenization quality (identifier splitting / keyword noise).

### 6.4.1 Task: Promote per-language reserved word sets to “complete” keyword lists

**Current problem:** the existing `*_CALL_KEYWORDS` and `*_USAGE_SKIP` sets are partial.  
This causes false-positive calls/usages for keywords and builtin type names.

**Primary implementation locations to update:**
- C-like:
  - `src/index/constants.js` → `CLIKE_CALL_KEYWORDS`, `CLIKE_USAGE_SKIP`
- TypeScript:
  - `src/lang/typescript/constants.js` → `TS_CALL_KEYWORDS`, `TS_USAGE_SKIP`, `TS_FLOW_SKIP`
- Others (inline in file):
  - `src/lang/csharp.js` → `CSHARP_CALL_KEYWORDS`, `CSHARP_USAGE_SKIP`
  - `src/lang/go.js` → `GO_CALL_KEYWORDS`, `GO_USAGE_SKIP`
  - `src/lang/java.js` → `JAVA_CALL_KEYWORDS`, `JAVA_USAGE_SKIP`
  - `src/lang/kotlin.js` → `KOTLIN_CALL_KEYWORDS`, `KOTLIN_USAGE_SKIP`
  - `src/lang/lua.js` → `LUA_CALL_KEYWORDS`, `LUA_USAGE_SKIP`
  - `src/lang/perl.js` → `PERL_CALL_KEYWORDS`, `PERL_USAGE_SKIP`
  - `src/lang/php.js` → `PHP_CALL_KEYWORDS`, `PHP_USAGE_SKIP`
  - `src/lang/ruby.js` → `RUBY_CALL_KEYWORDS`, `RUBY_USAGE_SKIP`
  - `src/lang/shell.js` → `SHELL_CALL_KEYWORDS`, `SHELL_USAGE_SKIP`
  - Rust (flow/dataflow only):
    - `src/lang/rust.js` → `RUST_USAGE_SKIP`

**Missing comprehensive reserved-word sets (add these):**
- Objective-C (`src/lang/clike.js` / `src/lang/tree-sitter` usage; no `*_RESERVED_WORDS` yet)
- Swift (`src/lang/swift.js` only has `SWIFT_DECL_KEYWORDS` + tiny skip set)
- C++ (currently only covered implicitly by `CLIKE_RESERVED_WORDS`)
- JavaScript (`src/lang/javascript.js` has no reserved-word set)
- Python (`src/lang/python.js` has no reserved-word set)
- Rust (has `RUST_USAGE_SKIP` only; no full reserved list)
- SQL dialects: Postgres / MySQL / SQLite (`src/lang/sql.js` has no reserved-word sets)
- CSS (`src/lang/css.js` has no reserved-word set)
- HTML (`src/lang/html.js` has no reserved-word set)

**Required refactor (recommended for maintainability):**
- [x] For each language module above, introduce a single exported `*_RESERVED_WORDS` (or `*_KEYWORDS`) set that is the **superset**.
- [x] Define:
  - `*_CALL_KEYWORDS = RESERVED_WORDS ∩ {things that can appear before “(” in syntax but are not calls}`
  - `*_USAGE_SKIP = RESERVED_WORDS ∪ {primitive types, literals, ultra-common words}`  
    (keep it *strictly* a superset to reduce false positives)
- [x] Ensure all sets are:
  - lowercased where language is case-sensitive (except where language semantics require case, e.g., Rust `Self`)
  - sorted in source for readability (alphabetical)
  - have no duplicates

**Acceptance criteria:**
- Fewer false positives in `calls`/`usages` for the targeted languages.
- No existing tests regress.

**Add regression tests (must add):**
- `tests/indexing/relations/keyword-skip-heuristics.test.js` (new)

Design:
- For each language that uses regex `\bNAME\s*\(` call extraction, feed a snippet that contains:
  - control structures that look like calls: `if(...)`, `for(...)`, `while(...)`, etc
  - real calls: `foo(...)`, `obj.foo(...)`
- Assert that:
  - control structure keywords are **not** included in `calls`
  - `foo`/`obj.foo` **are** included

Implementation hint:
- Use the existing relation entrypoints:
  - C-like: `src/lang/clike.js` exports `buildCLikeRelations` (or equivalent; see file exports)
  - Go: `buildGoRelations(...)` or the module export that returns `{ calls, usages }`
  - etc.

If you don’t have a clean exported function, test the internal `collect*CallsAndUsages()` functions directly.

---

### 6.4.2 Task: Per-language “code dictionaries” for identifier segmentation

**Goal:** Improve identifier splitting (e.g., `HTTPRequest` → `http` + `request`, `userID` → `user` + `id`)  
**without changing core scoring/ranking logic** (only segmentation quality).

**Current segmentation engine:** `src/shared/tokenize.js`
- `splitWordsWithDict(token, dictWords, config)` is already used by:
  - index-time tokenization: `src/index/build/tokenization.js`
  - query-time tokenization: `src/retrieval/query.js`

**Proposed design:**
- [x] Add a second dictionary source: **code dictionaries**, separate from natural-language dictionaries.
- [x] Code dictionaries are loaded, and applied only when tokenizing code (index mode `code`).
- [x] Provide:
  - `common-code.txt` (shared abbreviations): `http`, `url`, `uuid`, `json`, `yaml`, `html`, `css`, `sql`, `api`, `cli`, `ui`, `db`, `rpc`, `grpc`, `tls`, `ssl`, `jwt`, `oauth`, etc.
  - Per-language additions: `go.txt`, `java.txt`, `typescript.txt`, etc.

**Where to implement:**
- Dictionary path discovery:
  - Extend `tools/dict-utils/paths/dictionaries.js` (or add sibling `code-dictionaries.js`)
  - Add config shape to `tools/dict-utils/config/schema` (if present) or document it in roadmap.
- Runtime load:
  - `src/index/build/runtime/runtime.js` → `loadDictionaryWords(...)` currently loads `dictWords`
  - Add `codeDictWords` and/or `codeDictWordsByLanguage`
- Tokenization:
  - `src/index/build/tokenization.js`:
    - When `mode === "code"`, pass a dictionary set that unions:
      - natural dict words (`dictWords`)
      - common code dict
      - effective-language-specific code dict (if any)
  - Ensure worker tokenization has access too:
    - `src/index/build/workers/indexer-worker.js` uses `createTokenizationContext()`

**Acceptance criteria:**
- Turning on code dictionaries improves segmentation for representative identifiers.
- Prose segmentation is unaffected unless explicitly configured.

**Add tests (must add):**
- `tests/indexing/tokenization/tokenize-code-dictionaries.test.js` (new)
  - Verify that with a code dictionary containing `http` and `request`, `HTTPRequest` splits to include `http` and `request`.
  - Verify that with code dictionaries disabled, splitting falls back to existing behavior.

---

### 6.4.3 Task: Token classification (keyword vs identifier vs operator) + weighting

**Goal:** Keep keywords/operators searchable but reduce their ranking impact (keyword-noise control).

**Core requirements:**
- [x] Add classification for code tokens into at least:
  - `identifier`
  - `keyword`
  - `operator`
  - `literal` (numbers/strings)
- [x] Use Tree-sitter token/node types when available, **fallback** to keyword lists only when necessary.
  - Tree-sitter config: `src/lang/tree-sitter/config.js` lists supported `TREE_SITTER_LANGUAGE_IDS`.
- [x] Keep keywords indexable but **down-weight** them relative to identifiers.

#### Proposed implementation strategy (fits current architecture)

**A) Extend tokenization output to carry typed token buckets**
- Modify `src/index/build/tokenization.js`:
  - Currently returns `{ tokens, frequencies, positions, totalTokens }`
  - Extend to also return:
    - `identifierTokens` (array)
    - `keywordTokens` (array)
    - `operatorTokens` (array)
  - `tokens` should continue to exist for backward compatibility (initially keep it as the union).

**B) Feed typed buckets into `fieldTokens`**
- Modify `src/index/build/file-processor/assemble.js` `buildChunkPayload()`:
  - Currently sets `fieldTokens = { name, signature, doc, comment, body }`
  - Add new fields:
    - `fieldTokens.keyword = keywordTokens`
    - `fieldTokens.operator = operatorTokens`
  - Decide what `body` should contain:
    - **Recommended final shape:** `body = identifierTokens` only
    - But do this behind a config flag for compatibility (see below).

**C) Build field postings for new token fields**
- Modify `src/index/build/state.js`:
  - `fieldPostings` currently has `name`, `signature`, `doc`, `comment`, `body`.
  - Add `keyword` and `operator` maps (or make this dynamic by iterating keys from `chunk.fieldTokens`).
- Ensure `src/index/build/postings.js` writes `field_postings.json` with the additional fields.

**D) Retrieval: add default weights for new fields**
- Modify `src/retrieval/query-intent.js`:
  - Extend `DEFAULT_FIELD_WEIGHTS` to include:
    - `keyword`: small weight (e.g., 0.15–0.35)
    - `operator`: tiny weight (e.g., 0.05) or 0 (indexable but not scoring)
- Ensure `src/retrieval/pipeline.js` still operates if these fields are missing (older index).

**E) Compatibility plan**
- Add config flag (suggested):
  - `indexing.postings.tokenClassification.enabled` (default: `false` initially)
- When disabled:
  - Keep current behavior: `body = tokens` (union), no new fields required.
- When enabled:
  - `body = identifierTokens`
  - `keyword`/`operator` fields populated and weighted.

**Acceptance criteria:**
- Queries with only identifiers behave the same or better.
- Queries that are mostly keywords (e.g., `async await`) still return results, but keyword-only matches don’t dominate ranking.

**New tests (must add):**
1. `tests/indexing/tokenization/token-classification-tree-sitter.test.js`
   - Feed a small snippet in a Tree-sitter-supported language (e.g., JS or Go).
   - Assert that tokens are classified as expected:
     - identifiers go to `identifierTokens`
     - `if`, `for`, `return` go to `keywordTokens`
     - `=>`, `.`, `::`, `(`, `)` go to `operatorTokens` (depending on which operators you choose to index)
2. `tests/retrieval/ranking/keyword-downweighting.test.js`
   - Build a tiny synthetic index with two chunks:
     - Chunk A: many keyword tokens, few identifiers
     - Chunk B: fewer keywords, matching identifiers
   - Query for identifiers + keyword; assert chunk B ranks above A when classification is enabled.

---

## 6.5 CI-Long lane: isolate long-running tests

### 6.5.1 Task: Create a “CI-Long” lane that runs only tests tagged `long`

**Why:** Long tests slow PR feedback; they belong in scheduled/nightly lanes.

**Source of truth for “long”:**
- Tag rules in `tests/run.rules.jsonc` under `"tagRules"` include tag `"long"`.

**Required changes (recommended design: lane alias)**
- [x] Update `tests/run.rules.jsonc`:
  - Add `"ci-long"` to `"knownLanes"`.
- [x] Update `tests/runner/run-discovery.js` `resolveLanes()`:
  - Treat `ci-long` the same as `ci` (expand to `unit`, `integration`, `services`).
- [x] Update `tests/run.js`:
  - When lane `ci-long` is requested, automatically add `--tag long` (as if user passed it).
  - Ensure `--exclude-tag` still works as expected.
- [x] Add npm script in `package.json`:
  - `"test:ci-long": "node tests/run.js --lane ci-long"`
- [x] Add a GitHub Actions workflow lane/job (choose one):
  - **Option A:** Add to `.github/workflows/nightly.yml` (best): run `npm run test:ci-long` on all OSes.
  - **Option B:** Add a separate scheduled workflow `.github/workflows/ci-long.yml`.

**Acceptance criteria:**
- `npm run test:ci-long` runs **only** tests tagged `long`.
- PR CI remains fast (ci-lite).
- Nightly (or scheduled) runs include ci-long.

**Implementation references:**
- Tags/lane system:
  - `tests/run.rules.jsonc`
  - `tests/runner/run-discovery.js`
  - `tests/run.js`

---

## Appendix: Suggested “complete” reserved word lists (copy/paste seeds)

> These are intended as **seed lists** to prevent having to web-search during implementation.  
> Prefer Tree-sitter classification where possible, but keep these sets for heuristic parsers.

### JavaScript / TypeScript (seed keywords)
```
await break case catch class const continue debugger default delete do else enum export extends false finally for function if import in instanceof new null return super switch this throw true try typeof var void while with yield let
as implements interface package private protected public static
any boolean bigint number object string symbol unknown never
keyof readonly infer satisfies asserts is require namespace module type from of get set constructor declare abstract override
```

### C / C++ (seed keywords)
```
auto break case char const continue default do double else enum extern float for goto if inline int long register restrict return short signed sizeof static struct switch typedef union unsigned void volatile while
_Alignas _Alignof _Atomic _Bool _Complex _Generic _Imaginary _Noreturn _Static_assert _Thread_local
alignas alignof and and_eq asm bitand bitor bool catch char8_t char16_t char32_t class compl concept const_cast consteval constexpr constinit co_await co_return co_yield decltype delete dynamic_cast explicit export false friend import module mutable namespace new noexcept not not_eq nullptr operator or or_eq private protected public reinterpret_cast requires static_assert static_cast template this thread_local throw true try typeid typename using virtual wchar_t xor xor_eq final override
```

### Go (seed keywords + predeclared)
```
break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var
nil true false iota
append cap close complex copy delete imag len make new panic print println real recover
bool byte complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr any
```

### Java (seed)
```
abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while
true false null
var record yield sealed permits non-sealed
module open requires exports opens to uses provides with transitive
```

### Kotlin (seed)
```
as as? break class continue do else false for fun if in !in interface is !is null object package return super this throw true try typealias val var when while
by catch constructor delegate dynamic field file finally get import init param property receiver set setparam where
actual abstract annotation companion const crossinline data enum expect external final infix inline inner internal lateinit noinline open operator out override private protected public reified sealed suspend tailrec vararg value
```

### C# (seed)
```
abstract as base bool break byte case catch char checked class const continue decimal default delegate do double else enum event explicit extern false finally fixed float for foreach goto if implicit in int interface internal is lock long namespace new null object operator out override params private protected public readonly ref return sbyte sealed short sizeof stackalloc static string struct switch this throw true try typeof uint ulong unchecked unsafe ushort using virtual void volatile while
add alias ascending async await by descending dynamic equals from get global group into join let nameof on orderby partial remove select set value var when where yield record init with
```

### Lua (seed)
```
and break do else elseif end false for function goto if in local nil not or repeat return then true until while
```

### PHP (seed)
```
__halt_compiler abstract and array as break callable case catch class clone const continue declare default die do echo else elseif empty enddeclare endfor endforeach endif endswitch endwhile eval exit extends final finally fn for foreach function global goto if implements include include_once instanceof insteadof interface isset list match namespace new or print private protected public readonly require require_once return static switch throw trait try unset use var while xor yield yield from
true false null
```

### Ruby (seed)
```
BEGIN END alias and begin break case class def defined? do else elsif end ensure false for if in module next nil not or redo rescue retry return self super then true undef unless until when while yield
__FILE__ __LINE__ __ENCODING__
```

### Shell (bash/sh seed)
```
if then else elif fi for while until do done case esac in select function time coproc
break continue return exit shift eval exec trap wait local declare typeset readonly export set unset source
true false
```

### Perl (seed)
```
my our use sub package if elsif else unless while until for foreach continue do given when default
next last redo goto return
BEGIN END INIT CHECK UNITCHECK
die warn print say
```

---



## Phase 7 — Embeddings + ANN unification

This section is a **fully expanded, implementation-ready** rewrite of the Phase 7 roadmap. 

**Primary goals:**
- Make embedding generation **build-scoped, deterministic, and resumable** (service queue or inline).
- Make ANN backends **consistent** (same target vectors, same candidate filtering semantics, same readiness signals).
- Make the artifact surface **manifest-first** and contract-compliant (no “guessing” filenames in strict mode).
- Remove quantization/normalization ambiguity so that outputs are **correct, stable, and comparable**.

---

### Objective

Unify embeddings and ANN artifacts across all build paths (inline indexing, build-embeddings, and service queue) so that:

1. **Index build outputs are deterministic**
   - Embedding jobs always target an explicit build root and index directory.
   - Cached embeddings are keyed by an explicit identity key that includes model and quantization settings.
   - Incremental updates and full builds produce the same embedding artifacts.

2. **ANN backends behave consistently**
   - Candidate filtering behaves the same across HNSW and LanceDB.
   - ANN target selection aligns with `denseVectorMode` (merged/doc/code/auto).
   - “ANN-ready” state is clearly signaled in `index_state.json` and the manifest.

3. **Artifact discovery is contract-compliant**
   - Strict discovery uses `pieces/manifest.json` (no directory scanning / filename guessing).
   - Embeddings/ANN artifacts are included in the manifest when present, absent when not.

---

### Exit criteria

All items must be satisfied:

- ✅ **Embedding jobs are build-scoped**
  - `tools/indexer-service.js` uses the job payload to run build-embeddings **against the correct build root** even if builds/current.json changes.
  - Queue payload format is versioned and validated (`embeddingPayloadFormatVersion`).

- ✅ **No quantization overflow / wrap**
  - Quantization levels are clamped to `[2, 256]` in every path that quantizes vectors.
  - No path writes >255 values into a `Uint8Array` or “uint8 JSON” vector artifact.

- ✅ **Normalization is consistent**
  - If `embeddingIdentity.normalize === true`, all stored vectors used for ANN and exact ranking are normalized (or explicitly documented and tested otherwise).

- ✅ **Manifest completeness**
  - If an ANN backend artifact exists (HNSW bin, LanceDB directory, SQLite-vec table marker), the manifest includes a corresponding entry (and any required meta entry).
  - If it does not exist, the manifest does not list it.

- ✅ **Strict mode compliance**
  - Retrieval and validation do not guess filenames in strict mode; they locate artifacts through the manifest.

- ✅ **Parity tests pass**
  - Ranking parity tests demonstrate that Dense vs HNSW vs LanceDB are consistent on deterministic fixtures (within acceptable error bounds for ANN).

---

## 7.0 Foundation: contracts, terminology, and execution order

### 7.0.1 Source-of-truth hierarchy and conflict resolution rules

Phase 7 touches multiple “spec surfaces”. Use this hierarchy when conflicts arise:

1. **docs/contracts/public-artifact-surface.md**  
   - Canonical rule: strict tooling must discover artifacts via the manifest (no guessing).  
2. **src/contracts/** (runtime validators + schema defs)  
   - Canonical for what the code *currently* enforces.
3. **docs/guides/embeddings.md** and **docs/guides/search.md**  
   - Operational guidance. If it conflicts with (1), update the guide.
4. **Current implementation**  
   - If code is *ahead* of docs (e.g., it already writes an artifact but docs omit it), update docs/contracts to match the intended public surface.
   - If code is *behind* docs/contracts, update code to match contracts.

**Explicit Phase 7 conflicts discovered and resolution choices:**
- **Conflict A:** Embedding queue `indexRoot` meaning is inconsistent (pipeline passes per-mode index dir; build-embeddings `--index-root` expects base build root).  
  ✅ Resolution: **Rename/clarify fields** in the job payload (`buildRoot` as base; `indexDir` as per-mode). Update tests + worker accordingly. This removes ambiguity and matches build-embeddings behavior.
- **Conflict B:** `tools/build-embeddings/manifest.js` currently filters entries by `ARTIFACT_SCHEMA_DEFS`, which omits non-JSON artifacts like HNSW `.bin` and LanceDB directories.  
  ✅ Resolution: **Manifest must include these artifacts**. Update manifest writer to include them via an allowlist even if they are not JSON-schema-validated, and update docs/contracts to explicitly list them as part of the public surface.
- **Conflict C:** Retrieval loaders read many JSON artifacts via direct filesystem reads (bypassing manifest), contradicting “manifest-first”.  
  ✅ Resolution: In strict mode, retrieval must use `src/shared/artifact-io.js` manifest-based resolvers for all artifacts it loads (JSON and non-JSON).

### 7.0.2 Terminology

To prevent recurring confusion, Phase 7 standardizes these terms:

- **repoRoot**: The repository being indexed/searched.
- **buildRoot**: A single build output root (e.g., `<repo>/builds/<buildId>`). This is the root that contains `index-code`, `index-prose`, etc.
- **indexDir**: A per-mode directory inside buildRoot, e.g.:
  - `<buildRoot>/index-code`
  - `<buildRoot>/index-prose`
- **mode**: One of `code | prose | extracted-prose | records` (Phase 7 primarily targets code + prose).
- **vector variant / target**:
  - `merged`: merged embedding vector for a chunk
  - `code`: code-only vector
  - `doc`: doc-only vector
- **denseVectorMode**: How to select the vector variant for ranking:
  - `merged | code | doc | auto`
  - `auto` is resolved per query intent (and/or mode-specific fallback).
- **ANN backend**: `lancedb | hnsw | sqlite-vec | dense | none` (exact list depends on optional deps and configuration).

### 7.0.3 Capability matrix (post-Phase 7 required behavior)

After Phase 7, these capabilities must hold:

- Dense exact ranking: supports `merged/doc/code` (already possible via `resolveDenseVector()` once `denseVectorMode` is wired through).
- LanceDB ANN: supports `merged/doc/code` (already built and selectable via `resolveLanceDbTarget()`).
- HNSW ANN: **must have an explicit, documented target mapping**:
  - Build and load HNSW indices for `merged/doc/code` so it can match LanceDB behavior.


### 7.0.4 Recommended execution order

Order tasks so that cross-cutting foundational changes land first:

1. **7.2 Artifact contract + manifest completeness** (must exist before strict loaders can be updated)
2. **7.3 Quantization invariants** (prevents corrupt outputs and invalid caches)
3. **7.4 Normalization policy consistency** (required before parity tests)
4. **7.1 Embedding job scoping + worker behavior** (service correctness)
5. **7.5 LanceDB robustness**
6. **7.6 HNSW compatibility + observability**
7. **7.7 Backend policy + ranking equivalence**
8. **7.8 Storage resilience**

---

### 7.0.5 Test lane classification (mandatory)

All new Phase 7 tests must land in the intended CI lane.

- Update `tests/run.rules.jsonc` to map any new test files (do not rely on ambiguous filenames alone).
- If a test is intentionally placed to match an existing lane rule, verify it in `npm test -- --list-lanes` and note it in the test section.
- Add a shared optional-deps test helper (e.g., `tests/helpers/optional-deps.js`) so skip behavior is consistent across tests.

## 7.1 Embedding jobs are build-scoped, deterministic, idempotent

### Why this exists

Current embedding service flow is not fully build-scoped:
- `src/index/build/indexer/pipeline.js` enqueues an embedding job, but the worker (`tools/indexer-service.js`) ignores job buildRoot/indexRoot and calls `tools/build-embeddings.js` without `--index-root`.
- Queue tests currently allow inconsistent `buildRoot` vs `indexRoot` values, which hides real scoping bugs.

### 7.1.1 Define the embedding job payload schema (versioned)

**Touchpoints**
- `src/index/build/indexer/embedding-queue.js` (~L1–L49)
- `tools/service/queue.js` (~L1–L270)
- `tools/indexer-service.js` (~L1–L441)
- Tests: `tests/indexing/embeddings/embedding-queue.test.js` (~L1–L51), `tests/indexing/embeddings/embedding-queue-defaults.test.js` (~L1–L37)

**New canonical job payload fields** (JSON):
```json
{
  "type": "embeddings",
  "embeddingPayloadFormatVersion": 2,
  "repoRoot": "/abs/path/to/repo",
  "buildId": "b123",
  "buildRoot": "/abs/path/to/repo/builds/b123",
  "mode": "code",
  "indexDir": "/abs/path/to/repo/builds/b123/index-code",
  "embeddingIdentity": { "...": "..." },
  "embeddingIdentityKey": "sha1-or-similar",
  "configHash": "sha1-of-effective-config",
  "repoProvenance": {
    "gitSha": "optional",
    "dirty": false,
    "toolVersion": "optional"
  },
  "createdAt": "2026-01-30T12:34:56.000Z",
  "updatedAt": "2026-01-30T12:34:56.000Z",
  "attemptCount": 0,
  "lastError": null
}
```

**Hard requirements**
- `buildRoot` MUST be an absolute path.
- `indexDir` MUST be an absolute path AND MUST be inside `buildRoot` (validate via `path.relative()`; reject `..` escape).
- `mode` MUST be one of the supported modes.
- `embeddingIdentityKey` MUST match `buildEmbeddingIdentityKey(embeddingIdentity)` exactly.
- `configHash` MUST be stable for the effective embedding config.
- `embeddingPayloadFormatVersion` MUST be set (defaulted, but not omitted).

**Compatibility behavior**
- If a job is missing `embeddingPayloadFormatVersion`, treat it as version 1 and:
  - If it has `indexRoot` (legacy), interpret:
    - If `indexRoot` ends with `/index-code` or `/index-prose`, treat it as `indexDir`.
    - Else treat it as `buildRoot`.
  - Populate missing fields where safely derivable.
  - Emit a warning once per worker run that legacy payloads are being upgraded.

### 7.1.2 Fix the enqueue site to emit correct fields

**Touchpoints**
- `src/index/build/indexer/pipeline.js` (~L1–L326) (search: `enqueueEmbeddingJob({`)
- `src/index/build/indexer/embedding-queue.js` (~L1–L49)

**Current bug**
- Pipeline passes `indexRoot: outDir` where `outDir` is already the per-mode index directory. This is incompatible with build-embeddings `--index-root` semantics and breaks any future “join index dir” logic.

**Required changes**
- In `pipeline.js` when calling `enqueueEmbeddingJob`, pass:
  - `buildRoot: runtime.buildRoot` (already exists on runtime)
  - `indexDir: outDir` (rename from indexRoot)
- In `embedding-queue.js`, accept `indexDir` (new) and either:
  - Disallow legacy `indexRoot` input, OR
  - Support both but normalize to canonical `indexDir`.

**Also update**
- Validate `indexDir` exists (or at least that its parent buildRoot exists) before enqueueing. If missing, treat as programmer error and throw (this prevents silent jobs that can never run).

### 7.1.3 Worker must run build-embeddings against the correct build root

**Touchpoints**
- `tools/indexer-service.js` (~L1–L441) (function `runBuildEmbeddings`)
- `tools/build-embeddings/cli.js` (~L1–L95) (already supports `--index-root`)
- `tools/build-embeddings/runner.js` (~L1–L763) (already expects indexRoot base)

**Required changes**
- Update `runBuildEmbeddings({ job })` to include:
  - `--index-root <job.buildRoot>`  
    (NOT `job.indexDir`; build-embeddings runner will derive per-mode indexDir.)
- If job includes `indexDir`, pass it only for validation/logging; do not use as the base index root.
- Ensure the worker runs `--mode <job.mode>` and uses the job’s `repoRoot` (or `repo`).
- If `job.repoRoot` and the worker’s `--repo` mismatch, the worker should:
  - prefer `job.repoRoot` if present
  - warn if `--repo` differs (avoid “wrong repo” processing)

**Safety requirement**
- If `job.buildRoot` does not exist, mark job failed with `lastError` explaining missing build root and do not retry indefinitely (cap attempts).

### 7.1.4 Index state should clearly represent “pending embeddings”

**Touchpoints**
- `src/index/build/indexer/steps/write.js` (~L1–L101) (writes initial index_state during stage2)
- `tools/build-embeddings/runner.js` (~L1–L763) (updates index_state during stage3)

**Required state machine**
- Stage2 build when embeddings are configured to run later via service:
  - `index_state.embeddings.enabled = true`
  - `index_state.embeddings.ready = false`
  - `index_state.embeddings.pending = true`  ✅ add this
  - `index_state.embeddings.service = true`
  - `index_state.embeddings.mode = <mode>`
  - `index_state.embeddings.embeddingIdentity` and `.embeddingIdentityKey` SHOULD be present if known at stage2.
- Stage3 success:
  - `enabled = true`
  - `ready = true`
  - `pending = false`
  - `updatedAt` set (already)
- Stage3 failure:
  - `enabled = true`
  - `ready = false`
  - `pending = false` (job completed but failed) OR keep `pending=true` only if the job will be retried.
  - `lastError` set (new)

**Note:** Retrieval currently uses `embeddingsReady = embeddingsState?.ready !== false && embeddingsState?.pending !== true`. That logic assumes `pending` exists; Phase 7 makes it real.

### 7.1.5 Tests for build scoping and worker correctness

**Update existing tests**
- `tests/indexing/embeddings/embedding-queue.test.js`
  - Must require that when `enqueueEmbeddingJob({ runtime, mode, indexDir })` is called:
    - job.buildRoot equals runtime.buildRoot
    - job.indexDir equals resolved indexDir
    - job.indexDir is within job.buildRoot
  - Remove the current test behavior that allows buildRoot/indexRoot mismatch.
- `tests/indexing/embeddings/embedding-queue-defaults.test.js`
  - Assert that missing optional fields are filled:
    - `embeddingPayloadFormatVersion` is set
    - `attemptCount` default 0
    - `createdAt` and `updatedAt` are ISO strings

**Add new tests**
- `tests/services/indexer/indexer-service-embedding-job-uses-build-root.test.js` (new)
  - Create two builds (b1 and b2) under a temp repo
  - Create a job targeting buildRoot=b1
  - Simulate builds/current.json pointing at b2
  - Run `tools/indexer-service.js --once --queue embeddings` (or equivalent)
  - Assert embeddings artifacts were written under build b1 (not b2)
  - Assert job is marked completed and `index_state.json` under b1 indicates `ready=true`.

---

## 7.2 Artifact contract parity for embeddings + ANN

### Why this exists

Contracts require manifest-first discovery. Today:
- `tools/build-embeddings/manifest.js` tries to add embedding pieces but filters them by `ARTIFACT_SCHEMA_DEFS`, excluding important non-JSON artifacts.
- Retrieval/validation still open some artifacts by guessed filenames.

Phase 7 makes embeddings and ANN artifacts fully discoverable via the manifest.

### 7.2.1 Define the canonical public artifact names for embeddings + ANN

**Specs to update**
- `docs/contracts/artifact-schemas.md`
- `docs/contracts/public-artifact-surface.md`

**Code to update**
- `src/contracts/registry.js` and/or `src/contracts/schemas/artifacts.js` (if adding names)
- `tools/build-embeddings/manifest.js`
- `src/shared/artifact-io/manifest.js` (if adding helpers for binary/dir artifacts)
- `src/retrieval/cli-index.js`, `src/retrieval/cli/load-indexes.js`, `src/index/validate.js`

**Canonical names (Phase 7)**
These names are used as `manifestEntry.name` and in code when resolving artifacts:

Dense vectors (quantized uint8 JSON, with vectors embedded):
- `dense_vectors` → `dense_vectors_uint8.json`
- `dense_vectors_doc` → `dense_vectors_doc_uint8.json`
- `dense_vectors_code` → `dense_vectors_code_uint8.json`

HNSW (non-JSON + JSON meta):
- `dense_vectors_hnsw` → `dense_vectors_hnsw.bin`
- `dense_vectors_hnsw_meta` → `dense_vectors_hnsw.meta.json`
- `dense_vectors_doc_hnsw` → `dense_vectors_doc_hnsw.bin`
- `dense_vectors_doc_hnsw_meta` → `dense_vectors_doc_hnsw.meta.json`
- `dense_vectors_code_hnsw` → `dense_vectors_code_hnsw.bin`
- `dense_vectors_code_hnsw_meta` → `dense_vectors_code_hnsw.meta.json`

LanceDB (directories + JSON meta):
- `dense_vectors_lancedb` → `dense_vectors.lancedb/`
- `dense_vectors_lancedb_meta` → `dense_vectors.lancedb.meta.json`
- `dense_vectors_doc_lancedb` → `dense_vectors_doc.lancedb/`
- `dense_vectors_doc_lancedb_meta` → `dense_vectors_doc.lancedb.meta.json`
- `dense_vectors_code_lancedb` → `dense_vectors_code.lancedb/`
- `dense_vectors_code_lancedb_meta` → `dense_vectors_code.lancedb.meta.json`

SQLite vector extension ANN presence:
- This is DB state, not a file artifact. Represent it in `index_state.embeddings.backends.sqliteVec` and optionally as a manifest “marker”:
  - `dense_vectors_sqlite_vec_meta` → `dense_vectors_sqlite_vec.meta.json` (new optional)  
    (If added, it documents dims/count and table name; it is optional because it depends on build options and sqlite configuration.)

**Important:** Even if you do not add JSON schemas for binary/dir artifacts, their NAMES must be part of the public artifact surface and must appear in the manifest when present.

### 7.2.2 Update the embeddings manifest writer to include non-JSON artifacts

**Touchpoints**
- `tools/build-embeddings/manifest.js` (~L1–L111)

**Current behavior**
- Builds `embeddingPieces`, then filters by `ARTIFACT_SCHEMA_DEFS` names, which excludes:
  - `dense_vectors_hnsw` (bin)
  - `dense_vectors_lancedb` (dir)
  - and doc/code variants.

**Required behavior**
- Remove or relax the schema-name filter. Replace with a clear allowlist:
  - `const allowed = new Set([...Object.keys(ARTIFACT_SCHEMA_DEFS), ...NON_JSON_PUBLIC_ARTIFACTS]);`
  - where `NON_JSON_PUBLIC_ARTIFACTS` includes the bin/dir names listed above.
- For `format: 'bin'`, add manifest entry if the file exists.
- For `format: 'dir'`, add manifest entry if the directory exists.
- Ensure manifest entries record:
  - `format` as `json|jsonl|bin|dir` (already)
  - `bytes` and `sha256` for files (`bin` and `json`) where feasible
  - For directories, record `entries` count and/or omit bytes (bytes optional); if bytes is recorded, compute deterministically (walk directory sorted).

**Edge cases**
- If `.bak` exists for HNSW, do not add it to manifest as a separate artifact. The `.bak` is an implementation detail. Only the canonical `.bin` path is listed.

### 7.2.3 Update readers to use manifest in strict mode

**Touchpoints**
- `src/retrieval/cli-index.js` (~L1–L416) (file-backed load)
- `src/retrieval/cli/load-indexes.js` (~L1–L368) (LanceDB attach)
- `src/index/validate.js` (~L1–L581)
- `src/shared/artifact-io.js` (~L1–L12) and `src/shared/artifact-io/manifest.js` (~L1–L291)

**Required behavior**
- In strict mode:
  - JSON artifacts are loaded via `loadJsonArrayArtifact`, `loadJsonObjectArtifact`, `loadChunkMeta`, etc.
  - Non-JSON artifacts are *located* via manifest (resolve path), then opened.

**Concrete implementation steps**
1. Add helper(s) in `src/shared/artifact-io.js`:
   - `resolveBinaryArtifactPath(dir, name, { strict })`
   - `resolveDirArtifactPath(dir, name, { strict })`
   These should:
   - in strict mode: require manifest entry and return absolute path
   - in non-strict mode: fall back to legacy filename guessing (only for backward compatibility)
2. Update `src/retrieval/cli-index.js`:
   - Replace `readJsonFile(path.join(dir, 'dense_vectors_uint8.json'))` with `loadJsonObjectArtifact(dir, 'dense_vectors', { strict: true })`
   - Replace HNSW meta load with `loadJsonObjectArtifact(dir, 'dense_vectors_hnsw_meta', { strict: true })`
   - Resolve HNSW bin with `resolveBinaryArtifactPath(dir, 'dense_vectors_hnsw', { strict: true })`
3. Update `src/retrieval/cli/load-indexes.js` attachLanceDb:
   - Resolve `dense_vectors_*_lancedb_meta` through manifest, not direct path join.
   - Resolve the lancedb directory through manifest entry `dense_vectors_*_lancedb`.
4. Update `src/index/validate.js`:
   - For strict validation, require manifest presence for embedding artifacts and use it to locate them.
   - Validation should fail if an artifact exists on disk but is missing from manifest (strict mode).

### 7.2.4 Index state should include embedding identity and backend presence

**Touchpoints**
- `src/index/build/indexer/steps/write.js` (~L1–L101) (stage2)
- `tools/build-embeddings/runner.js` (~L1–L763) (stage3)
- Tests: `tests/indexing/embeddings/embeddings-validate.test.js` (~L1–L82), `tools/index-validate.js` (~L1–L130) output

**Required new fields**
- `index_state.embeddings.embeddingIdentity` (object)
- `index_state.embeddings.embeddingIdentityKey` (string)
- `index_state.embeddings.backends` (object, example):
```json
{
  "hnsw": { "enabled": true, "available": true, "target": "merged", "dims": 384, "count": 1234 },
  "lancedb": { "enabled": true, "available": true, "target": "code", "dims": 384, "count": 1234 },
  "sqliteVec": { "enabled": true, "available": false }
}
```

**Rules**
- `available` means the artifact is present and loadable.
- `enabled` means config requested it.
- `target` is only required if the backend depends on vector variant selection.

### 7.2.5 Tests for manifest completeness and strict discovery

**Add new tests**
- `tests/indexing/embeddings/manifest-embeddings-pieces.test.js`
  - Build stage2 index for fixture repo (stub embeddings).
  - Run build-embeddings stage3.
  - Load `<indexDir>/pieces/manifest.json`.
  - Assert it includes entries for:
    - `dense_vectors`
    - `dense_vectors_hnsw` and `dense_vectors_hnsw_meta` (if hnswlib is installed; if not installed, assert they are absent)
    - `dense_vectors_lancedb` and `dense_vectors_lancedb_meta` (if lancedb is installed; else absent)
  - Assert that if `dense_vectors_hnsw.bin` exists, manifest includes it.
  - Assert that if manifest lists it, file exists.

- `tests/retrieval/backend/retrieval-strict-manifest-embeddings.test.js`
  - Create an indexDir with embeddings artifacts present but remove `pieces/manifest.json`.
  - Run `search.js` in strict mode (default) and assert it fails with `ERR_MANIFEST_MISSING` (or equivalent).
  - Run `search.js --non-strict` (if supported) and assert it can still run (legacy fallback), but logs a warning.

**Update existing tests**
- `tests/indexing/artifacts/artifact-io-manifest-discovery.test.js`
  - Extend to also verify `dense_vectors` and `dense_vectors_hnsw_meta` cannot be loaded without manifest in strict mode once the loader changes land.

---

## 7.3 Quantization invariants end-to-end

### Why this exists

There are multiple quantization entry points:
- `src/shared/embedding-utils.js` has both `quantizeEmbeddingVector()` (unclamped levels) and `quantizeEmbeddingVectorUint8()` (clamped).
- Several call sites use the unclamped path and then pack into a Uint8Array, which can wrap values.

This phase enforces correct quantization everywhere.

### 7.3.1 Clamp quantization levels globally to [2, 256]

**Touchpoints**
- `src/storage/sqlite/vector.js` (~L1–L71) (function `resolveQuantizationParams`)
- `src/shared/embedding-utils.js` (~L1–L176) (`quantizeEmbeddingVector`, `quantizeEmbeddingVectorUint8`, `dequantizeUint8ToFloat32`)
- `src/index/embedding.js` (~L1–L56) (`quantizeVec`, `quantizeVecUint8`)
- `tools/build-embeddings/embed.js` (~L1–L119)
- `src/storage/sqlite/build/incremental-update.js` (~L1–L567)
- `src/index/build/file-processor/embeddings.js` (~L1–L260)

**Required changes**
1. In `resolveQuantizationParams()`:
   - Clamp `levels` to integer in `[2, 256]`.
   - Rationale: prevents overflow **and** avoids divide-by-zero in `scale = (maxVal - minVal) / (levels - 1)` when `levels <= 1`.
   - If invalid, default to 256.
2. In `quantizeEmbeddingVector()`:
   - Either:
     - clamp internally (same as Uint8 version), OR
     - mark as internal-only and ensure no production path uses it.
   - Phase 7 requirement: **production quantization must not be able to output values >255**.
3. Update `src/index/embedding.js`:
   - Make `quantizeVec()` call the clamped implementation OR remove it in favor of `quantizeVecUint8()` and update call sites.

### 7.3.2 Ensure all stored “uint8 artifacts” are actually uint8-safe

**Artifacts affected**
- `dense_vectors_uint8.json` (`dense_vectors`)
- `dense_vectors_doc_uint8.json` (`dense_vectors_doc`)
- `dense_vectors_code_uint8.json` (`dense_vectors_code`)
- SQLite dense tables written by `tools/build-embeddings/sqlite-dense.js`
- HNSW/LanceDB build paths that dequantize from uint8

**Required changes**
- Update `tools/build-embeddings/embed.js` to quantize using the clamped path.
  - Prefer storing vectors as plain arrays of integers 0..255 in JSON.
- Update `src/storage/sqlite/build/incremental-update.js` to use a clamped quantizer before packing into Uint8Array.

### 7.3.3 Persist quantization metadata where it is needed

Current code often assumes `minVal=-1` and `levels=256`, which breaks if config differs.

**Phase 7 rule**
- Any component that needs to dequantize MUST have access to the exact `(minVal, maxVal, levels)` used (or an equivalent representation).

**Implementation choice**
- Add optional fields to the dense vector artifacts and backend meta files:
  - For `dense_vectors*` artifacts: add `minVal`, `maxVal`, `levels`, and optionally `quantization` object.
  - For HNSW meta and LanceDB meta: add the same quantization fields.
  - This is safe because JSON schemas allow additionalProperties.

**Touchpoints**
- Writers:
  - `tools/build-embeddings/runner.js` (~L1–L763) (when writing dense_vectors*.json and meta)
  - `tools/build-embeddings/hnsw.js` (~L1–L115) (meta output)
  - `tools/build-embeddings/lancedb.js` (~L1–L143) (meta output)
- Readers:
  - `src/retrieval/rankers.js` (~L1–L292) (rankDenseVectors: stop hardcoding `minVal=-1`)
  - `src/retrieval/sqlite-helpers.js` (~L1–L544) (dense meta: stop hardcoding minVal)
  - `tools/build-embeddings/lancedb.js` (~L1–L143) (dequantizeUint8ToFloat32 must use correct quantization)

### 7.3.4 Update LanceDB build to dequantize correctly

**Touchpoints**
- `tools/build-embeddings/lancedb.js` (~L1–L143)

**Required changes**
- `buildBatch()` currently calls `dequantizeUint8ToFloat32(row.vec)` without passing params (defaults to -1..1, 256).
- Update `writeLanceDbIndex()` signature to accept quantization params (or `scale + minVal`), and pass through from `runner.js`.

**Correctness tests**
- A dedicated test should:
  - Configure quantization levels != 256 (e.g., 128) in a temporary repo config
  - Build embeddings and LanceDB index
  - Query LanceDB directly (or via search) and assert results are stable and not obviously degraded vs Dense

### 7.3.5 Tests for quantization invariants

**Update existing tests**
- `tests/quantize-embedding-utils.js` (if exists) or add new:
  - Assert clamping:
    - levels < 2 => 2
    - levels > 256 => 256
  - Assert no value in output exceeds 255.

**Add new test**
- `tests/embedding-quantization-no-wrap.js`
  - Construct an embedding vector with values near 1.0
  - Use quantization levels 512 in config (intentionally invalid)
  - Run the embedding build path that writes JSON and SQLite
  - Assert:
    - dense vectors JSON only contains integers 0..255
    - sqlite dense table values match expected quantization (no modulo wrap)
    - `index_state.embeddings.embeddingIdentity.quantization.levels` shows the clamped value.

---

## 7.4 Normalization policy consistency

### Why this exists

Normalization affects:
- exact dense ranking (dot product expects normalized vectors for cosine equivalence)
- ANN backends (HNSW metric, LanceDB metric)
- caching (embedding identity includes normalize)

### 7.4.1 Define and enforce normalization rules

**Rule 1**
- If `embeddingIdentity.normalize === true`, then:
  - code, doc, and merged vectors MUST be L2 normalized before storage.
  - Any dequantized float vectors used for ANN MUST be normalized (or equivalent).

**Rule 2**
- If `embeddingIdentity.normalize === false`, then:
  - storage may contain raw vectors, but ANN backend selection must respect configured metric.

**Touchpoints**
- `src/shared/embedding-adapter.js` (~L1–L158) (ensures embedding providers normalize)
- `tools/build-embeddings/embed.js` (~L1–L119) (mergeEmbeddingVectors + normalizeEmbeddingVector)
- `src/index/build/file-processor/embeddings.js` (~L1–L260) (inline embeddings path)
- `tools/build-embeddings/runner.js` (~L1–L763) (cache load path where HNSW vectors are dequantized)

**Required changes**
- Ensure build-embeddings cache load path normalizes HNSW float vectors whenever identity.normalize is true, not only when `hnswConfig.space === 'cosine'`.
- Ensure `mergeEmbeddingVectors()` behavior is explicitly specified:
  - If doc vector is missing (zeros), merged should still normalize correctly and not bias scale.
  - Add test coverage.

### 7.4.2 Tests for normalization consistency

**Add test**
- `tests/indexing/embeddings/embedding-normalization-consistency.test.js`
  - Use stub embeddings that produce a known non-normalized vector.
  - Ensure the pipeline normalizes it before storage when normalize=true.
  - Ensure merged vector equals normalized(mean(code, doc)) within tolerance.

**Update ANN tests**
- `tests/retrieval/ann/hnsw-ann.test.js` and `tests/retrieval/ann/lancedb-ann.test.js` should assert:
  - embeddings meta includes normalize=true
  - ANN meta metric/space matches expected
  - Query-time similarity ordering matches Dense within tolerance.

---

## 7.5 LanceDB robustness improvements

### Why this exists

Candidate filtering semantics and robustness issues:
- When candidateSet is large and pushdown is disabled, a single fixed-limit query may return fewer than topN matches after filtering.
- Connection caching is not concurrency-safe (race opens).
- Filter clause construction must be safe and correct.

### 7.5.1 Implement iterative overfetch for candidateSet filtering

**Touchpoints**
- `src/retrieval/lancedb.js` (~L1–L180) (function `searchLanceDbCandidates`)

**Required behavior**
- When `candidateSet` is provided:
  - Try pushdown if candidateSet is numeric and <= `LANCE_CANDIDATE_PUSH_LIMIT`.
  - Else run iterative overfetch:
    1. Start with `limit = max(topN*4, topN+10)`.
    2. Execute query with that limit.
    3. Filter results by candidateSet.
    4. If filtered count < topN AND raw results length == limit:
       - increase limit (e.g., x2) up to a cap (candidateCount or a global max).
       - repeat.
     5. Stop when enough results or when limit reaches cap.

**Correctness requirement**
- Deterministic: same inputs yield same outputs (stable sort tie-breakers).
- Efficient: cap iterations (e.g., max 4 passes).

### 7.5.2 Make connection caching concurrency-safe

**Touchpoints**
- `src/retrieval/lancedb.js` (~L1–L180) (`connectionCache`)

**Required changes**
- Store a Promise in the cache while connecting:
  - If concurrent calls happen, they await the same Promise.
- If connection fails, delete cache entry so later attempts can retry.

### 7.5.3 Harden filter construction

**Touchpoints**
- `src/retrieval/lancedb.js` (~L1–L180)

**Required changes**
- Validate `idColumn` is a safe identifier (e.g., `/^[A-Za-z_][A-Za-z0-9_]*$/`).
- Ensure `candidateSet` values are integers, not floats.

### 7.5.4 Tests for LanceDB candidate filtering

**Add new test**
- `tests/lancedb-candidate-filtering.js`
  - Use a stub dataset large enough that candidateSet > push limit.
  - Use a candidateSet that excludes most top hits.
  - Assert:
    - The function still returns topN results within candidateSet (iterative overfetch works).
    - Stats indicate multiple passes were executed (optional metric in logs).

---

### 7.5.5 Acceptance criteria

- Candidate-set filtering works for both small and large candidate sets:
  - If `candidateSet.size >= topN`, the function returns **at least** `topN` results whenever the underlying dataset contains enough matches.
  - If the dataset (or candidateSet) cannot produce `topN` matches, it returns as many as possible without throwing.
- Connection caching is concurrency-safe:
  - Concurrent queries to the same LanceDB directory do not trigger multiple `connect()` calls.
- Pushdown filtering is used when safe:
  - When `candidateSet` is numeric and `candidateSet.size <= LANCE_CANDIDATE_PUSH_LIMIT`, the query uses a `where` clause pushdown.

### 7.5.6 Tests

Add/Update the following tests (names are prescriptive; adjust location if the repo’s test layout requires flat files):

- `tests/retrieval/ann/lancedb-candidate-filtering.test.js` (new)
  - Exercises iterative overfetch when candidateSet is large.
- `tests/retrieval/ann/lancedb-connection-cache.test.js` (new)
  - Verifies promise-cached connections prevent double-open under concurrency.
- `tests/retrieval/ann/lancedb-filter-pushdown.test.js` (new)
  - Verifies pushdown is used only for safe numeric candidate sets.
- `tests/retrieval/ann/lancedb-ann.test.js` (existing)
  - Extend assertions if needed to confirm ANN backend is LanceDB and returns stable results.



## 7.6 HNSW signature compatibility and observability

### Why this exists

- `hnswlib-node` API signatures differ across versions; current code may pass the wrong second argument to `readIndexSync`.
- Insert failures are not sufficiently observable.
- Variant selection must align with denseVectorMode if Phase 7 supports doc/code/merged.

### 7.6.1 Make loadHnswIndex tolerant to signature differences

**Touchpoints**
- `src/shared/hnsw.js` (~L1–L160) (function `loadHnswIndex`)
- `src/shared/hnsw.js` (~L1–L160) (function `resolveHnswPaths` if extended to support variants)

**Required changes**
- Detect `readIndexSync` signature:
  - If it expects `(path, maxElements)` then pass maxElements (number).
  - If it expects `(path, allowReplaceDeleted)` then pass boolean.
  - If unknown, try safe fallbacks with try/catch:
    1. call with just `(path)`
    2. call with `(path, maxElements)`
    3. call with `(path, allowReplaceDeleted)`
  - Use meta/config to choose expected dims/count.

**Observability**
- When fallback path is used, log a warning once with:
  - detected arity
  - attempted signatures
  - final chosen signature

### 7.6.2 Build and load HNSW indices for merged/doc/code variants

**Touchpoints**
- Writer:
  - `tools/build-embeddings/runner.js` (~L1–L763)
  - `tools/build-embeddings/hnsw.js` (~L1–L115)
- Reader:
  - `src/retrieval/cli-index.js` (~L1–L416) (HNSW load)
  - `src/retrieval/ann/providers/hnsw.js` (~L1–L27) (already uses idx.hnsw)
  - `src/shared/hnsw.js` (~L1–L160) path resolver

**Required behavior**
- For each mode, if embeddings are ready and HNSW is enabled and available:
  - Build HNSW for:
    - merged vectors (`dense_vectors_hnsw.*`)
    - doc vectors (`dense_vectors_doc_hnsw.*`)
    - code vectors (`dense_vectors_code_hnsw.*`)
- At query-time, select which HNSW index to use based on `resolvedDenseVectorMode`.
  - This mirrors LanceDB behavior and ensures parity.
- Meta files MUST include:
  - dims, count
  - space/metric
  - efSearch/efConstruction/m
  - embeddingIdentityKey (or at least model id)
  - quantization parameters (or scale + minVal)
  - createdAt timestamp

### 7.6.3 Improve insert failure observability

**Touchpoints**
- `tools/build-embeddings/hnsw.js` (~L1–L115)

**Required changes**
- Preserve and rely on the existing atomic write pattern:
  - write to a temp path
  - atomically replace the target `.bin`
  - keep a `.bak` via `replaceFile({ keepBackup: true })`
  - never delete `.bak` unless a subsequent successful load of the new `.bin` is confirmed (and even then, deletion is optional).
- In `writeIndex()`:
  - Collect insertion failures:
    - `{ idx, label, errorMessage }` (label is the chunk id)
  - If count mismatch:
    - write a JSON file alongside meta (e.g., `dense_vectors_hnsw.failures.json`) or include failure summary in meta
    - include top N failures in error message for debugging
- Ensure build fails loudly if insertion failures occur (unless explicitly configured to allow partial indexes).

### 7.6.4 Tests for HNSW variant selection and signature fallback

**Update existing tests**
- `tests/retrieval/ann/hnsw-ann.test.js`
  - Once doc/code variants are built, assert those files exist too.
- `tests/retrieval/ann/hnsw-atomic.test.js`
  - Ensure .bak fallback still works with new load logic.

**Add new test**
- `tests/retrieval/ann/hnsw-target-selection.test.js`
  - Build embeddings with stub embeddings.
  - Force `denseVectorMode=code` and ensure HNSW provider loads the code variant.
  - Force `denseVectorMode=doc` and ensure doc variant loads.

---

### 7.6.5 Acceptance criteria

- HNSW loading is compatible across supported `hnswlib-node` versions:
  - `loadHnswIndex()` successfully loads a valid index regardless of the `readIndexSync` signature variant.
  - If a signature mismatch occurs, fallback logic selects a working call shape and logs a single diagnostic warning.
- Insert failures are observable and actionable:
  - If HNSW insertion fails for any vector, the build either:
    - fails with a clear error including a failure summary, OR
    - (only if explicitly configured) produces a partial index and writes a failures report.
- Atomicity behavior remains correct:
  - If `.bak` exists and the main `.bin` is corrupt, load falls back to `.bak` and still serves results.

### 7.6.6 Tests

Add/Update the following tests:

- `tests/retrieval/ann/hnsw-load-signature.test.js` (new)
  - Mocks multiple `readIndexSync` signatures and verifies fallback behavior.
- `tests/retrieval/ann/hnsw-insert-failures.test.js` (new)
  - Forces insertion failures and asserts a failures report (or error) is emitted.
- `tests/retrieval/ann/hnsw-ann.test.js` (existing)
  - Extend to verify doc/code variant selection if Phase 7 builds those indices.
- `tests/retrieval/ann/hnsw-atomic.test.js` (existing)
  - Must continue to pass; ensures `.bak` fallback behavior remains intact.
- `tests/retrieval/ann/hnsw-candidate-set.test.js` (existing)
  - Must continue to pass; candidate-set filtering for HNSW remains correct.



## 7.7 Backend policy and ranking equivalence

### Why this exists

We need a single coherent way to:
- select which dense vectors are used for ranking (`denseVectorMode`)
- select which ANN target is used (must align with denseVectorMode)
- compare backends on a stable fixture (parity)

### 7.7.1 Wire denseVectorMode from config/CLI into retrieval

**Touchpoints**
- `docs/guides/search.md` (~L1–L74) (already references denseVectorMode)
- `docs/guides/embeddings.md` (update to reflect denseVectorMode + strict manifest behavior)
- `docs/config/schema.json` and/or `docs/config/inventory.md` (add `search.denseVectorMode` + CLI flag documentation)
- `src/retrieval/cli/normalize-options.js` (~L1–L273) (currently hardcodes denseVectorMode='merged')
- `src/retrieval/cli/options.js` (~L1–L141) (CLI option definitions)
- `src/retrieval/cli/query-plan.js` (~L1–L205) (already passes denseVectorMode into plan)
- `src/retrieval/query-intent.js` (~L1–L84) (resolveIntentVectorMode)

**Required changes**
- Add CLI option: `--dense-vector-mode merged|doc|code|auto`
  - default should match existing behavior (`merged`) to avoid breaking changes.
- Config key is `search.denseVectorMode` (aligns with existing defaults + docs).
- Ensure `resolvedDenseVectorMode` is computed once and passed into `loadSearchIndexes()` (already).
- Ensure `resolveIntentVectorMode()` never returns `'auto'` when intent provided and valid; else allow 'auto' as fallback.
- Configuration precedence is explicit: **CLI > user config > defaults**, and log when CLI overrides a config value.

### 7.7.2 Ensure ANN backend target selection matches denseVectorMode

**Touchpoints**
- LanceDB:
  - `src/shared/lancedb.js` (~L1–L65) (`resolveLanceDbTarget`) ✅ already supports.
- HNSW:
  - `src/shared/hnsw.js` (~L1–L160) path resolver must support variants.
- SQLite-vec:
  - `tools/build-embeddings/sqlite-dense.js` (~L1–L209) and `tools/vector-extension.js` (~L1–L393)
  - If SQLite-vec is kept as merged-only, it must be documented and enforced.

**Required behavior**
- For each mode, the ANN provider uses the same vector variant as `idx.denseVec` uses.
- If a backend cannot support the selected variant, it must:
  - either fail with a clear error (if explicitly requested), or
  - fall back with an explicit warning (if auto-selected).

### 7.7.3 Parity tests: dense vs ANN backends

**Add new integration test**
- `tests/ann-parity.js`
  - Build index + embeddings for fixture repo with stub embeddings.
  - Run search with:
    - `--ann-backend dense`
    - `--ann-backend lancedb`
    - `--ann-backend hnsw`
  - For each, capture topK doc ids and scores.
  - Assert:
    - Dense is the reference.
    - ANN results contain the same top results in the same order for a deterministic stub embedding (or within a small tolerance / allow ties).
  - Run for multiple `denseVectorMode` values:
    - merged
    - code
    - doc

**Note**
- ANN parity can be relaxed for real embeddings, but for stub embeddings it should be exact or nearly exact.

---

### 7.7.4 Acceptance criteria

- `denseVectorMode` is end-to-end functional:
  - CLI/config can set `merged|doc|code|auto`.
  - The resolved mode is applied consistently to:
    - exact dense ranking
    - ANN target selection (LanceDB + HNSW; SQLite-vec if supported)
- Backend selection is explicit and explainable:
  - If a requested backend cannot satisfy the resolved vector mode, the system either errors clearly or falls back with an explicit warning (depending on selection policy).
- ANN parity tests pass on deterministic fixtures:
  - With stub embeddings, Dense vs ANN results match (or are within the defined tolerance window).

### 7.7.5 Tests

Add/Update tests:

- `tests/retrieval/ann/ann-parity.test.js` (new; can be implemented as a Node script in this repo’s style)
  - Compares Dense vs LanceDB vs HNSW across vector modes.
- `tests/retrieval/ann/dense-vector-mode.test.js` (new)
  - Verifies `resolveIntentVectorMode()` and `resolveDenseVector()` behaviors.
- `tests/retrieval/ann/ann-backend-selection.test.js` (new)
  - Verifies the capability matrix and fallback/error behaviors.
- Existing backend smoke tests:
  - `tests/retrieval/ann/lancedb-ann.test.js`
  - `tests/retrieval/ann/hnsw-ann.test.js`



## 7.8 Storage resilience (LMDB/SQLite/cache)

### 7.8.1 LMDB mapSize planning

**Touchpoints**
- `tools/build-lmdb-index.js` (~L1–L311)
- `src/storage/lmdb/schema.js` (~L1–L49) (meta keys)
- Tests: `tests/storage/lmdb/lmdb-backend.test.js` (~L1–L122), `tests/storage/lmdb/lmdb-corruption.test.js` (~L1–L105), `tests/storage/lmdb/lmdb-report-artifacts.test.js` (~L1–L125)

**Required behavior**
- Compute a conservative mapSize before writing:
  - Derive an estimate from artifact sizes (chunk_meta, postings, file_relations, etc.)
  - Add overhead factor (e.g., *2.0) and minimum floor (e.g., 256MB)
  - Cap to a maximum if needed
- Write the chosen mapSize into LMDB meta keys so debugging is easier.

### 7.8.2 SQLite dense writer safety for shared DB paths

**Touchpoints**
- `tools/build-embeddings/sqlite-dense.js` (~L1–L209)
- `tools/dict-utils/paths/db.js` (~L1–L62) (resolveSqlitePaths)

**Current risk**
- `DELETE FROM dense_vectors_ann` is unscoped; if code and prose share the same DB file, one run can delete the other mode’s ANN table.

**Required change**
Choose one (documented) approach:
- Preferred: mode-specific ANN table names:
  - `dense_vectors_ann_code`, `dense_vectors_ann_prose`
- Alternative: add `mode` column to vector table and delete by mode (if supported by extension).

Update all query code accordingly:
- `tools/vector-extension.js` query table name must match.

### 7.8.3 Embedding cache preflight metadata

**Touchpoints**
- `tools/build-embeddings/cache.js` (~L1–L26)
- `tools/build-embeddings/runner.js` (~L1–L763)

**Goal**
- Avoid scanning full cache to validate dims/identity each run on huge repos.

**Required change**
- Write a cache meta file per (mode, identityKey), e.g.:
  - `<cacheRoot>/<mode>/cache_meta.json`
  - includes: identityKey, dims, model, normalize, quantization, createdAt
- On startup, runner loads this meta and uses it for fast validation.
- If missing, fall back to current scan and then write meta.

### 7.8.4 Tests for storage resilience

**Update tests**
- LMDB tests should continue to pass; add an assertion that mapSize meta exists (if added).
- Add a new test for shared SQLite DB path configuration:
  - Configure codeDbPath == proseDbPath in a temp user config
  - Build embeddings for code and prose
  - Assert both modes’ ANN tables exist and are not deleted by the other.

---

### 7.8.5 Acceptance criteria

- LMDB build is resilient:
  - `tools/build-lmdb-index.js` chooses a mapSize that prevents MapFull errors on Phase 7 fixtures.
  - The chosen mapSize is recorded in LMDB metadata for debugging.
- SQLite ANN tables are mode-safe:
  - If code and prose share a DB file, running embeddings build for one mode does not delete the other mode’s ANN data.
- Cache preflight avoids full scans in the common case:
  - When cache meta exists, runner does not scan the entire cache to validate dims/identity.

### 7.8.6 Tests

Add/Update tests:

- `tests/storage/lmdb/lmdb-mapsize.test.js` (new)
  - Builds LMDB for a fixture repo and asserts no MapFull and that mapSize meta is present.
- `tests/storage/sqlite/ann/sqlite-ann-mode-scope.test.js` (new)
  - Configures shared DB paths and asserts both modes’ ANN tables remain intact.
- `tests/shared/cache/cache-preflight-meta.test.js` (new)
  - Ensures cache meta is written and later used to avoid scanning.
- Existing LMDB tests (must continue to pass):
  - `tests/storage/lmdb/lmdb-backend.test.js`
  - `tests/storage/lmdb/lmdb-corruption.test.js`
  - `tests/storage/lmdb/lmdb-report-artifacts.test.js`
- Storage resilience integration test:
  - `tests/storage/embeddings/embeddings-backend-resilience.test.js` (new)
    - Simulates partial backend failures (e.g., LanceDB build fails, HNSW succeeds) and asserts:
      - index_state advertises only available backends
      - retrieval does not attempt to use missing backend

### 7.8.7 Edge cases and fallback behavior

- Partial backend build failure:
  - If one backend fails (e.g., LanceDB directory missing/corrupt) but dense vectors exist:
    - `index_state.embeddings.ready` may still be true (dense vectors are usable).
    - `index_state.embeddings.backends.lancedb.available` must be false.
    - Retrieval must either fall back to another backend or Dense, without crashing.
- Manifest mismatch:
  - If an artifact exists on disk but is missing from manifest (strict mode):
    - validation should fail loudly
    - retrieval should treat it as unavailable and surface a clear message rather than guessing.

### 7.8.8 Final Phase 7 audit (mandatory)

- After all Phase 7 tasks land, perform a focused audit of **search** and **embeddings** code/tests:
  - scan for any remaining manifest-by-pass reads in strict mode
  - confirm denseVectorMode and ANN target selection are applied consistently
  - review tests for missing lane assignments or optional-dependency guards
  - update any additional files or tests discovered during the audit



## Mapping: Where this work fits in the repo

### ANN backends
- LanceDB:
  - Build: `tools/build-embeddings/lancedb.js`
  - Runtime: `src/retrieval/lancedb.js`, `src/retrieval/ann/providers/lancedb.js`, `src/shared/lancedb.js`
- HNSW:
  - Build: `tools/build-embeddings/hnsw.js`
  - Runtime: `src/shared/hnsw.js`, `src/retrieval/ann/providers/hnsw.js`, `src/retrieval/cli-index.js`
- SQLite vector extension:
  - Build: `tools/build-embeddings/sqlite-dense.js`
  - Runtime: `tools/vector-extension.js`, `src/retrieval/sqlite-helpers.js`

### Artifact contract / manifest
- Contract docs:
  - `docs/contracts/public-artifact-surface.md`
  - `docs/contracts/artifact-schemas.md`
- Schema code:
  - `src/contracts/registry.js`
  - `src/contracts/schemas/artifacts.js`
- Manifest tooling:
  - `tools/build-embeddings/manifest.js`
  - `src/shared/artifact-io/manifest.js`

---

## Addendum: Strict manifest compliance requirements

This addendum is **mandatory** for Phase 7 completeness.

### A. Strict mode must not guess filenames

Any code path that loads artifacts in strict mode MUST NOT:
- `fs.readFile(path.join(dir, 'dense_vectors_uint8.json'))`
- check for `dense_vectors_hnsw.bin` via guessed filename
- scan directories for `.lancedb`

Instead, strict mode MUST:
- load manifest (`pieces/manifest.json`)
- resolve artifact paths through `resolveArtifactPresence()`

### B. Non-strict fallback is allowed only as a temporary compatibility bridge

If non-strict mode is supported:
- It should be explicitly gated by a CLI flag (e.g., `--non-strict`) or an internal option.
- It should emit a warning that strict contract is being bypassed.

---

## Fixtures list

Use these fixtures in tests. Prefer deterministic, small fixtures; do not introduce “random” corpora that make ANN results flaky.

### Existing fixture repos already in-tree
- `tests/fixtures/sample/`  
  - Primary small deterministic fixture repo used broadly in existing tests.

### Phase 7 fixture repos to add (or verify) under `tests/fixtures/embeddings/`

If these directories do not exist yet, Phase 7 must create them exactly as specified.

1. `tests/fixtures/embeddings/basic-repo/`
   - Purpose: baseline end-to-end embeddings + ANN build on a tiny repo.
   - Must include:
     - At least 2 small code files (e.g., `src/a.js`, `src/b.py`)
     - At least 1 prose file (e.g., `README.md`)
   - Expected behavior:
     - Both `index-code` and `index-prose` produce chunk_meta and dense vectors artifacts.
     - ANN backends can be built if optional deps exist.

2. `tests/fixtures/embeddings/missing-vectors/`
   - Purpose: validate that “missing code/doc vectors” are handled deterministically (zero-fill), and merged vectors normalize correctly.
   - Must include:
     - A small code file with no doc/comments (so `docVector` can be missing/empty in some build paths)
     - A prose file that produces doc-only content
   - Expected behavior:
     - `dense_vectors_doc` for some chunks is all-zero.
     - Merged vector is normalized and non-NaN.
     - ANN builders do not crash on many identical doc vectors.

3. `tests/fixtures/embeddings/quantization-caps/`
   - Purpose: validate quantization clamping and “no wrap” invariants.
   - Must include:
     - A repo with enough chunks to exercise vector writing (even 5–10 chunks is fine).
     - A repo-local config that intentionally sets `quantization.levels` out of range (e.g., 9999).
   - Expected behavior:
     - Artifacts contain only 0..255 values.
     - `embeddingIdentity.quantization.levels` reflects the **clamped** effective value.

### Stub embeddings mode
To keep tests deterministic and fast, use stub embeddings wherever possible:
- Environment: `PAIROFCLEATS_EMBEDDINGS=stub` (or the repo’s equivalent stub toggle)
- Requirement:
  - Stub embeddings must produce deterministic vectors based only on input text and requested dims.
  - They must support both code and prose modes.

## Compat migration checklist Phase 7

Phase 7 intentionally adds fields and manifest entries. It must remain safe to run against older builds and older queue payloads.

Checklist:

- [ ] **Do not rename dense vector filenames on disk.**  
  Keep:
  - `dense_vectors_uint8.json`
  - `dense_vectors_doc_uint8.json`
  - `dense_vectors_code_uint8.json`  
  Phase 7 may add optional metadata fields to these JSON objects, but must not change filenames.

- [ ] **Queue payload versioning is explicit and safe.**
  - New jobs must include `embeddingPayloadFormatVersion: 2`.
  - Worker must either:
    - accept v1 payloads and upgrade them with a warning, or
    - refuse v1 payloads with a clear error message that points to remediation.
  - Never “silently reinterpret” ambiguous fields without logging.

- [ ] **index_state fields are additive.**
  - Preserve existing `index_state.embeddings.enabled/ready/service/mode` semantics.
  - Add new fields (`pending`, `embeddingIdentity`, `embeddingIdentityKey`, `backends`) without breaking older readers.

- [ ] **Strict manifest compatibility.**
  - Older builds may not include embedding artifacts in `pieces/manifest.json`.
  - In strict mode, treat missing manifest entries as “artifact unavailable” and surface a clear validation error (do not guess filenames).
  - If non-strict mode is supported, it may fall back to guessed filenames but must warn.

- [ ] **Optional dependencies remain optional.**
  - If `hnswlib-node` is not installed:
    - Build should skip HNSW gracefully.
    - Manifest must not list HNSW artifacts.
    - Retrieval must not advertise HNSW as available.
  - If `lancedb` is not installed:
    - Build should skip LanceDB gracefully.
    - Manifest must not list LanceDB artifacts.
    - Retrieval must not advertise LanceDB as available.
  - If `sqlite-vec` is not available:
    - Build should skip sqlite-vec ANN tables/markers.
    - Manifest must not list sqlite-vec markers.
    - Retrieval must not advertise sqlite-vec as available.
  - **Tests for optional deps must skip (not fail) when deps are missing**, with a clear skip message.
    - Document this rule for all optional-dep tests in `docs/testing/truth-table.md` (or equivalent testing guide).
    - Centralize skip checks in `tests/helpers/optional-deps.js` and reuse across tests.

- [ ] **Quantization clamp is allowed to invalidate caches.**
  - If an out-of-range `levels` value previously produced incorrect artifacts, Phase 7 clamp is a correctness fix.
  - Any resulting cache invalidation is expected; document it and ensure failures are clear (“identityKey changed”).

## Artifacts contract appendix

This appendix consolidates the *minimum* contract required for Phase 7 so implementers do not need to cross-reference multiple docs while coding. It is additive with (and must not contradict) `docs/contracts/public-artifact-surface.md`.

### A. Dense vector artifacts

These artifacts are JSON objects whose `vectors` field contains the quantized vectors.

#### A.1 `dense_vectors`  
- Manifest name: `dense_vectors`  
- On-disk file: `dense_vectors_uint8.json`

#### A.2 `dense_vectors_doc`  
- Manifest name: `dense_vectors_doc`  
- On-disk file: `dense_vectors_doc_uint8.json`

#### A.3 `dense_vectors_code`  
- Manifest name: `dense_vectors_code`  
- On-disk file: `dense_vectors_code_uint8.json`

#### Required keys (all three)
- `dims` (int)  
- `vectors` (array)  
- `scale` (number)

#### Optional keys (recommended in Phase 7)
- `model` (string or null)
- `minVal` (number)
- `maxVal` (number)
- `levels` (int)
- `quantization` (object, if you want a structured form)
- `embeddingIdentityKey` (string)
- `createdAt` (ISO timestamp)

#### Vector invariants
- For every vector `v` in `vectors`:
  - `v.length === dims`
  - every element is an integer in `[0, 255]`
- If a vector is missing upstream (no doc text, etc), zero-fill is allowed but must be deterministic.

---

### B. HNSW artifacts

HNSW consists of a binary index file plus a JSON meta file.

#### Names and paths (merged/doc/code)
- `dense_vectors_hnsw` → `dense_vectors_hnsw.bin`
- `dense_vectors_hnsw_meta` → `dense_vectors_hnsw.meta.json`
- `dense_vectors_doc_hnsw` → `dense_vectors_doc_hnsw.bin`
- `dense_vectors_doc_hnsw_meta` → `dense_vectors_doc_hnsw.meta.json`
- `dense_vectors_code_hnsw` → `dense_vectors_code_hnsw.bin`
- `dense_vectors_code_hnsw_meta` → `dense_vectors_code_hnsw.meta.json`

#### B.1 HNSW meta required keys
- `dims` (int)
- `count` (int)
- `space` (string; e.g. `cosine|l2|ip`)

#### B.2 HNSW meta optional keys (recommended)
- `efSearch` (int)
- `m` (int)
- `efConstruction` (int)
- `expectedModel` (string; legacy, if present)
- `identityKey` or `embeddingIdentityKey` (string)
- `createdAt` (ISO timestamp)
- quantization metadata (`minVal/maxVal/levels` or equivalent)

#### B.3 HNSW binary file invariants
- The `.bin` file is treated as an opaque artifact for the contract.
- It MUST be discoverable via the manifest in strict mode.
- `.bak` files are implementation details and must not be separately listed in the manifest.

---

### C. LanceDB artifacts

LanceDB consists of a directory plus a JSON meta file.

#### Names and paths (merged/doc/code)
- `dense_vectors_lancedb` → `dense_vectors.lancedb/`
- `dense_vectors_lancedb_meta` → `dense_vectors.lancedb.meta.json`
- `dense_vectors_doc_lancedb` → `dense_vectors_doc.lancedb/`
- `dense_vectors_doc_lancedb_meta` → `dense_vectors_doc.lancedb.meta.json`
- `dense_vectors_code_lancedb` → `dense_vectors_code.lancedb/`
- `dense_vectors_code_lancedb_meta` → `dense_vectors_code.lancedb.meta.json`

#### C.1 LanceDB meta required keys
- `dims` (int)
- `count` (int)
- `metric` (string; e.g. `cosine|l2|dot`)

#### C.2 LanceDB meta additional keys (recommended)
- `table` (string; table name)
- `idColumn` (string; must match how IDs are stored, typically `id`)
- `embeddingColumn` (string; column containing vector embedding)
- `identityKey` or `embeddingIdentityKey` (string)
- `createdAt` (ISO timestamp)
- quantization metadata (`minVal/maxVal/levels` or equivalent)

#### C.3 LanceDB directory invariants
- The directory MUST be discoverable via the manifest in strict mode.
- Directory contents are considered backend-specific implementation details, but must remain stable enough for readers to open.

---

### D. Manifest entry invariants

Every manifest entry must include:
- `name` (string; canonical artifact name)
- `path` (string; relative to the indexDir)
- `format` (string; one of `json|jsonl|bin|dir`)
- `bytes` (int)  
  - For `dir` entries, `bytes` may be omitted. If present, it must be deterministic.

Recommended fields:
- `sha256` for file entries (`json`, `jsonl`, `bin`)

---

### E. Cross-artifact invariants

- If `index_state.embeddings.ready === true` then the manifest MUST contain `dense_vectors`.
- If an ANN backend is reported as available in `index_state.embeddings.backends.*.available === true`, then the corresponding artifact entries MUST exist in the manifest.

--- 

# Phase 9 -- Symbol identity (collision-safe IDs) + cross-file linking 

## Objective

Eliminate correctness hazards caused by non-unique, name-based joins (notably `file::name` and legacy `chunkId` usage) and replace them with a collision-safe identity layer. Use that identity to produce:

1) **Stable, segment-aware node identity** (`chunkUid`, `segmentUid`, `virtualPath`) that survives minor line shifts and prevents collisions across:
   - same-name declarations in different files,
   - same-name declarations inside different segments of the same container file,
   - repeated definitions (overloads, nested scopes, generated code patterns).

2) **A canonical symbol identity and reference contract** (`symbolKey`, `signatureKey`, `scopedId`, `symbolId`, `SymbolRef`) that:
   - is deterministic,
   - is language-agnostic at the storage boundary,
   - preserves ambiguity instead of forcing wrong links.

3) **Cross-file resolution that is import-aware and ambiguity-preserving**, using bounded heuristics and explicit `state` / `confidence` fields.

4) **First-class symbol graph artifacts** (`symbols`, `symbol_occurrences`, `symbol_edges`) that enable downstream graph analytics and product features without re-parsing code.

5) **Fail-closed identity and symbol joins:** no `file::name` fallback in strict mode; ambiguous resolutions are preserved, not guessed.

---
# Phase 9 -- Symbol identity (collision-safe IDs) + cross-file linking (detailed execution plan)



## Phase 9 objective (what "done" means)

Eliminate all correctness hazards caused by non-unique, name-based joins (notably `file::name` and legacy `chunkId` usage) and replace them with a collision-safe, stability-oriented identity layer. Use that identity to produce:

1) **Stable, segment-aware node identity** (`chunkUid`, `segmentUid`, `virtualPath`) that survives minor line shifts and prevents collisions across:
   - same-name declarations in different files,
   - same-name declarations inside different segments of the same container file,
   - repeated definitions (overloads, nested scopes, generated code patterns).

2) **A canonical symbol identity and reference contract** (`symbolKey`, `signatureKey`, `scopedId`, `symbolId`, `SymbolRef`) that:
   - is deterministic,
   - is language-agnostic at the storage boundary,
   - preserves ambiguity instead of forcing wrong links.

3) **Cross-file resolution that is import-aware and ambiguity-preserving**, using bounded heuristics and explicit confidence/status fields.

4) **First-class symbol graph artifacts** (`symbols.jsonl`, `symbol_occurrences.jsonl`, `symbol_edges.jsonl`) that enable downstream graph analytics and product features without re-parsing code.

5) **Fail-closed identity and symbol joins:** no file::name fallback in strict mode; ambiguous resolutions are preserved, not guessed.

This phase directly targets the Phase 9 intent in the roadmap ("Symbol identity (collision-safe IDs) + cross-file linking") and depends on the canonical `chunkUid` contract delivered in Phase 8. In particular, the `chunkUid` construction approach and "fail closed" requirement are consistent with the canonical identity contract described in the planning materials.

---

## Phase 9 non-goals (explicitly out of scope for Phase 9 acceptance)

These may be separate follow-on phases or optional extensions:

- Full **SCIP/LSIF/ctags hybrid symbol source registry** (runtime selection/merging) beyond ensuring the contracts can represent those IDs.
- Full module-resolution parity with Node/TS (tsconfig paths, package exports/imports, Yarn PnP, etc). Phase 9 supports **relative import resolution** only.
- Whole-program correctness for dynamic languages; Phase 9 focuses on **correctness under ambiguity** (never wrong-link) rather than "resolve everything".
- Cross-repo symbol federation.

---

## Phase 9 key decisions (locked)

These choices remove ambiguity and prevent future "forks" in implementation.

### D1) Graph node identity uses `chunkUid`, not `file::name`, not legacy `chunkId`

- **Chosen:** `chunkUid` is the canonical node identifier for graphs and cross-file joins.
- **Why:** `file::name` is not unique; `chunkId` is range-based and churns with line shifts. The roadmap's canonical identity guidance explicitly calls for a `chunkUid` that is stable under line shifts and includes segment disambiguation.

### D2) Symbol identity is a two-layer model: `symbolKey` (human/debug) + `symbolId` (portable token)

- **Chosen:** Persist both.
- **Why:** `symbolKey` is explainable and supports deterministic "rebuild equivalence" reasoning. `symbolId` is compact and future-proofs external sources (SCIP/LSIF) without schema churn.

### D3) Cross-file resolution is ambiguity-preserving

- **Chosen:** When multiple plausible targets exist, record candidates and mark the ref **ambiguous**; do not pick arbitrarily.
- **Why:** Wrong links destroy trust and cascade into graph features, risk flows, and context packs. Ambiguity can be resolved later by better signals.

### D4) Artifact emission is streaming-first and deterministically ordered

- **Chosen:** JSONL for symbol artifacts; deterministic sharding and sorting.
- **Why:** Large repos must not require in-memory materialization of symbol graphs; deterministic ordering is required for reproducible builds and regression testing.

---

## Phase 9 contracts (normative, implementation-ready)

> These contracts must be implemented exactly as specified to avoid drift.

### 9.C1 Identity contract (v1)

#### 9.C1.1 `segmentUid` (string | null)

- **Definition:** A stable identifier for a segment inside a container file (Vue SFC blocks, fenced Markdown blocks, etc).
- **Scope:** Unique within the repo (i.e., global uniqueness is acceptable and preferred).
- **Stability:** Must remain stable under *minor line shifts* outside the segment content.

**Algorithm (v1):**

```
segmentUid = "seg1:" + xxhash64(
  containerRelPath + "\0"
  + segmentType + "\0"
  + effectiveLanguageId + "\0"
  + normalizeText(segmentText)
  + "\0"
  + (parentSegmentUid ?? "")
)
```

- `normalizeText`:
  - normalize line endings to `\n`
  - preserve all non-whitespace characters
  - do not strip trailing whitespace by default (correctness-first)

#### 9.C1.2 `virtualPath` (string)

A deterministic "as-if file path" that disambiguates segments:

- If no segment: `virtualPath = fileRelPath`
- If segment: `virtualPath = fileRelPath + "#seg:" + segmentUid`

#### 9.C1.3 `chunkUid` (string)

- **Definition:** Stable-ish identifier for a chunk, used for graphs and join keys.
- **Stability:** Must remain stable when only lines outside the chunk's span shift (i.e., chunk text unchanged).
- **Collision handling:** If a collision is detected within `{virtualPath, segmentUid}`, deterministically disambiguate and record `collisionOf`.

**Algorithm (v1) -- consistent with the canonical contract described in the planning docs:**

```
span = normalizeForUid(chunkText)
pre  = normalizeForUid(text.slice(max(0, start-128), start))
post = normalizeForUid(text.slice(end, min(len, end+128)))

spanHash = xxhash64("span\0" + span)
preHash  = xxhash64("pre\0" + pre)   (only if pre.length > 0)
postHash = xxhash64("post\0" + post) (only if post.length > 0)

base = "ck64:v1:" + namespaceKey + ":" + virtualPath + ":" + spanHash
if (segment.languageId) base = "ck64:v1:" + namespaceKey + ":" + virtualPath + ":" + segment.languageId + ":" + spanHash
if (preHash)  base += ":" + preHash
if (postHash) base += ":" + postHash

chunkUid = base
```

This follows the canonical identity contract exactly (see `docs/specs/identity-contract.md` §4).

**Collision disambiguation (required):**

If `chunkUid` already exists for a different chunk under the same `virtualPath` scope:

- set `collisionOf = originalChunkUid`
- follow the canonical disambiguation steps: escalate context windows once, then assign deterministic ordinals and append `:ord<index>`.

> Note: the ordinal must be deterministic across runs given identical inputs.

#### 9.C1.4 metaV2 additions

`metaV2` MUST include:

- `chunkUid: string`
- `segmentUid: string | null`
- `virtualPath: string`

And SHOULD include (for diagnostics and future hardening):

- `identity: { v: 1, spanHash: string, preHash: string, postHash: string, collisionOf?: string }`

### 9.C2 Symbol identity contract (v1)

#### 9.C2.1 `kindGroup`

Normalize "kind" strings into a stable group set:

- `function`, `arrow_function`, `generator` → `function`
- `class` → `class`
- `method`, `constructor` → `method`
- `interface`, `type`, `enum` → `type`
- `variable`, `const`, `let` → `value`
- `module`, `namespace`, `file` → `module`
- unknown/other → `other`

#### 9.C2.2 `symbolKey`

```
symbolKey = virtualPath + "::" + qualifiedName + "::" + kindGroup
```

- `qualifiedName` defaults to `chunk.name`.
- When available, prefer container-aware names like `Class.method`.

#### 9.C2.3 `signatureKey` (optional)

```
signatureKey = qualifiedName + "::" + normalizeSignature(signature)
```

`normalizeSignature` must:
- collapse runs of whitespace to a single space
- preserve punctuation, generics, and parameter ordering

#### 9.C2.4 `scopedId`

```
scopedId = kindGroup + "|" + symbolKey + "|" + (signatureKey ?? "") + "|" + chunkUid
```

#### 9.C2.5 `symbolId`

- Deterministic, compact token:
- `symbolId = schemePrefix + sha1(scopedId)`

Where `schemePrefix` depends on source:

- Native/chunk-based: `sym1:heur:` (heuristic/native)
- SCIP: `sym1:scip:`
- LSIF: `sym1:lsif:`
- CTAGS: `sym1:ctags:`

> Phase 9 implements only `heur` generation but must preserve the scheme field in schemas.

#### 9.C2.6 `SymbolRef` (reference envelope)

A reference to a symbol, which may be resolved, ambiguous, or unresolved.

```
SymbolRefV1 = {
  v: 1,
  targetName: string,          // observed identifier, e.g. "foo" or "Foo.bar"
  kindHint: string | null,      // optional hint, e.g. "function"
  importHint: {
    moduleSpecifier: string | null,
    resolvedFile: string | null
  } | null,
  candidates: Array<{
    symbolId: string,
    chunkUid: string,
    symbolKey: string,
    signatureKey: string | null,
    kindGroup: string
  }>,
  status: "resolved" | "ambiguous" | "unresolved",
  resolved: {
    symbolId: string,
    chunkUid: string
  } | null
}
```

- `candidates` MUST be capped (see resolver caps in Phase 9.4).
- `resolved` is non-null only when `status === "resolved"`.

### 9.C3 Symbol graph artifacts (v1)

All symbol artifacts are emitted in `index-code/`:

- `symbols.jsonl`
- `symbol_occurrences.jsonl`
- `symbol_edges.jsonl`

Each line is one JSON object. Deterministic order and deterministic sharding are required.

#### 9.C3.1 `symbols.jsonl`

One record per symbol definition (i.e., per chunk with `metaV2.symbol`):

```
{
  "v": 1,
  "symbolId": "...",
  "scopedId": "...",
  "scheme": "heur",
  "symbolKey": "...",
  "signatureKey": null | "...",
  "chunkUid": "...",
  "virtualPath": "...",
  "segmentUid": null | "...",
  "file": "...",
  "lang": "...",
  "kind": "...",
  "kindGroup": "...",
  "name": "...",
  "qualifiedName": "...",
  "signature": null | "..."
}
```

#### 9.C3.2 `symbol_occurrences.jsonl`

One record per observed reference occurrence (calls, usages). At minimum:

```
{
  "v": 1,
  "fromChunkUid": "...",
  "fromFile": "...",
  "fromVirtualPath": "...",
  "occurrenceKind": "call" | "usage",
  "targetName": "...",
  "range": { "start": number, "end": number } | null,
  "ref": SymbolRefV1
}
```

#### 9.C3.3 `symbol_edges.jsonl`

One record per reference edge (call, usage) emitted from chunk relations:

```
{
  "v": 1,
  "edgeKind": "call" | "usage",
  "fromChunkUid": "...",
  "fromSymbolId": null | "...",
  "to": SymbolRefV1,
  "confidence": number,         // 0..1
  "evidence": {
    "importNarrowed": boolean,
    "matchedExport": boolean,
    "matchedSignature": boolean
  }
}
```

### 9.C4 Graph relations artifact migration (v2)

`graph_relations.json` MUST be updated such that:

- Node `id` is `chunkUid` (not legacy chunkId and not `file::name`)
- Node `attrs` include:
  - `chunkUid`, `chunkId` (legacy), `legacyKey` (for diagnostics only)
  - `symbolId` (when available)
- Edges are emitted **only** for resolved symbol edges (status=resolved)

---

## Phase 9 implementation plan (phases/subphases/tasks/tests)

### 9.1 Verify identity primitives (`segmentUid`, `chunkUid`, `virtualPath`) -- delivered in Phase 8

> If any identity primitive is missing or diverges from the canonical spec, stop Phase 9 and complete the work in Phase 8 before continuing.

**Verification checklist (no new algorithm changes in Phase 9)**
- Code presence:
  - `src/index/identity/*` helpers exist and match `docs/specs/identity-contract.md`.
  - `segmentUid`, `virtualPath`, and `chunkUid` are populated in `metaV2` for every code chunk.
- Behavior:
  - `segmentUid` stable under line shifts outside the segment.
  - `chunkUid` stable under line shifts outside the chunk span; changes when span text changes.
  - Collision handling uses canonical escalation + `:ord<N>` suffixes.
- Fail-closed identity rules:
  - Strict validation rejects any chunk missing `chunkUid`/`segmentUid`/`virtualPath`.
  - No file::name fallback for joins in strict mode.
- Tests (already required in Phase 8; rerun only if identity code changes):
  - tests/unit/segment-uid-stability.test.js (test:unit)
  - tests/unit/chunk-uid-stability.test.js (test:unit)
  - tests/validate/chunk-uid-required.test.js (test:services)
  - tests/indexing/relations/graph-chunk-id.test.js (updated to chunkUid)

---

### 9.2 Implement symbol identity (`metaV2.symbol`, `SymbolRef`) and helpers

**Primary touchpoints**
- `src/index/metadata-v2.js` — attach `metaV2.symbol` (definition chunks only).
- `src/shared/identity.js` — **already exists** and contains symbol identity primitives. Phase 9 MUST extend/reuse this (do **not** fork identity algorithms).
- New (optional wrapper): `src/index/identity/symbol.js` — if created, keep it as a thin adapter over `src/shared/identity.js` for index-specific policy (definition chunk detection, kind-group mapping, etc).
- Update callsites: graph builder, cross-file resolver, map builder

#### 9.2.1 Implement symbol identity builder

- [x] **Update `src/shared/identity.js` (do this first)**
  - [x] Confirm/export the primitives used by every symbol identity producer:
    - `buildSymbolKey(...)`
    - `buildSignatureKey(...)`
    - `buildScopedSymbolId(...)`
    - `buildSymbolId(...)`
    - `resolveSymbolJoinKey(...)` (used to join calls/usages to symbol definitions)
  - [x] Ensure the primitives accept the Phase 9 canonical inputs (`virtualPath`, `qualifiedName`, `signature`, `kindGroup`, `chunkUid`/`segmentUid` as required by the Phase 9 contracts) and **do not depend on legacy `chunkId`** for uniqueness unless explicitly marked legacy/back-compat.

- [x] **Add `src/index/identity/kind-group.js`**
  - [x] Implement `toKindGroup(kind: string | null): string`

- [x] **Add `src/index/identity/symbol.js`** *(thin adapter over `src/shared/identity.js`)*
  - [x] Export `buildSymbolIdentity({ metaV2 }): { scheme, kindGroup, qualifiedName, symbolKey, signatureKey, scopedId, symbolId } | null`
  - [x] **Hard requirement:** implement hashing/key building by calling helpers from `src/shared/identity.js` (e.g., `buildSymbolKey`, `buildSignatureKey`, `buildScopedSymbolId`, `buildSymbolId`).  
    Do **not** create a second independent SymbolKey/SignatureKey algorithm.
  - [x] Return null when chunk is not a "definition chunk" (policy below).

**Definition chunk policy (v1):**

- A chunk is a definition chunk if:
  - `chunk.name` is truthy AND not equal to `"(module)"` unless kindGroup is `module`, AND
  - `chunk.kind` is truthy OR `chunk.name === "(module)"`, AND
  - `metaV2.lang` is truthy (code mode).

> This policy is intentionally permissive; it can be tightened later, but Phase 9 prioritizes completeness with ambiguity-safe linking.

#### 9.2.2 Populate `metaV2.symbol`

- [x] **Modify `src/index/metadata-v2.js`**
  - [x] After identity fields are set, compute `metaV2.symbol` via `buildSymbolIdentity`.
  - [x] Ensure `symbolKey` is based on `virtualPath`, not `file`.
  - [x] Ensure `symbolId` is deterministic.

#### 9.2.3 Tests for symbol identity

- [x] **Add `tests/indexing/identity/symbol-identity.test.js`**
  - Given a fake `metaV2` with chunkUid/virtualPath/kind/name/signature:
    - assert `symbolKey`, `signatureKey`, `scopedId` are correct.
    - assert `symbolId` is stable across runs.
    - assert `kindGroup` normalization.

---

### 9.3 Implement import-aware cross-file resolution (ambiguity-preserving)

**Primary touchpoints**
- `src/index/type-inference-crossfile/pipeline.js`
- New: `src/index/type-inference-crossfile/resolver.js`
- Update language relations to supply import bindings:
  - `src/lang/javascript/relations.js` (and optionally TS)

#### 9.3.1 Extend language relations to capture import bindings (JS/TS)

- [x] **Modify `src/lang/javascript/relations.js`**
  - [x] During AST walk, build `importBindings`:
    - `import { foo as bar } from "./x"` ⇒ `bar -> { imported: "foo", module: "./x" }`
    - `import foo from "./x"` ⇒ `foo -> { imported: "default", module: "./x" }`
    - `import * as ns from "./x"` ⇒ `ns -> { imported: "*", module: "./x" }`
  - [x] Store in the returned relations object as `importBindings`.

- [x] **Modify `src/index/build/file-processor/relations.js`**
  - [x] Include `importBindings` in fileRelations entries.

- [x] **Update file_relations schema** (`src/shared/artifact-schemas.js`)
  - [x] Allow optional `importBindings` field.

#### 9.3.2 Add relative import resolver helper

- [x] **Add `src/index/type-inference-crossfile/resolve-relative-import.js`**
  - [x] Implement `resolveRelativeImport(importerFile: string, spec: string, fileSet: Set<string>): string | null`
  - [x] Constraints:
    - only handle `./` and `../` specifiers
    - resolve with extension probing:
      - `.ts`, `.tsx`, `.js`, `.jsx`, `.mjs`, `.cjs`
      - directory index: `spec + "/index" + ext`
    - normalize to repo-relative POSIX paths (match existing `chunk.file` conventions)

#### 9.3.3 Implement resolver (SymbolRef builder)

- [x] **Add `src/index/type-inference-crossfile/resolver.js`**
  - [x] Build a `NativeSymbolIndex` from `chunks`:
    - `byVirtualPath: Map<string, { byExportName: Map<string, SymbolDef[]> }>`
    - `byNameGlobal: Map<string, SymbolDef[]>`
    - index both full qualifiedName and leaf name (`foo.bar` ⇒ also index `bar`) but record `matchKind`.
  - [x] Implement `resolveRef({ fromChunk, targetName, kindHint, fileRelations, fileSet }): SymbolRefV1`
    - Bounded candidate collection + scoring (see caps below)
    - Import narrowing:
      - If `importBindings` provides a binding for the target's root identifier, resolve that module to a file.
      - Restrict candidate search to those files; then apply export filtering:
        - if imported name is known, prefer matching exports.
    - If exactly one best candidate above threshold ⇒ `status=resolved`
    - Else if >=2 candidates above threshold ⇒ `status=ambiguous` with top-K candidates
    - Else ⇒ `status=unresolved` with empty candidates

**Caps / guardrails (must be implemented):**

- `MAX_CANDIDATES_PER_REF = 25`
- `MAX_CANDIDATES_GLOBAL_SCAN = 200` (if exceeded, downgrade to ambiguous with "too many" signal)
- Deterministic sorting of candidates:
  - primary: score desc
  - secondary: `symbolKey` asc

#### 9.3.4 Resolver tests

- [x] **Add `tests/indexing/type-inference/crossfile/resolve-relative-import.test.js`**
  - table-driven tests for extension probing and index resolution.

- [x] **Add `tests/indexing/type-inference/crossfile/symbolref-resolution.test.js`**
  - Build synthetic chunks with metaV2.symbol identities across:
    - two files exporting same name `foo` ⇒ ambiguous
    - importer with `import { foo } from "./a"` ⇒ resolved to `a`
    - alias import `import { foo as bar }` and call `bar()` ⇒ resolved
    - unresolved case: no exports match

---

### 9.4 Update cross-file inference pipeline to emit SymbolRef-based links

**Primary touchpoints**
- `src/index/type-inference-crossfile/pipeline.js`
- `src/index/type-inference-crossfile/symbols.js` (deprecate or repurpose)
- Tooling providers that key by `file::name`

#### 9.4.1 Replace `file::name` joins with chunkUid/symbol identity joins

- [x] **Modify `src/index/type-inference-crossfile/pipeline.js`**
  - [x] Replace `chunkByKey` (`file::name`) map with:
    - `chunkByUid: Map<chunkUid, chunk>`
    - `defsBySymbolId: Map<symbolId, chunkUid>` (for quick reverse lookup)
  - [x] Replace legacy `calleeKey = file::target` logic with resolved SymbolRef:
    - call summary includes `resolvedCalleeChunkUid` when available.

#### 9.4.2 Emit new-format `callLinks` and `usageLinks`

- [x] In pipeline, for each call relation:
  - [x] Build `SymbolRefV1` via resolver.
  - [x] Append `codeRelations.callLinks` entry in **new format**:
    ```
    {
      v: 1,
      edgeKind: "call",
      fromChunkUid: <caller chunkUid>,
      to: <SymbolRefV1>,
      confidence: <0..1>,
      evidence: {...}
    }
    ```
  - [x] Preserve legacy fields only if necessary for backward compatibility:
    - if retained, ensure they are explicitly marked `legacy: true` and never used for joins.

- [x] Same for `usageLinks` with `edgeKind: "usage"`.

#### 9.4.3 Keep `callSummaries` but add chunkUid resolution

- [x] Extend each `callSummaries[]` record to include:
  - `calleeRef: SymbolRefV1`
  - `resolvedCalleeChunkUid: string | null`
  - Keep `target/file/kind` for display backward compatibility.

#### 9.4.4 Tooling provider audit (chunkUid-keyed outputs are already implemented)

✅ **Current repo state (verified in code):** all built-in tooling providers already return results keyed by `chunkUid` (no `file::name` Maps).

Providers (current touchpoints):
- `src/index/tooling/clangd-provider.js` — returns `{ byChunkUid }` (capability: `supportsSymbolRef: false`)
- `src/index/tooling/pyright-provider.js` — returns `{ byChunkUid }` (capability: `supportsSymbolRef: false`)
- `src/index/tooling/sourcekit-provider.js` — returns `{ byChunkUid }` (capability: `supportsSymbolRef: false`)
- `src/index/tooling/typescript-provider.js` — returns `{ byChunkUid }` (capability: `supportsSymbolRef: true`)

**Why keep this task anyway?**  
Phase 9 relies on `chunkUid` as the canonical join key, so we need a regression-proof audit + tests that prevent reintroducing `file::name` joins.

- [x] Confirm each provider’s public output surface is `{ provider, byChunkUid }` (not `{ byFile }`).
- [x] Add a targeted regression test per provider that asserts:
  - [x] the top-level key is `byChunkUid`,
  - [x] keys look like `ck64:v1:` / `chunk:`-style UIDs (not `file::name`),
  - [x] duplicate keys are not silently overwritten (throw or log+count, but do not drop).
  - Suggested test files (choose lane explicitly):
    - `tests/tooling/lsp/clangd-provider-output-shape.test.js`
    - `tests/tooling/lsp/pyright-provider-output-shape.test.js`
    - `tests/tooling/lsp/sourcekit-provider-output-shape.test.js`
    - `tests/tooling/lsp/typescript-provider-output-shape.test.js`

**Additional Phase 9 requirement for TS provider**
- [x] Ensure the TS provider’s `symbolRef` emission uses the Phase 9 symbol identity scheme (see 9.2), and does not embed legacy `chunkId` in any join-critical field unless explicitly marked “legacy/back-compat”.

#### 9.4.5 Pipeline tests

- [x] Update / add tests under `tests/type-inference-crossfile/*`:
  - Assert pipeline outputs `callLinks[].to.status` values are correct for fixtures.
  - Assert callSummaries contains `calleeRef` and `resolvedCalleeChunkUid` when resolvable.
  - Assert no `Map` join uses `file::name` in the pipeline (lint-like test via grep in CI is acceptable).

---

### 9.5 Emit symbol artifacts (`symbols`, `symbol_occurrences`, `symbol_edges`)

**Primary touchpoints**
- `src/index/build/artifacts.js`
- New writer modules in `src/index/build/artifacts/writers/`
- `src/shared/artifact-io.js`
- `src/shared/artifact-schemas.js`
- `src/index/validate.js`

#### 9.5.1 Add writer modules

- [x] **Add `src/index/build/artifacts/writers/symbols.js`**
  - [x] Iterator over `state.chunks` yielding `symbols.jsonl` records.
  - [x] Deterministic order: sort by `symbolId` (or by `(virtualPath, qualifiedName, kindGroup, chunkUid)` if streaming constraints require per-shard sort).
  - [x] Use JSONL sharding logic similar to `file-relations.js`.

- [x] **Add `src/index/build/artifacts/writers/symbol-occurrences.js`**
  - [x] Iterate chunks; for each call/usage relation occurrence emit occurrence record with `ref` included.

- [x] **Add `src/index/build/artifacts/writers/symbol-edges.js`**
  - [x] Iterate chunks; for each callLinks/usageLinks edge emit edge record.
  - [x] Emit unresolved/ambiguous edges as well (they're valuable for metrics and later resolution).

#### 9.5.2 Integrate into artifact build

- [x] **Modify `src/index/build/artifacts.js`**
  - [x] Write the three symbol artifacts into `index-code/`.
  - [x] Ensure pieces manifest includes them.

- [x] **Modify `src/shared/artifact-io.js`**
  - [x] Add JSONL required keys entries for:
    - `symbols` (e.g., require `v`, `symbolId`, `chunkUid`)
    - `symbol_edges` (require `v`, `edgeKind`, `fromChunkUid`, `to`)
    - `symbol_occurrences` (require `v`, `fromChunkUid`, `occurrenceKind`)

- [x] **Modify `src/shared/artifact-schemas.js`**
  - [x] Add schemas for the new artifacts.

#### 9.5.3 Add validation and metrics hooks

- [x] **Modify `src/index/validate.js`**
  - [x] When symbol artifacts are present:
    - [x] validate schema
    - [x] cross-check referential integrity:
      - every `symbols.chunkUid` exists in chunk_meta
      - every resolved edge `to.resolved.chunkUid` exists
  - [x] Compute and print metrics (non-fatal unless strict flag is enabled):
    - `resolvedRate`, `ambiguousRate`, `unresolvedRate`

#### 9.5.4 Tests for artifacts

- [x] Add `tests/indexing/artifacts/symbol-artifacts-smoke.test.js`
  - Build a small in-memory "fake state" with 2 chunks and resolved/ambiguous links.
  - Run iterators and ensure JSONL output lines validate and include required keys.

---

### 9.6 Migrate relation graphs to use `chunkUid` and resolved edges only

**Primary touchpoints**
- `src/index/build/graphs.js`
- `tests/indexing/relations/graph-chunk-id.test.js`
- `src/map/build-map.js` (consumes graph_relations)

#### 9.6.1 Update graph builder

- [x] **Modify `src/index/build/graphs.js`**
  - [x] Node identity:
    - `nodeId = chunk.metaV2.chunkUid`
    - Store legacy fields as attributes only.
  - [x] Edges:
    - For each `callLinks`/`usageLinks` edge record:
      - if `to.status !== "resolved"` ⇒ skip for graph_relations edges
      - else edge target is `to.resolved.chunkUid`
  - [x] Remove `chunkIdByKey` (`file::name`) join logic entirely.
  - [x] Keep guardrails and sampling; update samples to include `chunkUid`.

#### 9.6.2 Graph schema/version bump

- [x] Bump `graph_relations.version` to `2`
- [x] Ensure consumers handle version 1 and 2:
  - v1: id may be chunkId or legacyKey
  - v2: id is chunkUid
  - Map builder should accept both (backward compatibility).

#### 9.6.3 Tests

- [x] Update `tests/indexing/relations/graph-chunk-id.test.js`
  - Ensure:
    - nodes keyed by chunkUid
    - collision scenario produces distinct node ids
    - legacyKey remains in attrs for diagnostics
  - Add regression: ambiguous edges are not included in graph edges.

---

### 9.7 Update map build to use new identities (and avoid collisions)

**Primary touchpoints**
- `src/map/build-map.js`
- `src/map/isometric/client/map-data.js` (only if assumptions change)

#### 9.7.1 Update symbol keying inside map build

- [x] **Modify `src/map/build-map.js`**
  - Replace `buildSymbolId(file::name)` with:
    - prefer `chunk.metaV2.symbol.symbolId`
    - else use `chunk.metaV2.chunkUid`
  - Maintain a mapping:
    - `memberId -> chunkUid`
  - Use graph_relations v2 node ids (`chunkUid`) to join to chunk_meta.

#### 9.7.2 Backward compatibility

- [x] If graph_relations.version === 1:
  - maintain existing behavior (best-effort)
- [x] If version === 2:
  - require chunkUid mapping; fail with explicit error if missing (do not silently mis-join).

#### 9.7.3 Map tests

- [x] Add `tests/indexing/map/map-build-symbol-identity.test.js`
  - Build minimal graph_relations v2 + chunk_meta fixture.
  - Assert map members are distinct for same-name collisions.

---

### 9.8 Performance, determinism, and regression guardrails

#### 9.8.1 Determinism requirements

- [x] `chunkUid` deterministic for identical inputs.
- [x] Symbol artifacts emitted in deterministic line order.
- [x] Graph builder output deterministic ordering (`serializeGraph` already sorts).

Add tests:

- [x] `tests/indexing/determinism/symbol-artifact-order.test.js`
  - Run iterator twice and assert identical output.

#### 9.8.2 Throughput requirements

- [x] Avoid O(N^2) scans over all symbols per reference:
  - use name-indexed maps and import-narrowing.
- [x] Avoid per-reference filesystem operations:
  - precompute `fileSet` in resolver.

Add tests/benchmarks (optional but recommended):

- [x] `tools/bench/symbol-resolution-bench.js`
  - synthetic repo with 100k symbols and 200k refs; ensure runtime is bounded.

---

## Phase 9 exit criteria (must all be true)

- [x] No graph or cross-file linking code performs `Map.set()` keyed solely by `file::name` in a way that can silently overwrite distinct entities.
- [x] `metaV2.chunkUid` is present and non-empty for every code chunk ("fail closed").
- [x] `graph_relations.version === 2` and node ids are `chunkUid`.
- [x] Pipeline emits SymbolRef-based call/usage links; ambiguous/unresolved are preserved explicitly.
- [x] Symbol artifacts are written and validate successfully on the small fixture suite.
- [x] New tests for chunkUid stability and resolver correctness are green.

---

## Appendix A -- Concrete file-by-file change list

This appendix is purely to reduce "search time" during implementation. Each file lists the exact intent.

### A.1 New files to add

- `src/index/identity/normalize.js`
- `src/index/identity/virtual-path.js`
- `src/index/identity/segment-uid.js`
- `src/index/identity/chunk-uid.js`
- `src/index/identity/kind-group.js`
- `src/index/identity/symbol.js`
- `src/index/type-inference-crossfile/resolve-relative-import.js`
- `src/index/type-inference-crossfile/resolver.js`
- `src/index/build/artifacts/writers/symbols.js`
- `src/index/build/artifacts/writers/symbol-occurrences.js`
- `src/index/build/artifacts/writers/symbol-edges.js`
- Tests:
  - `tests/identity/chunk-uid-stability.test.js`
  - `tests/identity/segment-uid-stability.test.js`
  - `tests/indexing/identity/symbol-identity.test.js`
  - `tests/indexing/type-inference/crossfile/resolve-relative-import.test.js`
  - `tests/indexing/type-inference/crossfile/symbolref-resolution.test.js`
  - `tests/indexing/artifacts/symbol-artifacts-smoke.test.js`
  - `tests/indexing/map/map-build-symbol-identity.test.js`
  - `tests/indexing/determinism/symbol-artifact-order.test.js`

### A.2 Existing files to modify

- `src/index/segments.js` -- compute and propagate `segmentUid`
- `src/index/build/file-processor.js` -- compute `chunkUid`
- `src/index/build/file-processor/assemble.js` -- pass through chunkUid fields
- `src/index/metadata-v2.js` -- include identity + symbol identity
- `src/lang/javascript/relations.js` -- emit `importBindings`
- `src/index/build/file-processor/relations.js` -- include importBindings
- `src/shared/artifact-schemas.js` -- add schemas, extend file_relations
- `src/shared/artifact-io.js` -- required keys for new JSONL artifacts
- `src/index/type-inference-crossfile/pipeline.js` -- emit SymbolRef edges and avoid file::name joins
- `src/index/tooling/{typescript,pyright,clangd,sourcekit}-provider.js` -- key by chunkUid
- `src/index/build/artifacts.js` -- write symbol artifacts
- `src/index/validate.js` -- validate symbol artifacts (optional strict)
- `src/index/build/graphs.js` -- graph_relations v2 using chunkUid
- `src/map/build-map.js` -- join graph nodes to chunk meta via chunkUid
- `tests/indexing/relations/graph-chunk-id.test.js` -- update

---

## Appendix B -- Metrics to report (recommended)

- `symbol_resolution.resolved_rate`
- `symbol_resolution.ambiguous_rate`
- `symbol_resolution.unresolved_rate`
- `symbol_resolution.max_candidates_hit_rate`
- `symbol_resolution.import_narrowed_rate`

In strict CI mode, optionally enforce:

- `wrong_link_rate == 0` on fixtures with gold truth
- `resolved_rate >= threshold` on fixtures (threshold set per fixture)

---

## Added detail (Phase 9 task mapping)

### 9.1 Identity primitives (segmentUid, chunkUid, virtualPath)
- Files to change/create:
  - New: src/index/identity/normalize.js, virtual-path.js, segment-uid.js, chunk-uid.js
  - Existing: src/index/segments.js (assignSegmentUids / buildSegmentUid at ~17-50)
  - Existing: src/index/build/file-processor/assemble.js (buildChunkPayload at ~52-105)
  - Existing: src/index/metadata-v2.js (buildMetaV2 uses chunk/meta fields at ~214-260)
  - Existing: src/index/chunk-id.js (legacy chunkId; used by resolveChunkId)
- Call sites/line refs:
  - src/index/segments.js:17-50 (buildSegmentUid, assignSegmentUids)
  - src/index/build/file-processor/assemble.js:52-105
  - src/index/chunk-id.js:1-18
- Gaps/conflicts:
  - Resolved: docs/phases/phase-9/identity-contracts.md now matches docs/specs/identity-contract.md for chunkUid (span/pre/post hashes + virtualPath + segmentUid).
  - Phase 8 spec updated to align; Phase 9 remains the implementation target.

### 9.2 Symbol identity (metaV2.symbol + SymbolRef)
- Files to change/create:
  - New: src/index/identity/kind-group.js, src/index/identity/symbol.js
  - Existing: src/index/metadata-v2.js (add symbol object after identity fields)
  - Existing: src/index/type-inference-crossfile/symbols.js (leafName/isTypeDeclaration; may be replaced by identity helpers)
- Call sites/line refs:
  - src/index/metadata-v2.js:214-260 (current metaV2 fields)
  - src/index/type-inference-crossfile/symbols.js:1-30
- Gaps/conflicts:
  - Resolved: symbolKey inputs now use `virtualPath` (segmentUid-based), not segmentId.

### 9.3 Import-aware cross-file resolver
- Files to change/create:
  - New: src/index/type-inference-crossfile/resolve-relative-import.js, resolver.js
  - Existing: src/lang/javascript/relations.js (add importBindings during AST walk; call site around 360-420)
  - Existing: src/index/build/file-processor/relations.js (persist importBindings into fileRelations)
  - Existing: src/contracts/schemas/artifacts.js (extend file_relations schema)
- Call sites/line refs:
  - src/lang/javascript/relations.js:360-418 (AST traversal + callDetails)
  - src/index/build/file-processor/relations.js:27-50
  - src/contracts/schemas/artifacts.js:318-334

### 9.4 Pipeline emits SymbolRef-based links
- Files to change/create:
  - src/index/type-inference-crossfile/pipeline.js (replace chunkByKey `${file}::${name}` at ~58-70; update callLinks at ~201-280)
  - src/index/type-inference-crossfile/symbols.js (or new resolver helpers)
  - src/index/tooling/* providers (clangd/pyright/sourcekit/typescript) keyed by file::name
- Call sites/line refs:
  - src/index/type-inference-crossfile/pipeline.js:58-70, 201-280, 286, 340
  - src/index/tooling/typescript-provider.js:308
  - src/index/tooling/clangd-provider.js:230
  - src/index/tooling/pyright-provider.js:281, 328
  - src/index/tooling/sourcekit-provider.js:198
- Gaps/conflicts:
  - Multiple providers split names by /::|\./ (see src/index/type-inference-crossfile/symbols.js:4-9); switching to SymbolRef requires consistent qualifiedName handling.

### 9.5 Symbol artifacts (symbols, symbol_occurrences, symbol_edges)
- Files to change/create:
  - New writers: src/index/build/artifacts/writers/symbols.js, symbol-occurrences.js, symbol-edges.js
  - src/index/build/artifacts.js (enqueue writers near file_relations at ~380)
  - src/shared/artifact-io/jsonl.js (required keys list)
  - src/contracts/schemas/artifacts.js (add schemas)
  - src/index/validate.js (strict validation + referential checks)
- Call sites/line refs:
  - src/index/build/artifacts.js:380-401
  - src/shared/artifact-io/jsonl.js:11-17
  - src/index/validate.js:76-95, 301-347

### 9.6 Graph relations migrate to chunkUid
- Files to change/create:
  - src/index/build/graphs.js (legacyKey + resolveChunkId at ~9-149)
  - tests/indexing/relations/graph-chunk-id.test.js (update expectations)
- Call sites/line refs:
  - src/index/build/graphs.js:9, 91-149
- Gaps/conflicts:
  - resolveChunkId currently uses chunkId fallback; Phase 8 must ensure metaV2.chunkUid is populated to avoid legacyKey reuse.

### 9.7 Map build identity updates
- Files to change/create:
  - src/map/build-map.js (consume chunkUid + symbolId)
  - src/map/build-map/symbols.js (buildSymbolId uses file::name at ~11-16)
  - src/map/build-map/edges.js (edge member keys at ~104)
  - src/map/build-map/filters.js (file::name parsing at ~30-31, 115-116, 189-192, 216-217)
- Call sites/line refs:
  - src/map/build-map/symbols.js:11-16
  - src/map/build-map/edges.js:104
  - src/map/build-map/filters.js:30-31, 115-116, 189-192, 216-217

### 9.8 Performance + determinism guardrails
- Files to change/create:
  - src/index/build/graphs.js (serializeGraph already sorts; keep stable ordering)
  - new tests under tests/determinism/ and tools/bench/
- Call sites/line refs:
  - src/index/build/graphs.js:45-68 (serializeGraph ordering)

### Associated specs reviewed (Phase 9)
- docs/phases/phase-9/identity-contracts.md
- docs/phases/phase-9/symbol-artifacts-and-pipeline.md
- docs/phases/phase-9/migration-and-backcompat.md
- docs/specs/identity-contract.md
- docs/specs/symbol-identity-and-symbolref.md
- docs/specs/symbol-artifacts.md

## Phase 9 addendum: dependencies, ordering, artifacts, tests, edge cases

### Cross-phase ordering (Phase 8 ↔ Phase 9)
- Identity primitives (`segmentUid`, `virtualPath`, `chunkUid`) **must already be complete from Phase 8** before any Phase 9 symbol/graph work starts.
- Phase 9.1 is verification-only: if identity primitives are missing or drifted, stop Phase 9 and complete Phase 8 identity tasks first.
- Identity tests (segmentUid/chunkUid/strict validation) must already be green from Phase 8; rerun only if identity code changes.

### 9.1 Dependencies and order of operations
- Dependencies:
  - segmentUid algorithm must land before chunkUid (needs segment text).
  - virtualPath and chunkUid helpers must exist before any graph/tooling joins.
- Order of operations:
  1) Compute segmentUid during segmentation (container text available).
  2) Build virtualPath and chunkUid during chunk assembly.
  3) Persist into metaV2 + chunk payload.
  4) Add strict validation for missing chunkUid.

### 9.1 Acceptance criteria + tests (lane)
- Identity tests run in Phase 8 (see Phase 8 addendum). Rerun only if identity code changes.

### 9.1 Edge cases and fallback behavior
- Missing segment text in cache hydrate: treat as cache miss and reprocess file.
- chunkUid collision: escalate context once, then append :ord<N> deterministically.
- Fail-closed: strict mode rejects any chunk missing chunkUid/segmentUid/virtualPath (no file::name fallback).

### 9.2 Dependencies and order of operations
- Dependencies:
  - 9.1 identity helpers must land before symbol identity helpers.
- Order of operations:
  1) Implement kindGroup normalization.
  2) Implement symbolKey/signatureKey/scopedId builders.
  3) Add SymbolRef envelope helpers.

### 9.2 Acceptance criteria + tests (lane)
- tests/indexing/identity/identity-symbolkey-scopedid.test.js (test:unit)
- tests/indexing/type-inference/symbolref-envelope.test.js (test:unit)

### 9.2 Edge cases and fallback behavior
- Missing qualifiedName: fall back to chunk.name; mark symbolKey as low confidence.
- Duplicate scopedId: deterministic ordinal suffix or strict-mode error (choose and document).

### 9.3 Dependencies and order of operations
- Dependencies:
  - import bindings must be extracted before resolver runs.
- Order of operations:
  1) Collect import bindings in relations extraction.
  2) Resolve relative imports to candidate files.
  3) Emit SymbolRef candidates with status=ambiguous when >1.

### 9.3 Acceptance criteria + tests (lane)
- tests/indexing/imports/import-resolver-relative.test.js (test:integration)
- tests/indexing/artifacts/symbols/symbol-edges-ambiguous.test.js (test:services)

### 9.3 Edge cases and fallback behavior
- Unresolved import: emit unresolved SymbolRef with candidates empty; keep edge.
- Multiple matches: status=ambiguous; do not pick winner.
- Fail-closed: if resolver cannot map to chunkUid candidates, mark unresolved; do not guess by name.

### 9.4 Dependencies and order of operations
- Dependencies:
  - 9.1 chunkUid and 9.2 symbol helpers must be present.
- Order of operations:
  1) Build chunkUid map.
  2) Replace file::name joins with chunkUid joins.
  3) Attach SymbolRef info to call/usage links.

### 9.4 Acceptance criteria + tests (lane)
- tests/integration/file-name-collision-no-wrong-join.test.js (test:integration)
- tests/indexing/artifacts/symbols/symbol-links-by-chunkuid.test.js (test:services)

### 9.4 Edge cases and fallback behavior
- Missing chunkUid: strict mode fails; non-strict logs and skips the link.
- Multiple candidates: preserve ambiguity in SymbolRef.
- Fail-closed: never backfill chunkUid joins from file::name; emit ambiguous/unresolved instead.

### 9.5 Artifact row fields (symbols.jsonl, symbol_occurrences.jsonl, symbol_edges.jsonl)
- symbols.jsonl required keys (SymbolRecordV1):
  - v, symbolKey, scopedId, symbolId, qualifiedName, kindGroup, file, virtualPath, chunkUid
  - optional: signatureKey, languageId, chunkId, containerName, source
- symbol_occurrences.jsonl required keys (SymbolOccurrenceV1):
  - v, host.file, host.chunkUid, role, ref (SymbolRefV1)
  - optional: meta.callerScopedId, meta.argMap
- symbol_edges.jsonl required keys (SymbolEdgeV1):
  - v, type, from.file, from.chunkUid, to (SymbolRefV1)
  - optional: confidence, reason, call.argMap
- Caps (set explicit defaults in schema/tests):
  - maxCandidates in SymbolRef (recommended: 25)
  - maxEvidence/snippet size (no raw snippets; use hashes)
  - maxRowBytes (recommended: 32768)

### 9.5 Acceptance criteria + tests (lane)
- tests/indexing/artifacts/symbols/symbol-artifacts-emission.test.js (test:services)
- tests/indexing/validate/symbol-integrity-strict.test.js (test:services)
- tests/indexing/artifacts/symbols/symbol-edges-ambiguous.test.js (test:services)

### 9.5 Edge cases and fallback behavior
- Duplicate scopedId: strict validation fails; non-strict appends deterministic ordinal.
- SymbolRef resolved but missing chunkUid: treat as unresolved and log.
- Fail-closed: if SymbolRef is resolved but missing chunkUid/scopedId, drop edge in strict mode.

### 9.6 Dependencies and order of operations
- Dependencies:
  - 9.1 chunkUid must land before graph_relations v2.
- Order of operations:
  1) Update graph node ids to chunkUid.
  2) Update edge targets to resolved chunkUid only.
  3) Keep legacyKey for diagnostics only.

### 9.6 Acceptance criteria + tests (lane)
- tests/indexing/relations/graph-relations-v2-chunkuid.test.js (test:integration)

### 9.6 Edge cases and fallback behavior
- Missing chunkUid in chunk_meta: strict mode fails; non-strict skips node.

### 9.7 Dependencies and order of operations
- Dependencies:
  - Graph relations v2 must be complete before map build joins.
- Order of operations:
  1) Join map entries by chunkUid.
  2) Fallback to chunkId only for diagnostics.

### 9.7 Acceptance criteria + tests (lane)
- tests/indexing/map/map-chunkuid-join.test.js (test:integration)

### 9.7 Edge cases and fallback behavior
- Multiple map entries for same chunkUid: keep deterministic ordering, dedupe by chunkUid.

### 9.8 Dependencies and order of operations
- Dependencies:
  - Determinism checks after all artifact emission.
- Order of operations:
  1) Run determinism tests (two builds).
  2) Verify collision handling is stable.

### 9.8 Acceptance criteria + tests (lane)
- tests/indexing/determinism/chunkuid-determinism.test.js (test:integration)
- tests/indexing/determinism/symbol-artifact-determinism.test.js (test:integration)

### 9.8 Edge cases and fallback behavior
- Large repos: enforce sharded emission; fail if memory cap exceeded.

## Fixtures list (Phase 9)

- tests/fixtures/identity/chunkuid-collision
- tests/fixtures/symbols/ambiguous-defs
- tests/fixtures/imports/relative-ambiguous
- tests/fixtures/graph/chunkuid-join

## Compat/migration checklist (Phase 9)

- Keep chunkId and segmentId in metaV2 for debug/back-compat only.
- Emit graph_relations v2 with chunkUid node ids; keep legacyKey for diagnostics only.
- Symbol artifacts are additive; do not remove legacy repo_map outputs.

## Artifacts contract appendix (Phase 9)

- symbols.jsonl
  - required keys: v, symbolKey, scopedId, symbolId, qualifiedName, kindGroup, file, virtualPath, chunkUid
  - optional keys: signatureKey, languageId, chunkId, containerName, source
  - caps: maxRowBytes 32768
- symbol_occurrences.jsonl
  - required keys: v, host.file, host.chunkUid, role, ref (SymbolRefV1)
  - optional keys: meta.callerScopedId, meta.argMap
- symbol_edges.jsonl
  - required keys: v, type, from.file, from.chunkUid, to (SymbolRefV1)
  - optional keys: confidence, reason, call.argMap
- graph_relations.json (v2)
  - required node ids: chunkUid
  - legacyKey allowed for diagnostics only

---


## Phase 10 - Interprocedural risk propagation + explainability artifacts

**Goal:** Add a deterministic, capped, explainable *interprocedural* risk propagation system for the **code** index mode that:
- Reuses existing **local** risk signals (`docmeta.risk` from `src/index/risk.js`).
- Reuses existing **cross-file inference** call resolution (`applyCrossFileInference`), specifically `callDetails[].targetChunkUid`.
- Emits **new artifacts**:
  - `risk_summaries*.jsonl` (+ shard meta)
  - `risk_flows*.jsonl` (+ shard meta)
  - `risk_interprocedural_stats.json`
- Adds a compact, low-bytes **`docmeta.risk.summary`** for each risk-relevant chunk (to support fast display/filtering without scanning JSONL).
- Provides a CLI to explain the flows in an index (`pairofcleats risk explain ...`).

---

### Source-of-truth decisions + conflicts resolved 

This phase touches multiple "specs" that are currently **not aligned** with the repo's implemented contracts. Implement the *best* functionality **and** remove ambiguity by making these explicit choices.

#### A) `call_sites.jsonl` schema: **CODE contract is authoritative**
- **Authoritative schema:** `src/contracts/schemas/artifacts.js` (`call_sites` entry schema)
- **Writer:** `src/index/build/artifacts/writers/call-sites.js`

The older spec `docs/specs/risk-flows-and-call-sites.md` contains a *different* `call_sites` row shape (e.g., `calleeName`, `argsSummary`, no `start/end offsets`, etc.). That spec is **out of date** for `call_sites`.

**Choice:** Do **not** change the repo's `call_sites` contract to match the spec.  
**Action:** Update the *documents/specs* to match the code contract (see **10.0 Doc merge**).

**Why:** `call_sites` already exists, is validated by contracts/tests, and is used for call graph evidence. The safest and most correct approach is to treat the implemented contract as the single source of truth and bring docs into alignment.

#### B) `callSiteId` algorithm: **keep the existing implementation; update newer docs**
- **Actual implementation:** `buildCallSiteId(...)` in `src/index/build/artifacts/writers/call-sites.js`
- **Doc (currently aligned with code):** `docs/specs/risk-callsite-id-and-stats.md`
- **Doc (currently NOT aligned with code):** `docs/new_docs/risk-callsite-id-and-stats_IMPROVED.md` (it proposes a different string-to-hash recipe)

**Choice:** Keep the current algorithm (colon-separated parts, no `callsite:v1` prefix).  
**Action:** Update the "IMPROVED" doc during merge (or explicitly label it as a future v2) so docs do not contradict working code.

**Why:** Changing `callSiteId` would silently invalidate any stored references and degrade determinism across builds. We can introduce a versioned v2 later **only** if we add an explicit `callSiteIdVersion`/`schemaVersion` surface.

#### C) Config surface conflict: "repo config contract" vs Phase 10 config keys
- `docs/config/contract.md` suggests a narrow public config surface.
- Phase 10's specs and roadmap require `indexing.riskInterprocedural`.

**Choice (best for engineering velocity + testability):** Treat `indexing.riskInterprocedural` as an **internal/advanced** indexing knob and explicitly preserve it through config load/normalization.  
**Action:** Update `tools/dict-utils/config.js` normalization to keep `indexing.riskInterprocedural` (and any prerequisite knobs used by runtime gating), and update docs so the contract vs internal knobs are clearly delineated.

**Why:** Interprocedural risk is *expensive* and must be opt-in. The least invasive, most explicit opt-in is a config knob. If the product wants a narrower public contract later, it can gate exposure without deleting the internal setting.

---

## 10.0 Documentation merge + canonical spec cleanup (FOUNDATION - do first)

> **Objective:** Eliminate spec drift *before* implementation.

### 10.0.1 Merge/replace outdated specs with reconciled versions
Files involved (read all, then produce a merged canonical set):

- Canonical targets (should live under `docs/specs/`):
  - [x] `docs/specs/risk-interprocedural-config.md`
  - [x] `docs/specs/risk-summaries.md`
  - [x] `docs/specs/risk-flows-and-call-sites.md`
  - [x] `docs/specs/risk-callsite-id-and-stats.md`
  - [x] `docs/specs/risk-interprocedural-stats.md` (currently placeholder)

- Sources to merge in (from `docs/new_docs/`):
  - [x] `spec_risk-interprocedural-config_IMPROVED.md`
  - [x] `spec_risk-summaries_IMPROVED.md`
  - [x] `spec_risk-flows-and-call-sites_RECONCILED.md`
  - [x] `risk-callsite-id-and-stats_IMPROVED.md`
  - [x] `interprocedural-state-and-pipeline_DRAFT.md`

**Tasks (required, no ambiguity):**
- [x] Merge canonical specs in `docs/specs/` using the sources above (see Doc merge checklist at end of Phase 10).
- [x] Update the **`call_sites` schema section** in `risk-flows-and-call-sites.md` to explicitly say:
  - [x] Call sites are the existing artifact contract in `src/contracts/schemas/artifacts.js`.
  - [x] For interprocedural risk, we only require a subset of fields (list them), but the artifact may contain superset fields.
- [x] Ensure the **`callSiteId` algorithm** section matches `buildCallSiteId` in `call-sites.js` (use `calleeRaw`, not `calleeName`).
- [x] Reconcile **risk summaries schema**: incorporate stronger evidence shape (start/end line+col) and keep truncation/caps guidance. Resolve any mismatched field names (see 10.3 for the implemented schema).
- [x] Reconcile **risk flows schema**: keep the roadmap's detailed schema (source+sink endpoints, path with `chunkUids` + `callSiteIdsByStep`, confidence, notes). Update any new_docs schema to match.
- [x] Make **stats schema** explicit about what callSitesEmitted means:
  - [x] Define as unique callSiteIds referenced by emitted `risk_flows` (not total rows in call_sites).
- [x] Remove outdated statements (e.g., docs/config/schema.json doesn't include indexing.).

### 10.0.2 Add Spec status table inside Phase 10 docs
Create a small table (in whichever canonical spec is most appropriate, or at the top of this Phase 10 section) showing:

- [x] spec file -> implemented-by code module -> status (implemented / draft / planned)
- [x] version numbers (schemaVersion) and compatibility notes

**Tasks**
- [x] Add the status table to the canonical spec (or Phase 10 header).
- [x] Include schemaVersion and a compatibility note: **no back-compat; old indexes should error with a rebuild instruction**.


### 10.0.3 Archive deprecated specs + codify the process (MANDATORY)

This implements the repo-wide rule:

> Deprecated/replaced spec documents must be moved to `docs/archived/` (never deleted), and the process must be documented in `AGENTS.md`.

**Tasks**
- [x] Create `docs/archived/README.md` explaining:
  - [x] what belongs here,
  - [x] how to name/archive files,
  - [x] how to reference the replacement spec.
- [x] Create `docs/archived/phase-10/` (or `docs/archived/specs/phase-10/`) as the destination for Phase 10 spec deprecations.
- [x] After the merges in **10.0.1** are complete:
  - [x] Move the *staging* source docs from `docs/new_docs/` that are no longer meant to be edited:
    - [x] `docs/new_docs/spec_risk-interprocedural-config_IMPROVED.md`
    - [x] `docs/new_docs/spec_risk-summaries_IMPROVED.md`
    - [x] `docs/new_docs/spec_risk-flows-and-call-sites_RECONCILED.md`
    - [x] `docs/new_docs/risk-callsite-id-and-stats_IMPROVED.md`
    - [x] `docs/new_docs/interprocedural-state-and-pipeline_DRAFT.md`
    - [x] Destination: `docs/archived/phase-10/` (keep filenames intact).
  - [x] Add a short "DEPRECATED" header block to each moved file that points to the canonical replacement(s) in `docs/specs/...`.
- [x] Update **`AGENTS.md`** with a "Spec deprecation + archival process" section:
  - [x] When to archive vs update-in-place.
  - [x] Required metadata to include in the archived file header (replacement link + date/PR).
  - [x] A reminder that contracts (`src/contracts/**`) remain authoritative and specs must track them.

**Why this is required**
- `docs/new_docs/` is a staging area; leaving parallel variants creates drift and confusion.
- `docs/archived/` preserves context without keeping multiple "active" specs.


---

## 10.1 Config wiring + runtime gating (FOUNDATION - do before any propagation code)

### 10.1.0 Authoritative config keys (single source of truth)
**These keys are canonical. Use these exact names everywhere in Phase 10 and specs.**

**Tasks**
- [x] Document the authoritative keys list in Phase 10 and in `docs/specs/risk-interprocedural-config.md`.
- [x] Update any downstream task/test references to use these exact key names (no aliases).

**Authoritative keys**
- `indexing.riskInterprocedural.enabled`
- `indexing.riskInterprocedural.summaryOnly`
- `indexing.riskInterprocedural.strictness`
- `indexing.riskInterprocedural.sanitizerPolicy`
- `indexing.riskInterprocedural.emitArtifacts`
- `indexing.riskInterprocedural.caps.maxDepth`
- `indexing.riskInterprocedural.caps.maxPathsPerPair`
- `indexing.riskInterprocedural.caps.maxTotalFlows`
- `indexing.riskInterprocedural.caps.maxCallSitesPerEdge`
- `indexing.riskInterprocedural.caps.maxEdgeExpansions`
- `indexing.riskInterprocedural.caps.maxMs`

### 10.1.1 Add risk interprocedural config normalizer
**New file:** `src/index/risk-interprocedural/config.js`

Export:
- [x] `normalizeRiskInterproceduralConfig(raw, { mode })`

Inputs:
- [x] `raw` comes from `runtime.indexingConfig.riskInterprocedural` (or `{}`).

Output (**effective config**; use these defaults unless the merged spec dictates otherwise):
```js
{
  enabled: false,                 // hard gate
  summaryOnly: false,             // if true: summaries + compact docmeta only, no propagation, no risk_flows
  strictness: 'conservative',     // 'conservative' | 'argAware'
  sanitizerPolicy: 'terminate',   // 'terminate' | 'weaken'
  emitArtifacts: 'jsonl',         // 'none' | 'jsonl'  (accept legacy aliases: 'off' -> 'none')
  caps: {
    maxDepth: 4,
    maxPathsPerPair: 3,
    maxTotalFlows: 5000,
    maxCallSitesPerEdge: 3,
    maxEdgeExpansions: 200000,    // global cap on edge traversals (prevents explosion even if flows are capped)
    maxMs: 2500                   // wall clock budget; null disables
  }
}
```

**Normalization rules (MUST be deterministic):**
- [x] `emitArtifacts`: accept `off|none` -> `none`, `jsonl` -> `jsonl`. Anything else -> default `jsonl`.
- [x] `strictness`: unknown -> `conservative`
- [x] `sanitizerPolicy`: unknown -> `terminate`
- [x] numeric caps:
  - [x] coerce to integers
  - [x] clamp to sane ranges (define in code):
    - [x] `maxDepth`: 1..20
    - [x] `maxPathsPerPair`: 1..50
    - [x] `maxTotalFlows`: 0..1_000_000
    - [x] `maxCallSitesPerEdge`: 1..50
    - [x] `maxEdgeExpansions`: 10_000..10_000_000
    - [x] `maxMs`: null OR 10..60_000
- [x] `summaryOnly=true` forces "no flows" even if other caps allow.
- [x] If `enabled=false`, downstream code must treat the entire feature as disabled and avoid any heavy compute.

### 10.1.2 Preserve config keys through repo config normalization
**File:** `tools/dict-utils/config.js`  
Function: `normalizeUserConfig(config)`

Today this function intentionally narrows the public config surface. For Phase 10 to be operable and testable, we must preserve:

- `config.indexing.riskInterprocedural` (entire nested object)

**Implementation requirement:**
- [x] Add `riskInterprocedural: indexingConfig.riskInterprocedural || undefined` under the returned `indexing` object.
- [x] Keep it **as-is** (no normalization here); normalization is done in `src/index/risk-interprocedural/config.js`.

Also preserve any prerequisite knobs *already used by runtime* and referenced by specs (only if they are currently being dropped):
- [x] `indexing.riskAnalysis` (if you want it configurable)
- [x] `indexing.riskAnalysisCrossFile`
- [x] `indexing.typeInferenceCrossFile`

If the project intentionally keeps these non-configurable, document that clearly in the merged specs and do not add them.

### 10.1.3 Wire effective config into build runtime
**File:** `src/index/build/runtime/runtime.js`

Tasks:
- [x] Import `normalizeRiskInterproceduralConfig`.
- [x] Compute:
  - [x] `const riskInterproceduralConfig = normalizeRiskInterproceduralConfig(indexingConfig.riskInterprocedural, { mode });`
- [x] Add to returned runtime:
  - [x] `riskInterproceduralConfig`
  - [x] `riskInterproceduralEnabled` (boolean)
    - [x] `true` iff:
      - [x] `mode === 'code'`
      - [x] `riskAnalysisEnabled === true` (Phase 10 depends on local signals)
      - [x] `riskInterproceduralConfig.enabled === true`
- [x] Add gating to `analysisPolicy`:
  - [x] include `analysisPolicy.risk.interprocedural = riskInterproceduralEnabled`
  - [x] include `analysisPolicy.risk.interproceduralSummaryOnly = riskInterproceduralConfig.summaryOnly`

### 10.1.4 Ensure cross-file inference runs when riskInterprocedural is enabled
**File:** `src/index/build/indexer/steps/relations.js`

Current logic:
- `crossFileEnabled = typeInferenceCrossFileEnabled || riskAnalysisCrossFileEnabled`

Update to:
- [x] `crossFileEnabled = typeInferenceCrossFileEnabled || riskAnalysisCrossFileEnabled || runtime.riskInterproceduralEnabled`

**Important constraint:** Enabling cross-file inference does **not** have to enable "type inference output artifacts"; it only needs to run resolution so `callDetails[].targetChunkUid` exists.

So, keep:
- [x] `enableTypeInference: typeInferenceCrossFileEnabled`
- [x] `enableRiskCorrelation: riskAnalysisCrossFileEnabled`
- [x] Do NOT implicitly force these true just because riskInterprocedural is enabled.

### 10.1.5 Incremental build signature must include riskInterprocedural effective config
**File:** `src/index/build/indexer/signatures.js`

Add `riskInterproceduralConfig` (or a stable subset) to the signature components so incremental rebuilds invalidate when this changes.

- [x] Use a stable JSON stringify (or hash) of the *normalized effective config* object.
- [x] Do **not** include transient fields like timers.

### 10.1.6 Index state output must record whether this feature ran
**File:** `src/index/build/indexer/steps/write.js`

In `index_state.json`, add:
```json
"riskInterprocedural": {
  "enabled": true,
  "summaryOnly": false,
  "emitArtifacts": "jsonl"
}
```

- [x] Implement this in `index_state.json` (exact nesting flexible, but must be deterministic and allow tooling to quickly see if risk flows are expected).

### 10.1.7 Tests for config and gating
Add:
- [x] `tests/indexing/risk/interprocedural/config-normalization.test.js`
  - [x] unit test `normalizeRiskInterproceduralConfig`
  - [x] include edge cases: alias values, bad types, clamp behavior
- [x] `tests/indexing/risk/interprocedural/runtime-gating.test.js`
  - [x] create runtime via `createBuildRuntime` with mode=`code` and mode=`prose`
  - [x] assert `riskInterproceduralEnabled` toggles correctly
  - [x] assert crossFileEnabled includes it (mock `runCrossFileInference` decision logic)

---

## 10.2 Param name stabilization for arg-aware mode (FOUNDATION)

> Arg-aware propagation requires stable "callee param names" to map tainted args -> callee identifiers.

### 10.2.0 Map data flow entry points + consumers (required)
**Tasks**
- [x] Identify parsing entry points:
  - [x] `src/lang/javascript/relations.js` (param extraction in `buildCodeRelations`)
  - [x] `src/index/type-inference-crossfile/extract.js` (`extractParamTypes`)
  - [x] `src/index/type-inference-crossfile/pipeline.js` (`applyCrossFileInference`)
  - [x] `src/index/build/indexer/steps/relations.js` (`runCrossFileInference`)
- [x] Identify consumers:
  - [x] `src/index/risk-interprocedural/summaries.js`
  - [x] `src/index/risk-interprocedural/engine.js`
  - [x] `src/index/build/artifacts/writers/risk-interprocedural.js`
  - [x] `src/index/build/piece-assembly.js`
  - [x] `src/index/validate/risk-interprocedural.js`
- [x] Cross-reference these entry points/consumers in 10.5 (engine) and 10.6 (writers/manifest) to keep data flow explicit.

### 10.2.1 Fix JS param extraction to be stable + predictable
**File:** `src/lang/javascript/relations.js` (anchors referenced in original roadmap: around callLinks generation and docmeta param extraction)

Current risk:
- `node.params` can contain patterns (destructuring, defaults) that stringify inconsistently.

Required changes:
- [x] When building `docmeta.params` (or an adjacent structured field), produce **paramNames** array:
  - [x] For `Identifier` param: use name directly.
  - [x] For `AssignmentPattern` (`x=1`): use left identifier name if possible.
  - [x] For `RestElement` (`...rest`): use argument identifier name if possible.
  - [x] For patterns (`ObjectPattern`, `ArrayPattern`), use stable placeholders:
    - [x] `"arg0"`, `"arg1"`, ... (based on param index)
- [x] Ensure `paramNames` is:
  - [x] stable order
  - [x] capped (e.g., 16)
- [x] Preserve the existing `docmeta.signature` format (do not break search behavior).

**Cross-file inference dependency:**  
`applyCrossFileInference` populates `callLinks.paramNames` via `extractParamTypes`. That function must rely on stable `docmeta.params` or a new stable `docmeta.paramNames`. If needed:

- [x] Update `src/index/type-inference-crossfile/extract.js` (function `extractParamTypes`) to prefer:
  - [x] `docmeta.paramNames` if present
  - [x] else fall back to `docmeta.params`

### 10.2.2 Add tests for JS param normalization
Add:
- [x] `tests/lang/javascript/javascript-paramnames.test.js`

- [x] Fixture function:
```js
function f({a,b}, x=1, ...rest) {}
```

Expect:
- [x] `docmeta.paramNames` equals `["arg0","x","rest"]`
- [x] `callLinks.paramNames` for calls to `f` are consistent.

---

## 10.3 Risk summaries (artifact + compact docmeta)

> Summaries are the "input facts" for propagation and the primary explainability artifact even when propagation is disabled or times out.

### 10.3.1 Define the *final* summary row schema (implement exactly)
After doc merge (10.0), Implement this as the actual row contract (`schemaVersion: 1`):
- [x] Implement this schema in `src/contracts/schemas/artifacts.js` and `docs/specs/risk-summaries.md`.

**Artifact:** `risk_summaries.jsonl` (sharded)

**Row (RiskSummaryRowV1):**
```ts
{
  schemaVersion: 1,

  // identity
  chunkUid: string,
  file: string,
  languageId: string|null,

  // optional symbol context (for debugging / UI; must not bloat)
  symbol: {
    name: string|null,
    kind: string|null,
    signature: string|null
  },

  // signals (bounded + deterministic)
  signals: {
    sources: RiskSignalSummary[],
    sinks: RiskSignalSummary[],
    sanitizers: RiskSignalSummary[],
    localFlows: RiskLocalFlowSummary[]
  },

  // optional: local taint hints (helps arg-aware)
  taintHints?: {
    taintedIdentifiers: string[]
  },

  totals: {
    sources: number,
    sinks: number,
    sanitizers: number,
    localFlows: number
  },

  truncated: {
    sources: boolean,
    sinks: boolean,
    sanitizers: boolean,
    localFlows: boolean,
    evidence: boolean
  }
}
```

**RiskSignalSummary:**
```ts
{
  ruleId: string,
  ruleName: string,
  ruleType: "source"|"sink"|"sanitizer",
  category: string|null,
  severity: string|null,        // only meaningful for sinks
  confidence: number|null,      // 0..1
  tags: string[],               // bounded
  evidence: EvidenceRef[]       // bounded
}
```

**EvidenceRef:**
```ts
{
  file: string,
  startLine: number,
  startCol: number,
  endLine: number|null,
  endCol: number|null,
  snippetHash: string|null      // "sha1:<hex>" or null
}
```

**RiskLocalFlowSummary (resolve ambiguity explicitly):**
Because local flows involve a *pair* of rules, store both IDs:
```ts
{
  sourceRuleId: string,
  sinkRuleId: string,
  category: string|null,        // usually from sink
  severity: string|null,        // usually from sink
  confidence: number|null,      // derived from source/sink confidences
  evidence: EvidenceRef[]
}
```

This removes the ambiguity present in `spec_risk-summaries_IMPROVED.md` where flows had a single `ruleId`.

### 10.3.2 Implement summary builder
**New file:** `src/index/risk-interprocedural/summaries.js`

Exports:
- [x] `buildRiskSummaries({ chunks, runtime, mode, log })`

Behavior:
- [x] Only run when:
  - [x] `mode === 'code'`
  - [x] `runtime.riskInterproceduralEnabled === true` OR `runtime.riskInterproceduralConfig.emitArtifacts === 'jsonl'`
  - [x] If disabled entirely, skip.
- [x] For each chunk in `state.chunks`:
  - [x] Read `chunk.docmeta?.risk` (produced by `src/index/risk.js`).
  - [x] If no risk or no signals, skip row emission.
- [x] Convert `docmeta.risk.sources/sinks/sanitizers` into `RiskSignalSummary[]`:
  - [x] Deterministic ordering:
    - [x] primary: `severity` (high->medium->low->null) for sinks only
    - [x] then `ruleId`
    - [x] then earliest evidence location
  - [x] Caps:
    - [x] `maxSignalsPerKind = 50`
    - [x] `maxEvidencePerSignal = 5`
    - [x] `maxTagsPerSignal = 10`
- [x] Convert `docmeta.risk.flows` into `RiskLocalFlowSummary[]`:
  - [x] Derive `sourceRuleId`/`sinkRuleId` from existing detector output:
    - [x] detector: `flow.ruleIds = [sourceRuleId, sinkRuleId]`
  - [x] Deterministic order:
    - [x] `sourceRuleId`, then `sinkRuleId`, then evidence location
  - [x] Caps:
    - [x] `maxLocalFlows = 50`
- [x] Evidence normalization:
  - [x] Input evidence from detector is `{ line, column, excerpt }`
  - [x] Map:
    - [x] `startLine = line`
    - [x] `startCol = column`
    - [x] `endLine = line` (or null if you prefer; pick one and be consistent)
    - [x] `endCol = column`
    - [x] `snippetHash = sha1(normalizeWhitespace(excerpt))` or null if excerpt missing/empty after normalize
  - [x] Use `sha1` from `src/shared/hash.js`
- [x] Produce `totals` and `truncated` flags:
  - [x] `totals.*` counts BEFORE truncation
  - [x] `truncated.*` indicates truncation actually occurred

### 10.3.3 Attach compact summary to `docmeta.risk.summary`
**Output field:** `chunk.docmeta.risk.summary`

Compact schema (must stay small; no evidence arrays):
```ts
{
  sources: { count: number },
  sinks: { count: number, maxSeverity: string|null },
  sanitizers: { count: number },
  localFlows: { count: number },

  topCategories: string[],   // max 5
  topTags: string[],         // max 8

  interprocedural: {
    enabled: boolean,
    summaryOnly: boolean
  }
}
```

Rules:
- [x] Populate only if chunk has at least one local risk signal or local flow.
- [x] Values must be deterministic (sort ties lexicographically).
- [x] This compact summary is what UIs and CLI can read quickly without parsing JSONL.

### 10.3.4 Export `taintHints` from local risk detector
**File:** `src/index/risk.js`

Enhancement:
- [x] The local risk detector already tracks a `taint` map internally for assignment propagation.
- [x] Add a bounded list:
  - [x] `taintHints: { taintedIdentifiers: string[] }`
  - [x] Sort + cap (e.g., 50)
- [x] Attach to `docmeta.risk`.

This improves arg-aware propagation but is not required for correctness if `strictness=conservative`.

### 10.3.5 Per-row size cap enforcement (required)
Both summary rows and compact summary additions must obey size limits.

**Hard limit:** `<= 32 KiB` per JSONL row.

Implement row trimming in `buildRiskSummaries` (or in the writer) with deterministic steps:
- [x] Drop `tags` arrays from all signals.
- [x] Reduce evidence per signal to 1.
- [x] Drop all evidence arrays.
- [x] If still too large: drop the entire summary row and record in stats (`summariesDroppedBySize++`).

### 10.3.6 Tests for summaries
Add:
- [x] `tests/indexing/risk/interprocedural/summaries-schema.test.js`
  - [x] Build a fixture index; load `risk_summaries.jsonl`; schema-validate; verify expected counts.
- [x] `tests/indexing/risk/interprocedural/summaries-determinism.test.js`
  - [x] Run summary build twice on same fixture (same runtime), assert identical JSONL output bytes.
- [x] `tests/indexing/risk/interprocedural/summaries-truncation.test.js`
  - [x] Construct an artificial chunk with huge tags/evidence, assert trimming steps fire and flags/stats reflect.

---

## 10.4 Shared callsite utilities (FOUNDATION)

### 10.4.1 Factor callSiteId algorithm into a shared helper
**Goal:** Risk flows must reference callSiteIds that match the `call_sites` writer exactly.

**New file (recommended):** `src/index/callsite-id.js`

Export:
- [x] `buildCallSiteId({ file, startLine, startCol, endLine, endCol, calleeRaw })`

Implementation:
- [x] Move (or copy exactly) the logic from `src/index/build/artifacts/writers/call-sites.js`.
- [x] Update call-sites writer to import it (so there is only one implementation).

### 10.4.2 Define edge-key and call site sampling helpers
**New file:** `src/index/risk-interprocedural/edges.js`

Exports:
- [x] `edgeKey(callerUid, calleeUid) => string` (format: `"${callerUid}->${calleeUid}"`)
- [x] `sortCallDetailsForSampling(a, b)` (deterministic comparator)
- [x] `sampleCallSitesForEdge(callDetails, { maxCallSitesPerEdge }) => CallSiteSample[]`

Where `CallSiteSample` includes:
```ts
{
  callSiteId: string,
  args: string[]|null
}
```

Sampling requirements:
- [x] Build list from caller chunk's `codeRelations.callDetails`, filtering:
  - [x] `detail.targetChunkUid === calleeUid`
- [x] Sort by:
  - [x] `detail.file` (if present, else caller chunk file)
  - [x] `detail.startLine`, `detail.startCol`, `detail.endLine`, `detail.endCol`
  - [x] `detail.calleeNormalized` then `detail.calleeRaw`
  - [x] `callSiteId` (as tie-breaker)
- [x] Take first `N`.

**Important:** Sampling is used only for *flow evidence*, not for call graph completeness.

### 10.4.3 Add local pointer hash helper (callsite IDs + graph joins)
**File (likely):** `src/index/build/shared/graph/graph-store.js`

**Goal:** Ensure callsite IDs and graph joins use a shared, stable hash for local pointers so tests can target it.

**Tasks**
- [x] Add a helper that takes callsite-local inputs and produces a stable pointer hash (inputs must match callSiteId formation).
- [x] Document how callsite IDs are formed and reused in:
  - [x] 10.5 propagation (`risk-interprocedural/engine.js`)
  - [x] 10.6 writer/manifest plumbing (`risk-interprocedural.js`, piece assembly)
- [x] Expose the helper for tests (so sampling + joins can be verified deterministically).

### 10.4.4 Tests for callsite helpers
Add:
- [x] `tests/indexing/risk/interprocedural/callsite-id.test.js`
  - [x] Ensure the shared helper matches the writer's output on representative inputs.
- [x] `tests/indexing/risk/interprocedural/callsite-sampling.test.js`
  - [x] Given an array of mocked callDetails, assert deterministic ordering and stable sampling.
- [x] Add a focused test for the local pointer hash helper (inputs -> stable hash).

---

## 10.5 Interprocedural propagation -> risk_flows

> Propagation enumerates bounded call paths from source signals to sink signals.

### 10.5.1 Define the *final* flow row schema (implement exactly)
**Artifact:** `risk_flows.jsonl` (sharded)

- [x] Implement this schema in `src/contracts/schemas/artifacts.js` and `docs/specs/risk-flows-and-call-sites.md`.

Row `RiskFlowRowV1`:
```ts
{
  schemaVersion: 1,
  flowId: string,  // "sha1:<hex>"

  source: {
    chunkUid: string,
    ruleId: string,
    ruleName: string,
    ruleType: "source",
    category: string|null,
    severity: null,
    confidence: number|null
  },

  sink: {
    chunkUid: string,
    ruleId: string,
    ruleName: string,
    ruleType: "sink",
    category: string|null,
    severity: string|null,
    confidence: number|null
  },

  path: {
    chunkUids: string[],             // length >= 2
    callSiteIdsByStep: string[][]    // length == chunkUids.length - 1
  },

  confidence: number,                // computed final confidence 0..1

  notes: {
    strictness: "conservative"|"argAware",
    sanitizerPolicy: "terminate"|"weaken",
    hopCount: number,
    sanitizerBarriersHit: number,
    capsHit: string[]                // e.g., ["maxDepth","maxPathsPerPair"]
  }
}
```

**Call sites (existing artifact; do not break)**
- [x] Treat `call_sites` as a superset artifact; risk flows only consume a subset of fields.
- [x] Keep `call_sites` contract aligned to `src/contracts/schemas/artifacts.js` (no schema changes).
- [x] Ensure callSiteIds used here are produced by the shared helper from 10.4.1.
- [x] Document the subset fields consumed by propagation in `docs/specs/risk-flows-and-call-sites.md`.
- [x] Touchpoints:
  - [x] `src/index/build/artifacts/writers/call-sites.js` (writer + callSiteId)
  - [x] `src/contracts/schemas/artifacts.js` (contract authority)

### 10.5.2 Implement propagation engine
**New file:** `src/index/risk-interprocedural/engine.js`

Export:
- [x] `computeInterproceduralRisk({ chunks, summariesByChunkUid, runtime, log })`

Return:
```ts
{
  status: "ok" | "timed_out" | "disabled",
  summaryRows: RiskSummaryRowV1[],
  flowRows: RiskFlowRowV1[],
  stats: RiskInterproceduralStatsV1,
  // for referential checks / writers
  callSiteIdsReferenced: Set<string>
}
```

### 10.5.3 Graph inputs and how to build them (no searching required)
Inputs come from the existing indexing pipeline:

- `chunk.codeRelations.callDetails[]`
  - produced by language relations collectors (e.g., `src/lang/javascript/relations.js`)
  - enriched by cross-file inference (`applyCrossFileInference`) with `detail.targetChunkUid`

- `chunk.docmeta.risk.*`
  - produced by `src/index/risk.js`

The engine must **not** require reading artifacts from disk; it runs during build.
- [x] Enforce in-code: do not read artifacts from disk inside the propagation engine (use in-memory build state only).
- [x] Cross-reference 10.2.0 entry points/consumers for paramNames flow into this section.

### 10.5.4 Deterministic traversal algorithm (BFS)
Implement BFS rooted at each `(sourceChunkUid, sourceRuleId)`:

**Root ordering:**
- [x] Sort roots by:
  - [x] `sourceChunkUid`
  - [x] `sourceRuleId`

**Queue item ("state") shape:**
```ts
{
  chunkUid: string,
  rootSource: { chunkUid: string, ruleId: string },
  pathChunkUids: string[],             // from root to current
  callSiteIdsByStep: string[][],       // parallel to edges in path
  depth: number,                       // edges traversed so far
  sanitizerBarriersHit: number,
  taintSetKey: string|null             // only used for argAware
}
```

**Visited key (per spec; include depth):**
- [x] `visitedKey = `${rootSource.chunkUid}|${rootSource.ruleId}|${chunkUid}|${taintSetKey||""}|${depth}``

This is more permissive than typical BFS; it matches the intended "allow revisiting at deeper depth" behavior.

**Expansion order:**
- [x] When expanding a node:
  - [x] Get outgoing resolved callees from callDetails (or callLinks) and sort `calleeUid` lexicographically.
  - [x] For each callee, sample callSiteIds for the edge deterministically (10.4.2).
  - [x] Enqueue callee states in that sorted order.

### 10.5.5 Traversal strictness modes
#### conservative
- [x] Treat every resolved edge as traversable.
- [x] No taint tracking required.
- [x] `taintSetKey = null` for visited key.

#### argAware
An edge (caller->callee) is traversable only if at least one call-site argument is tainted.

**Taint sources (caller side):**
- [x] `callerSummary.taintHints.taintedIdentifiers` (if present)
- [x] Regex match against source rule patterns:
  - [x] Use compiled regexes for *source rules* from runtime's risk rules (`runtime.riskConfig`)
  - [x] Match per-argument string with identifier boundary rules:
    - [x] `argText` is the string from `callDetails.args[]`
    - [x] Consider an argument tainted if:
      - [x] It contains any tainted identifier as a whole token, OR
      - [x] It matches a source rule regex pattern

**Mapping taint into callee:**
- [x] Determine callee param names:
  - [x] Prefer `callLinks.paramNames` for that callee edge if available
  - [x] Else prefer callee chunk's `docmeta.paramNames` (from 10.2)
  - [x] Else: no mapping possible; treat traversal as conservative for that edge *only if* a tainted arg exists (still require tainted arg)
- [x] If argument index `i` is tainted and `paramNames[i]` exists:
  - [x] add `paramNames[i]` to callee taint set
- [x] Always union in callee's own `taintHints.taintedIdentifiers` (if present).

**Canonical taintSetKey:**
- [x] Sort tainted identifiers, cap to 16, join with `,`
- [x] Use this for visited key and determinism.

### 10.5.6 Sanitizer policy
A "barrier chunk" is any chunk that has `signals.sanitizers.length > 0` in its summary.

- `terminate`:
  - [x] You may still emit flows that *end at this chunk* (if it contains sinks).
  - [x] Do not expand outgoing edges from this chunk.
- `weaken`:
  - [x] Continue expansion.
  - [x] Increment `sanitizerBarriersHit` counter for notes and confidence penalty.

### 10.5.7 Flow emission rules
While BFS is running:
- [x] When visiting a chunk that has sinks (`signals.sinks.length > 0`):
  - [x] For each sink signal (sorted by severity desc then ruleId):
    - [x] Emit a flow row from root source -> this sink **unless**:
      - [x] `sinkChunkUid === sourceChunkUid` (no intra-chunk flows)
      - [x] caps would be exceeded

**Per-(source,sink) path cap:**
- [x] Maintain counter keyed by:
  - [x] `${sourceChunkUid}|${sourceRuleId}|${sinkChunkUid}|${sinkRuleId}`
- [x] Do not emit more than `maxPathsPerPair`.

### 10.5.8 Caps + timeout behavior (must be explicit)
Apply caps in this order (deterministic and reflected in stats):

- [x] **Timeout** (`maxMs`):
  - [x] Start timer before any propagation.
  - [x] If exceeded:
    - [x] set status=`timed_out`
    - [x] emit **zero** flow rows
    - [x] still emit summaries (already built)
- [x] **maxEdgeExpansions**:
  - [x] increment on each edge expansion attempt
  - [x] if exceeded: stop traversal and set `capsHit += ["maxEdgeExpansions"]`
- [x] **maxDepth**:
  - [x] do not expand states with `depth >= maxDepth`
- [x] **maxPathsPerPair**:
  - [x] per key cap described above
- [x] **maxTotalFlows**:
  - [x] stop emitting once reached; set `capsHit += ["maxTotalFlows"]`

### 10.5.9 Confidence scoring (implement exactly)
For each emitted flow:
- [x] `C_source = sourceSignal.confidence ?? 0.5`
- [x] `C_sink = sinkSignal.confidence ?? 0.5`
- [x] `base = 0.1 + 0.9 * C_source * C_sink`
- [x] `hopCount = chunkUids.length - 1`
- [x] `hopDecay = 0.85 ** Math.max(0, hopCount - 1)`
- [x] `sanitizerPenalty = sanitizerPolicy==="weaken" ? (0.5 ** sanitizerBarriersHit) : 1.0`
- [x] `final = clamp(base * hopDecay * sanitizerPenalty, 0, 1)`

### 10.5.10 Per-row size cap enforcement (required)
**Hard limit:** `<= 32 KiB` per JSONL row.

Deterministic trimming for flows:
- [x] Reduce each `callSiteIdsByStep[i]` to at most 1 id.
- [x] If still too large, replace `callSiteIdsByStep` with empty arrays (correct length).
- [x] If still too large, drop the row and record in stats.

### 10.5.11 Tests for propagation
Add fixtures + tests:

- [x] `tests/fixtures/risk-interprocedural/js-simple/`
  - [x] `index.js` contains:
    - [x] `function handle(req){ const cmd=req.body; return run(build(cmd)); }`
    - [x] `function build(x){ return x; }`
    - [x] `function run(cmd){ eval(cmd); }`
  - [x] Ensure:
    - [x] source rule `source.req.body` fires in `handle`
    - [x] sink rule `sink.eval` fires in `run`
    - [x] call chain resolved: handle->build->run

- [x] `tests/indexing/risk/interprocedural/flows-conservative.test.js`
  - [x] enable riskInterprocedural (conservative)
  - [x] assert at least 1 flow:
    - [x] `path.chunkUids.length === 3`
    - [x] `callSiteIdsByStep.length === 2`
    - [x] `notes.hopCount === 2`
    - [x] `sink.ruleId === "sink.eval"` (or the actual rule id)
- [x] `tests/indexing/risk/interprocedural/flows-argaware-negative.test.js`
  - [x] modify fixture so tainted value is NOT passed (e.g., `build("constant")`)
  - [x] argAware should emit 0 flows
- [x] `tests/indexing/risk/interprocedural/flows-sanitizer-policy.test.js`
  - [x] add sanitizer call in middle function (`escape(cmd)`)
  - [x] terminate: no flows beyond sanitizer
  - [x] weaken: flow exists but confidence reduced and `sanitizerBarriersHit>0`
- [x] `tests/indexing/risk/interprocedural/flows-timeout.test.js`
  - [x] set `maxMs=1` and create a fixture with branching call graph
  - [x] expect status `timed_out` and `risk_flows` empty

---

## 10.6 Artifact writing + contracts + manifest integration

### 10.6.1 Add contracts for new artifacts
**File:** `src/contracts/schemas/artifacts.js`

Add schemas for:
- [x] `risk_summaries` (jsonl)
- [x] `risk_flows` (jsonl)
- [x] `risk_interprocedural_stats` (json)

Also add meta schemas:
- [x] `risk_summaries_meta` (shard meta)
- [x] `risk_flows_meta`

Update:
- [x] `src/contracts/registry.js` (schema registry + schema hash)

**Risk interprocedural stats schema (canonical)**
- [x] Update `docs/specs/risk-interprocedural-stats.md` to match this schema (no appendix copy).
- [x] Required counters (explicit semantics):
  - [x] `flowsEmitted`: number of risk flow records written
  - [x] `risksWithFlows`: count of riskIds that emitted >= 1 flow
  - [x] `uniqueCallSitesReferenced`: count of unique callSiteIds referenced by emitted `risk_flows`
  - [x] `callSiteSampling`: { `enabled`, `perCalleeLimit`, `totalLimit`, `seed` }
  - [x] `mode`: propagation mode
  - [x] `timingMs`: { `total`, `propagation`, `io` }
  - [x] `capsHit`: record which caps were hit (depth, fanout, paths, timeout)

### 10.6.2 Add JSONL required keys
**File:** `src/shared/artifact-io/jsonl.js`

Extend `JSONL_REQUIRED_KEYS` with:
- [x] `risk_summaries`: `["schemaVersion","chunkUid","file","signals"]`
- [x] `risk_flows`: `["schemaVersion","flowId","source","sink","path","confidence","notes"]`

(Keep required keys minimal but sufficient.)

### 10.6.3 Add compression defaults for risk JSONL
**File:** `src/index/build/artifacts/compression.js`

Add `risk_summaries` and `risk_flows` to `COMPRESSIBLE_ARTIFACTS`.
- [x] Implement compression defaults update.

### 10.6.4 Implement artifact writers
**New file:** `src/index/build/artifacts/writers/risk-interprocedural.js`

Exports:
- [x] `enqueueRiskInterproceduralArtifacts({ state, runtime, mode, outputDir, manifest, log })`

Responsibilities:
- [x] If `mode !== "code"`: do nothing.
- [x] If `!runtime.riskInterproceduralEnabled`: do nothing.
- [x] Ensure summaries + flows are computed once and stored on state:
  - [x] `state.riskInterprocedural = { summaryRows, flowRows, stats, callSiteIdsReferenced }`
- [x] Write:
  - [x] always write `risk_interprocedural_stats.json` when enabled
  - [x] write `risk_summaries` jsonl only if `emitArtifacts==="jsonl"`
  - [x] write `risk_flows` jsonl only if `emitArtifacts==="jsonl"` and `summaryOnly===false` and `status==="ok"`
- [x] Reference 10.2.0 entry points/consumers to confirm where paramNames and callDetails originate.

**Where to compute:**  
Compute in the indexing pipeline **after** cross-file inference and **before** metaV2 finalization, so compact summaries land in chunk meta.

Recommended location:
- In `src/index/build/indexer/pipeline.js` after `runCrossFileInference(...)` and before postings/writing, OR
- In `src/index/build/indexer/steps/write.js` immediately before `finalizeMetaV2(...)`

Pick one and document it; do not compute twice.
- [x] Document the chosen compute location and ensure it is invoked exactly once.

### 10.6.5 Callsite assembly helper + manifest builder touchpoints
**Files (manifest builders):**
- [x] `src/index/build/incremental.js` (index manifest + pieces manifest)
- [x] `src/index/build/piece-assembly.js` (piece assembly + manifest usage)
- [x] `src/shared/artifact-io/manifest.js` (manifest path/compat helpers)

**Tasks**
- [x] Add/confirm a helper for assembling callsite references used by risk flows.
- [x] Wire the helper into `risk-interprocedural` writer usage so callSiteIds match the manifest.
- [x] Document the manifest builder files above in the callsite assembly helper docstring/comments.

### 10.6.6 Ensure chunk meta includes compact risk summary
No special code is needed if you attach `chunk.docmeta.risk.summary`, because:
- `src/index/metadata-v2.js` already includes `risk: docmeta?.risk`

- [x] Ensure the compact summary is small enough that `chunk-meta` writer does not drop docmeta for size reasons.

### 10.6.7 Add artifacts to piece assembly
**File:** `src/index/build/piece-assembly.js`

Add optional loading for:
- [x] `risk_summaries`
- [x] `risk_flows`
- [x] `risk_interprocedural_stats`

This makes downstream tooling (sqlite build, etc.) able to access these artifacts uniformly.

### 10.6.8 Tests for artifact writing
Add:
- [x] `tests/indexing/risk/interprocedural/artifacts-written.test.js`
  - [x] Build fixture index with `emitArtifacts="jsonl"`
  - [x] Assert files exist:
    - [x] `risk_summaries.jsonl` or sharded variants (+ `.meta.json`)
    - [x] `risk_flows.jsonl` or sharded variants (+ `.meta.json`)
    - [x] `risk_interprocedural_stats.json`
  - [x] Assert shard meta points to shard files.

---

## 10.7 Validation + referential integrity

### 10.7.1 Extend validator to load + schema-validate new artifacts
Files:
- [x] `src/index/validate.js`
- [x] `src/index/validate/artifacts.js`
- [x] `src/index/validate/presence.js`

Tasks:
- [x] Add `risk_summaries`, `risk_flows`, `risk_interprocedural_stats` to optional artifact list.
- [x] If present:
  - [x] schema-validate each using contracts
- [x] Add clear validation errors (include artifact name, failing row index if jsonl).
- [x] Compatibility stance: if artifacts are missing/old schema when expected, error and instruct users to rebuild (no back-compat).

### 10.7.2 Cross-artifact referential checks (must add)
Add new validator module:
- [x] `src/index/validate/risk-interprocedural.js`

Checks:
- [x] For each summary row:
  - [x] `chunkUid` exists in `chunk_meta`
  - [x] `file` matches `chunk_meta.file` (if present)
- [x] For each flow row:
  - [x] `path.chunkUids.length >= 2`
  - [x] `path.chunkUids[0] === source.chunkUid`
  - [x] `path.chunkUids[last] === sink.chunkUid`
  - [x] `path.callSiteIdsByStep.length === path.chunkUids.length - 1`
  - [x] Every `chunkUid` in path exists in `chunk_meta`
  - [x] Every `callSiteId` referenced exists in `call_sites` **if** `call_sites` is present
    - [x] (Note: call_sites is optional; if absent, validation should warn, not fail, unless strict mode demands it.)
- [x] For stats JSON:
  - [x] `effectiveConfig` fields are consistent with normalization
  - [x] If `status==="timed_out"`: flows count is 0
  - [x] If `emitArtifacts==="jsonl"` and `summaryOnly===false` and `status==="ok"`:
    - [x] `risk_flows` artifact must exist

### 10.7.3 Tests for validator checks
Add:
- [x] `tests/indexing/validate/validator/risk-interprocedural.test.js`
  - [x] Build fixture index with riskInterprocedural on
  - [x] Run validator, expect pass
  - [x] Corrupt one `callSiteId` in a flow row, expect validator fail with specific message

---

## 10.8 CLI: explain interprocedural risk flows

### 10.8.1 Add new command wiring
**File:** `bin/pairofcleats.js`

Add command:
- [x] `risk explain`

Map to new tool:
- [x] `tools/explain-risk.js`

### 10.8.2 Implement explain tool
**New file:** `tools/explain-risk.js`

Requirements:
- [x] Inputs:
  - [x] `--index <dir>` (required)
  - [x] `--chunk <chunkUid>` (required)
  - [x] `--max <n>` (default 20)
  - [x] optional filters:
    - [x] `--source-rule <ruleId>`
    - [x] `--sink-rule <ruleId>`
    - [x] `--json`
- [x] Loads artifacts from `indexDir`:
  - [x] `chunk_meta`
  - [x] `risk_summaries` (optional)
  - [x] `risk_flows` (optional)
  - [x] `call_sites` (optional; used to print call site context)
  - [x] `risk_interprocedural_stats` (optional)
- [x] Output (human mode):
  - [x] Print chunk identification (file, symbol name, kind)
  - [x] Print compact risk summary if present
  - [x] Print flows where chunk is:
    - [x] source chunk, or sink chunk, or appears in path
    - [x] ordered by descending `confidence`, then `flowId`
  - [x] For each flow:
    - [x] print path as `file::symbol` chain
    - [x] print sampled call sites per step by looking up `callSiteId` in `call_sites` (if present)
- [x] JSON mode: emit structured JSON with same data.

### 10.8.3 Tests for CLI
Add:
- [x] `tests/cli/general/risk-explain.test.js`
  - [x] Build fixture index
  - [x] Run `node bin/pairofcleats.js risk explain --index <dir> --chunk <uid>`
  - [x] Assert output contains flowId and the expected file names

### 10.8.4 Docs update for CLI output changes
**Files:** `docs/guides/commands.md` (and any CLI reference docs that mention `risk` commands)

**Tasks**
- [x] Update CLI usage/output examples if `risk explain` output or flags change.
- [x] Add a note about rebuild requirements for old indexes (align with 10.7 compatibility stance).

---

## 10.9 Cross-cutting robustness improvements (recommended)

### 10.9.1 Call graph edge union (prevents partial call_sites from hiding callLinks)
**File:** `src/index/build/graphs.js`

Current behavior:
- [x] If there is at least one callSiteEdge, it uses callSiteEdges and does NOT fall back to callLinks for missing edges.

Improve:
- [x] Always union edges from:
  - [x] `callSites` (when present)
  - [x] `callLinks` (when present)
- [x] Add a regression test (integration or unit) that proves missing callSiteEdges do not drop callLinks.

**Suggested test file:** `tests/indexing/risk/interprocedural/flows-conservative.test.js` (extend) or add `tests/risk-interprocedural/graph-callsite-union.test.js`.

### 10.9.2 Performance audit checklist
Before marking Phase 10 complete, verify:
- [x] Summaries build is O(#risk signals) and bounded by caps (`src/index/risk-interprocedural/summaries.js`).
- [x] Propagation stops on:
  - [x] timeout
  - [x] maxEdgeExpansions
  - [x] maxDepth
  - [x] maxTotalFlows
- [x] Memory usage:
  - [x] avoid building a global all-edges map if not needed; build per chunk on-demand (`risk-interprocedural/engine.js`).
- [x] No hidden global state:
  - [x] cache keys include buildRoot/buildId where applicable (pipeline + writer helpers).
- [x] Determinism:
  - [x] output stable across runs given same codebase and config (use `tests/indexing/risk/interprocedural/summaries-determinism.test.js` and a flow determinism test).

**Files to review (explicit)**
- [x] `src/index/risk-interprocedural/summaries.js` (summary caps + determinism)
- [x] `src/index/risk-interprocedural/engine.js` (caps, BFS ordering, timeouts, memory usage)
- [x] `src/index/risk-interprocedural/edges.js` (edge ordering + sampling determinism)
- [x] `src/index/build/artifacts/writers/risk-interprocedural.js` (status/emit flags + timing)

**Tests to use**
- [x] `tests/indexing/risk/interprocedural/summaries-determinism.test.js`
- [x] `tests/indexing/risk/interprocedural/flows-conservative.test.js`
- [x] `tests/indexing/risk/interprocedural/flows-argaware-negative.test.js`
- [x] `tests/indexing/risk/interprocedural/flows-timeout.test.js`

---

## Phase 10 completion checklist (must be true)
- [x] Docs are merged; canonical specs in `docs/specs/` match code contracts (especially `call_sites`).
- [x] Deprecated/replaced spec docs have been moved to `docs/archived/` and the process is documented in `AGENTS.md` (see 10.0.3).
- [x] `indexing.riskInterprocedural` survives config load and is normalized deterministically.
- [x] Cross-file inference runs when riskInterprocedural is enabled.
- [x] `docmeta.risk.summary` is present, compact, and deterministic.
- [x] `risk_summaries` artifact rows are schema-valid, capped, and <=32KiB each.
- [x] `risk_flows` artifact rows are deterministic, capped, and <=32KiB each.
- [x] Every callSiteId referenced by flows is resolvable in `call_sites` when present.
- [x] `risk_interprocedural_stats.json` is always written when enabled and accurately reflects status/caps.
- [x] Validator enforces schema + referential integrity for the new artifacts.
- [x] `pairofcleats risk explain` works and is covered by tests.
- [x] Old indexes are not supported; validation errors instruct users to rebuild (no compatibility shim).

---

### Doc merge checklist (explicit, per original roadmap requirement)
- [x] `docs/specs/risk-interprocedural-config.md` <- merge `docs/new_docs/spec_risk-interprocedural-config_IMPROVED.md`
- [x] `docs/specs/risk-summaries.md` <- merge `docs/new_docs/spec_risk-summaries_IMPROVED.md`
- [x] `docs/specs/risk-flows-and-call-sites.md` <- merge `docs/new_docs/spec_risk-flows-and-call-sites_RECONCILED.md`
- [x] `docs/specs/risk-callsite-id-and-stats.md` <- reconcile with code + update/annotate `docs/new_docs/risk-callsite-id-and-stats_IMPROVED.md`
- [x] `docs/specs/risk-interprocedural-stats.md` <- expand from placeholder using merged stats schema
- [x] `docs/new_docs/interprocedural-state-and-pipeline_DRAFT.md` <- either promote to `docs/specs/` or merge key content into the canonical specs

---

# Appendices  -  touchpoint mappings (with line ranges) + test lane hints

These appendices are generated to remove scavenger-hunts:
- Every file path referenced in a phase body appears here.
- Existing files include **approximate** line ranges.
- Planned files/dirs are labeled **NEW**.

## Appendix P0  -  Root-level touchpoints referenced by this roadmap

- `AGENTS.md` (~L1-L63)  -  agent workflow; must include the spec archival policy.
- `COMPLETED_PHASES.md` (~L1-L12)  -  record of completed roadmap phases.
- `GIGAROADMAP.md` (~L1-L4692)  -  prerequisite plan; this roadmap assumes it is complete.
- `package.json` (~L1-L278)  -  test lane scripts (`test:unit`, `test:services`, etc).

## Appendix P7  -  repo touchpoint map

> Line ranges are approximate. Prefer anchor strings (function/export names) over line numbers.

### Existing directories referenced
- `docs/contracts/` (DIR; exists)
- `src/contracts/` (DIR; exists)
- `tests/fixtures/sample/` (DIR; exists)

### Existing src/ files referenced (edit candidates)
- `src/contracts/registry.js` (~L1-L10)  -  exports/anchors: `ARTIFACT_SCHEMA_REGISTRY`, `ARTIFACT_SCHEMA_HASH`, `ARTIFACT_SCHEMA_NAMES`, `getArtifactSchema`
- `src/contracts/schemas/artifacts.js` (~L1-L677)  -  exports/anchors: `ARTIFACT_SCHEMA_DEFS`
- `src/index/build/file-processor/embeddings.js` (~L1-L260)
- `src/index/build/indexer/embedding-queue.js` (~L1-L49)  -  exports/anchors: `enqueueEmbeddingJob`
- `src/index/build/indexer/pipeline.js` (~L1-L326)
- `src/index/build/indexer/steps/write.js` (~L1-L101)  -  exports/anchors: `writeIndexArtifactsForMode`
- `src/index/embedding.js` (~L1-L56)  -  exports/anchors: `quantizeVec`, `quantizeVecUint8`, `normalizeVec`, `createEmbedder`
- `src/index/validate.js` (~L1-L581)
- `src/retrieval/ann/providers/hnsw.js` (~L1-L27)  -  exports/anchors: `createHnswAnnProvider`
- `src/retrieval/ann/providers/lancedb.js` (~L1-L39)  -  exports/anchors: `createLanceDbAnnProvider`
- `src/retrieval/cli-index.js` (~L1-L416)  -  exports/anchors: `resolveIndexDir`, `requireIndexDir`, `buildQueryCacheKey`, `getIndexSignature`
- `src/retrieval/cli/load-indexes.js` (~L1-L368)
- `src/retrieval/cli/normalize-options.js` (~L1-L273)  -  exports/anchors: `normalizeSearchOptions`
- `src/retrieval/cli/options.js` (~L1-L141)  -  exports/anchors: `getMissingFlagMessages`, `estimateIndexBytes`, `resolveIndexedFileCount`, `resolveBm25Defaults`, `loadBranchFromMetrics`
- `src/retrieval/cli/query-plan.js` (~L1-L205)  -  exports/anchors: `buildQueryPlan`
- `src/retrieval/lancedb.js` (~L1-L180)
- `src/retrieval/query-intent.js` (~L1-L84)  -  exports/anchors: `classifyQuery`, `resolveIntentVectorMode`, `resolveIntentFieldWeights`
- `src/retrieval/rankers.js` (~L1-L292)  -  exports/anchors: `rankBM25Legacy`, `getTokenIndex`, `rankBM25`, `rankBM25Fields`, `rankMinhash`
- `src/retrieval/sqlite-helpers.js` (~L1-L544)  -  exports/anchors: `createSqliteHelpers`
- `src/shared/artifact-io.js` (~L1-L12)
- `src/shared/artifact-io/manifest.js` (~L1-L291)  -  exports/anchors: `resolveManifestPath`, `loadPiecesManifest`, `readCompatibilityKey`, `normalizeMetaParts`, `resolveMetaFormat`
- `src/shared/embedding-adapter.js` (~L1-L158)  -  exports/anchors: `getEmbeddingAdapter`
- `src/shared/embedding-utils.js` (~L1-L176)  -  exports/anchors: `DEFAULT_EMBEDDING_POOLING`, `DEFAULT_EMBEDDING_NORMALIZE`, `DEFAULT_EMBEDDING_TRUNCATION`, `isVectorLike`, `mergeEmbeddingVectors`
- `src/shared/hnsw.js` (~L1-L160)  -  exports/anchors: `normalizeHnswConfig`, `resolveHnswPaths`, `loadHnswIndex`, `rankHnswIndex`
- `src/shared/lancedb.js` (~L1-L65)  -  exports/anchors: `normalizeLanceDbConfig`, `resolveLanceDbPaths`, `resolveLanceDbTarget`
- `src/storage/lmdb/schema.js` (~L1-L49)  -  exports/anchors: `LMDB_SCHEMA_VERSION`, `LMDB_META_KEYS`, `LMDB_ARTIFACT_KEYS`, `LMDB_ARTIFACT_LIST`, `LMDB_REQUIRED_ARTIFACT_KEYS`
- `src/storage/sqlite/build/incremental-update.js` (~L1-L567)
- `src/storage/sqlite/vector.js` (~L1-L71)  -  exports/anchors: `quantizeVec`, `resolveQuantizationParams`, `dequantizeUint8ToFloat32`, `toSqliteRowId`, `packUint32`

### Existing tools/ files referenced (edit candidates)
- `tools/build-embeddings.js` (~L1-L12)
- `tools/build-embeddings/cache.js` (~L1-L26)  -  exports/anchors: `buildCacheIdentity`, `resolveCacheRoot`, `resolveCacheDir`, `buildCacheKey`, `isCacheValid`
- `tools/build-embeddings/cli.js` (~L1-L95)  -  exports/anchors: `parseBuildEmbeddingsArgs`
- `tools/build-embeddings/embed.js` (~L1-L119)  -  exports/anchors: `assertVectorArrays`, `runBatched`, `ensureVectorArrays`, `createDimsValidator`, `isDimsMismatch`
- `tools/build-embeddings/hnsw.js` (~L1-L115)  -  exports/anchors: `createHnswBuilder`
- `tools/build-embeddings/lancedb.js` (~L1-L143)
- `tools/build-embeddings/manifest.js` (~L1-L111)  -  exports/anchors: `updatePieceManifest`
- `tools/build-embeddings/runner.js` (~L1-L763)
- `tools/build-embeddings/sqlite-dense.js` (~L1-L209)  -  exports/anchors: `updateSqliteDense`
- `tools/build-lmdb-index.js` (~L1-L311)
- `tools/dict-utils/paths/db.js` (~L1-L62)  -  exports/anchors: `resolveLmdbPaths`, `resolveSqlitePaths`
- `tools/index-validate.js` (~L1-L130)
- `tools/indexer-service.js` (~L1-L441)
- `tools/service/queue.js` (~L1-L270)  -  exports/anchors: `resolveQueueName`, `getQueuePaths`
- `tools/vector-extension.js` (~L1-L393)  -  exports/anchors: `getBinarySuffix`, `getPlatformKey`, `getVectorExtensionConfig`, `resolveVectorExtensionPath`, `loadVectorExtension`

### Existing docs/ files referenced (edit candidates)
- `docs/contracts/artifact-schemas.md` (~L1-L67)
- `docs/contracts/public-artifact-surface.md` (~L1-L104)
- `docs/guides/embeddings.md` (~L1-L92)
- `docs/guides/search.md` (~L1-L74)

### Existing tests/ files referenced (edit candidates)
- `tests/indexing/artifacts/artifact-io-manifest-discovery.test.js` (~L1-L60)  -  lane: `integration`; run: `npm run test:integration -- --match artifact-io-manifest-discovery.test`
- `tests/indexing/embeddings/embedding-queue-defaults.test.js` (~L1-L37)  -  lane: `integration`; run: `npm run test:integration -- --match embedding-queue-defaults`
- `tests/indexing/embeddings/embedding-queue.test.js` (~L1-L51)  -  lane: `integration`; run: `npm run test:integration -- --match embedding-queue`
- `tests/indexing/embeddings/embeddings-validate.test.js` (~L1-L82)  -  lane: `integration`; run: `npm run test:integration -- --match embeddings-validate`
- `tests/retrieval/ann/hnsw-ann.test.js` (~L1-L124)  -  lane: `integration`; run: `npm run test:integration -- --match hnsw-ann`
- `tests/retrieval/ann/hnsw-atomic.test.js` (~L1-L90)  -  lane: `integration`; run: `npm run test:integration -- --match hnsw-atomic`
- `tests/retrieval/ann/hnsw-candidate-set.test.js` (~L1-L78)  -  lane: `integration`; run: `npm run test:integration -- --match hnsw-candidate-set`
- `tests/retrieval/ann/lancedb-ann.test.js` (~L1-L100)  -  lane: `integration`; run: `npm run test:integration -- --match lancedb-ann`
- `tests/storage/lmdb/lmdb-backend.test.js` (~L1-L122)  -  lane: `integration`; run: `npm run test:integration -- --match lmdb-backend`
- `tests/storage/lmdb/lmdb-corruption.test.js` (~L1-L105)  -  lane: `integration`; run: `npm run test:integration -- --match lmdb-corruption`
- `tests/storage/lmdb/lmdb-report-artifacts.test.js` (~L1-L125)  -  lane: `integration`; run: `npm run test:integration -- --match lmdb-report-artifacts`

### Planned/new paths referenced in this phase (create as needed)
- **tests/**
  - `tests/ann-parity.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match ann-parity`
  - `tests/indexing/embeddings/embedding-normalization-consistency.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match embedding-normalization-consistency`
  - `tests/embedding-quantization-no-wrap.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match embedding-quantization-no-wrap`
  - `tests/fixtures/embeddings` (NEW fixture/dir  -  create as part of this phase)
  - `tests/fixtures/embeddings/basic-repo` (NEW fixture/dir  -  create as part of this phase)
  - `tests/fixtures/embeddings/missing-vectors` (NEW fixture/dir  -  create as part of this phase)
  - `tests/fixtures/embeddings/quantization-caps` (NEW fixture/dir  -  create as part of this phase)
  - `tests/retrieval/ann/hnsw-target-selection.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match hnsw-target-selection`
  - `tests/services/indexer/indexer-service-embedding-job-uses-build-root.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match indexer-service-embedding-job-uses-build-root`
  - `tests/retrieval/ann/ann-parity.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match ann-parity.test`
  - `tests/lancedb-candidate-filtering.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match lancedb-candidate-filtering`
  - `tests/indexing/embeddings/manifest-embeddings-pieces.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match manifest-embeddings-pieces`
  - `tests/quantize-embedding-utils.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match quantize-embedding-utils`
  - `tests/retrieval/backend/retrieval-strict-manifest-embeddings.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match retrieval-strict-manifest-embeddings`
  - `tests/storage/embeddings/embeddings-backend-resilience.test.js` (NEW)  -  intended lane: `storage`; run (once created): `npm run test:storage -- --match embeddings-backend-resilience.test`
  - `tests/retrieval/ann/ann-backend-selection.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match ann-backend-selection.test`
  - `tests/shared/cache/cache-preflight-meta.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match cache-preflight-meta.test`
  - `tests/retrieval/ann/dense-vector-mode.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match dense-vector-mode.test`
  - `tests/retrieval/ann/hnsw-insert-failures.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match hnsw-insert-failures.test`
  - `tests/retrieval/ann/hnsw-load-signature.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match hnsw-load-signature.test`
  - `tests/retrieval/ann/lancedb-candidate-filtering.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match lancedb-candidate-filtering.test`
  - `tests/retrieval/ann/lancedb-connection-cache.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match lancedb-connection-cache.test`
  - `tests/retrieval/ann/lancedb-filter-pushdown.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match lancedb-filter-pushdown.test`
  - `tests/storage/lmdb/lmdb-mapsize.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match lmdb-mapsize.test`
  - `tests/storage/sqlite/ann/sqlite-ann-mode-scope.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match sqlite-ann-mode-scope.test`


## Appendix P9  -  repo touchpoint map

> Line ranges are approximate. Prefer anchor strings (function/export names) over line numbers.

### Existing directories referenced
- `src/index/build/artifacts/writers/` (DIR; exists)
- `src/index/identity/` (DIR; exists)
- `src/index/tooling/` (DIR; exists)
- `tests/type-inference-crossfile/` (DIR; exists)
- `tools/bench/` (DIR; exists)

### Existing src/ files referenced (edit candidates)
- `src/contracts/schemas/artifacts.js` (~L1-L677)  -  exports/anchors: `ARTIFACT_SCHEMA_DEFS`
- `src/index/build/artifacts.js` (~L1-L528)
- `src/index/build/file-processor.js` (~L1-L529)  -  exports/anchors: `createFileProcessor`
- `src/index/build/file-processor/assemble.js` (~L1-L127)  -  exports/anchors: `buildChunkPayload`
- `src/index/build/file-processor/relations.js` (~L1-L71)  -  exports/anchors: `buildCallIndex`, `buildFileRelations`, `stripFileRelations`
- `src/index/build/graphs.js` (~L1-L267)  -  exports/anchors: `buildRelationGraphs`
- `src/index/chunk-id.js` (~L1-L21)  -  exports/anchors: `buildChunkId`, `resolveChunkId`
- `src/index/identity/chunk-uid.js` (~L1-L204)  -  exports/anchors: `PRE_CONTEXT_CHARS`, `POST_CONTEXT_CHARS`, `ESCALATION_CONTEXT_CHARS`, `MAX_COLLISION_PASSES`, `normalizeForUid`
- `src/index/metadata-v2.js` (~L1-L301)  -  exports/anchors: `buildMetaV2`, `finalizeMetaV2`
- `src/index/segments.js` (~L1-L190)  -  exports/anchors: `assignSegmentUids`, `discoverSegments`, `chunkSegments`
- `src/index/tooling/clangd-provider.js` (~L1-L187)  -  exports/anchors: `CLIKE_EXTS`, `createClangdProvider`
- `src/index/tooling/pyright-provider.js` (~L1-L127)  -  exports/anchors: `PYTHON_EXTS`, `createPyrightProvider`
- `src/index/tooling/sourcekit-provider.js` (~L1-L93)  -  exports/anchors: `SWIFT_EXTS`, `createSourcekitProvider`
- `src/index/tooling/typescript-provider.js` (~L1-L467)  -  exports/anchors: `createTypeScriptProvider`
- `src/index/type-inference-crossfile/pipeline.js` (~L1-L438)
- `src/index/type-inference-crossfile/symbols.js` (~L1-L30)  -  exports/anchors: `leafName`, `isTypeDeclaration`, `addSymbol`, `resolveUniqueSymbol`
- `src/index/validate.js` (~L1-L581)
- `src/lang/javascript/relations.js` (~L1-L687)  -  exports/anchors: `buildCodeRelations`
- `src/map/build-map.js` (~L1-L288)  -  exports/anchors: `buildNodeList`, `buildMapCacheKey`
- `src/map/build-map/edges.js` (~L1-L186)  -  exports/anchors: `buildEdgesFromGraph`, `buildEdgesFromCalls`, `buildEdgesFromUsage`, `buildEdgesFromCallSummaries`, `buildImportEdges`
- `src/map/build-map/filters.js` (~L1-L229)  -  exports/anchors: `resolveFocus`, `normalizeIncludeList`, `applyLimits`, `applyScopeFilter`, `applyCollapse`
- `src/map/build-map/symbols.js` (~L1-L95)  -  exports/anchors: `buildSymbolId`, `buildPortId`, `upsertMember`, `buildMemberIndex`, `resolveMemberByName`
- `src/map/isometric/client/map-data.js` (~L1-L47)  -  exports/anchors: `initMapData`
- `src/shared/artifact-io.js` (~L1-L12)
- `src/shared/artifact-io/jsonl.js` (~L1-L79)  -  exports/anchors: `resolveJsonlRequiredKeys`, `parseJsonlLine`
- `src/shared/artifact-schemas.js` (~L1-L2)
- `src/shared/identity.js` (~L1-L104)  -  exports/anchors: `buildChunkRef`, `isSemanticSymbolId`, `resolveSymbolJoinKey`, `resolveChunkJoinKey`, `buildSymbolKey`

### Existing docs/ files referenced (edit candidates)
- `docs/phases/phase-9/identity-contracts.md` (~L1-L132)
- `docs/phases/phase-9/migration-and-backcompat.md` (~L1-L45)
- `docs/phases/phase-9/symbol-artifacts-and-pipeline.md` (~L1-L122)
- `docs/specs/identity-contract.md` (~L1-L313)

### Existing tests/ files referenced (edit candidates)
- `tests/indexing/relations/graph-chunk-id.test.js` (~L1-L43)  -  lane: `integration`; run: `npm run test:integration -- --match graph-chunk-id`

### Planned/new paths referenced in this phase (create as needed)
- **src/**
  - `src/index/build/artifacts/writers/symbol-edges.js` (NEW  -  create as part of this phase)
  - `src/index/build/artifacts/writers/symbol-occurrences.js` (NEW  -  create as part of this phase)
  - `src/index/build/artifacts/writers/symbols.js` (NEW  -  create as part of this phase)
  - `src/index/identity/kind-group.js` (NEW  -  create as part of this phase)
  - `src/index/identity/normalize.js` (NEW  -  create as part of this phase)
  - `src/index/identity/segment-uid.js` (NEW  -  create as part of this phase)
  - `src/index/identity/symbol.js` (NEW  -  create as part of this phase)
  - `src/index/identity/virtual-path.js` (NEW  -  create as part of this phase)
  - `src/index/type-inference-crossfile/resolve-relative-import.js` (NEW  -  create as part of this phase)
  - `src/index/type-inference-crossfile/resolver.js` (NEW  -  create as part of this phase)
- **tools/**
  - `tools/bench/symbol-resolution-bench.js` (NEW  -  create as part of this phase)
- **docs/**
  - `docs/specs/symbol-artifacts.md` (NEW doc/spec  -  create as part of this phase)
  - `docs/specs/symbol-identity-and-symbolref.md` (NEW doc/spec  -  create as part of this phase)
- **tests/**
  - `tests/indexing/artifacts/symbol-artifacts-smoke.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match symbol-artifacts-smoke.test`
  - `tests/benchmarks` (NEW fixture/dir  -  create as part of this phase)
  - `tests/indexing/type-inference/crossfile/resolve-relative-import.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match resolve-relative-import.test`
  - `tests/indexing/type-inference/crossfile/symbolref-resolution.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match symbolref-resolution.test`
  - `tests/determinism` (NEW fixture/dir  -  create as part of this phase)
  - `tests/indexing/determinism/symbol-artifact-order.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match symbol-artifact-order.test`
  - `tests/fixtures/graph/chunkuid-join` (NEW fixture/dir  -  create as part of this phase)
  - `tests/fixtures/identity/chunkuid-collision` (NEW fixture/dir  -  create as part of this phase)
  - `tests/fixtures/imports/relative-ambiguous` (NEW fixture/dir  -  create as part of this phase)
  - `tests/fixtures/symbols/ambiguous-defs` (NEW fixture/dir  -  create as part of this phase)
  - `tests/identity/chunk-uid-stability.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match chunk-uid-stability.test`
  - `tests/identity/segment-uid-stability.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match segment-uid-stability.test`
  - `tests/indexing/identity/symbol-identity.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match symbol-identity.test`
  - `tests/indexing/determinism/chunkuid-determinism.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match chunkuid-determinism.test`
  - `tests/integration/file-name-collision-no-wrong-join.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match file-name-collision-no-wrong-join.test`
  - `tests/indexing/relations/graph-relations-v2-chunkuid.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match graph-relations-v2-chunkuid.test`
  - `tests/indexing/imports/import-resolver-relative.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match import-resolver-relative.test`
  - `tests/indexing/map/map-chunkuid-join.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match map-chunkuid-join.test`
  - `tests/indexing/determinism/symbol-artifact-determinism.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match symbol-artifact-determinism.test`
  - `tests/indexing/map/map-build-symbol-identity.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match map-build-symbol-identity.test`
  - `tests/indexing/artifacts/symbols/symbol-artifacts-emission.test.js` (NEW)  -  intended lane: `services`; run (once created): `npm run test:services -- --match symbol-artifacts-emission.test`
  - `tests/indexing/artifacts/symbols/symbol-edges-ambiguous.test.js` (NEW)  -  intended lane: `services`; run (once created): `npm run test:services -- --match symbol-edges-ambiguous.test`
  - `tests/indexing/artifacts/symbols/symbol-links-by-chunkuid.test.js` (NEW)  -  intended lane: `services`; run (once created): `npm run test:services -- --match symbol-links-by-chunkuid.test`
  - `tests/unit/chunk-uid-stability.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match chunk-uid-stability.test`
  - `tests/indexing/identity/identity-symbolkey-scopedid.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match identity-symbolkey-scopedid.test`
  - `tests/unit/segment-uid-stability.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match segment-uid-stability.test`
  - `tests/indexing/type-inference/symbolref-envelope.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match symbolref-envelope.test`
  - `tests/tooling/lsp/clangd-provider-output-shape.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match clangd-provider-output-shape.test`
  - `tests/tooling/lsp/pyright-provider-output-shape.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match pyright-provider-output-shape.test`
  - `tests/tooling/lsp/sourcekit-provider-output-shape.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match sourcekit-provider-output-shape.test`
  - `tests/tooling/lsp/typescript-provider-output-shape.test.js` (NEW)  -  intended lane: `unit`; run (once created): `npm run test:unit -- --match typescript-provider-output-shape.test`
  - `tests/validate/chunk-uid-required.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match chunk-uid-required.test`
  - `tests/indexing/validate/symbol-integrity-strict.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match symbol-integrity-strict.test`


## Appendix P10  -  repo touchpoint map

> Line ranges are approximate. Prefer anchor strings (function/export names) over line numbers.

### Existing directories referenced
- `docs/new_docs/` (DIR; exists)
- `docs/specs/` (DIR; exists)
- `src/contracts/` (DIR; exists)

### Existing src/ files referenced (edit candidates)
- `src/contracts/registry.js` (~L1-L10)  -  exports/anchors: `ARTIFACT_SCHEMA_REGISTRY`, `ARTIFACT_SCHEMA_HASH`, `ARTIFACT_SCHEMA_NAMES`, `getArtifactSchema`
- `src/contracts/schemas/artifacts.js` (~L1-L677)  -  exports/anchors: `ARTIFACT_SCHEMA_DEFS`
- `src/index/build/artifacts/compression.js` (~L1-L46)  -  exports/anchors: `resolveCompressionConfig`
- `src/index/build/artifacts/writers/call-sites.js` (~L1-L276)  -  exports/anchors: `createCallSites`, `enqueueCallSitesArtifacts`
- `src/index/build/graphs.js` (~L1-L267)  -  exports/anchors: `buildRelationGraphs`
- `src/index/build/indexer/pipeline.js` (~L1-L326)
- `src/index/build/indexer/signatures.js` (~L1-L120)  -  exports/anchors: `SIGNATURE_VERSION`, `buildIncrementalSignatureSummary`, `buildIncrementalSignaturePayload`, `buildTokenizationKey`, `buildIncrementalSignature`
- `src/index/build/indexer/steps/relations.js` (~L1-L205)  -  exports/anchors: `resolveImportScanPlan`, `preScanImports`, `postScanImports`, `runCrossFileInference`
- `src/index/build/indexer/steps/write.js` (~L1-L101)  -  exports/anchors: `writeIndexArtifactsForMode`
- `src/index/build/piece-assembly.js` (~L1-L512)
- `src/index/build/runtime/runtime.js` (~L1-L683)
- `src/index/metadata-v2.js` (~L1-L301)  -  exports/anchors: `buildMetaV2`, `finalizeMetaV2`
- `src/index/risk.js` (~L1-L404)  -  exports/anchors: `normalizeRiskConfig`, `detectRiskSignals`
- `src/index/type-inference-crossfile/extract.js` (~L1-L84)  -  exports/anchors: `extractReturnTypes`, `extractParamTypes`, `extractReturnCalls`, `inferArgType`
- `src/index/validate.js` (~L1-L581)
- `src/index/validate/artifacts.js` (~L1-L38)  -  exports/anchors: `buildArtifactLists`
- `src/index/validate/presence.js` (~L1-L183)  -  exports/anchors: `createArtifactPresenceHelpers`
- `src/lang/javascript/relations.js` (~L1-L687)  -  exports/anchors: `buildCodeRelations`
- `src/shared/artifact-io/jsonl.js` (~L1-L79)  -  exports/anchors: `resolveJsonlRequiredKeys`, `parseJsonlLine`
- `src/shared/hash.js` (~L1-L74)  -  exports/anchors: `sha1`, `sha1File`, `setXxhashBackend`

### Existing tools/ files referenced (edit candidates)
- `tools/dict-utils/config.js` (~L1-L310)  -  exports/anchors: `loadUserConfig`, `getEffectiveConfigHash`, `getCacheRoot`, `getDictConfig`, `applyAdaptiveDictConfig`

### Existing docs/ files referenced (edit candidates)
- `docs/config/contract.md` (~L1-L70)
- `docs/config/schema.json` (~L1-L264)
- `docs/new_docs/interprocedural-state-and-pipeline_DRAFT.md` (~L1-L156)
- `docs/new_docs/risk-callsite-id-and-stats_IMPROVED.md` (~L1-L120)
- `docs/new_docs/spec_risk-flows-and-call-sites_RECONCILED.md` (~L1-L141)
- `docs/new_docs/spec_risk-interprocedural-config_IMPROVED.md` (~L1-L99)
- `docs/new_docs/spec_risk-summaries_IMPROVED.md` (~L1-L169)
- `docs/specs/risk-callsite-id-and-stats.md` (~L1-L162)
- `docs/specs/risk-flows-and-call-sites.md` (~L1-L341)
- `docs/specs/risk-interprocedural-config.md` (~L1-L171)
- `docs/specs/risk-interprocedural-stats.md` (~L1-L9)
- `docs/specs/risk-summaries.md` (~L1-L253)

### Existing bin/ files referenced (edit candidates)
- `bin/pairofcleats.js` (~L1-L279)

### Planned/new paths referenced in this phase (create as needed)
- **src/**
  - `src/index/build/artifacts/writers/risk-interprocedural.js` (NEW  -  create as part of this phase)
  - `src/index/callsite-id.js` (NEW  -  create as part of this phase)
  - `src/index/risk-interprocedural/config.js` (NEW  -  create as part of this phase)
  - `src/index/risk-interprocedural/edges.js` (NEW  -  create as part of this phase)
  - `src/index/risk-interprocedural/engine.js` (NEW  -  create as part of this phase)
  - `src/index/risk-interprocedural/summaries.js` (NEW  -  create as part of this phase)
  - `src/index/validate/risk-interprocedural.js` (NEW  -  create as part of this phase)
- **tools/**
  - `tools/explain-risk.js` (NEW  -  create as part of this phase)
- **docs/**
  - `docs/archived` (NEW  -  create as part of this phase)
  - `docs/archived/README.md` (NEW doc/spec  -  create as part of this phase)
  - `docs/archived/phase-10` (NEW  -  create as part of this phase)
  - `docs/archived/specs/phase-10` (NEW  -  create as part of this phase)
- **tests/**
  - `tests/cli/general/risk-explain.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match risk-explain.test`
  - `tests/fixtures/risk-interprocedural/js-simple` (NEW fixture/dir  -  create as part of this phase)
  - `tests/lang/javascript/javascript-paramnames.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match javascript-paramnames.test`
  - `tests/indexing/risk/interprocedural/artifacts-written.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match artifacts-written.test`
  - `tests/indexing/risk/interprocedural/callsite-id.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match callsite-id.test`
  - `tests/indexing/risk/interprocedural/callsite-sampling.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match callsite-sampling.test`
  - `tests/indexing/risk/interprocedural/config-normalization.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match config-normalization.test`
  - `tests/indexing/risk/interprocedural/flows-argaware-negative.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match flows-argaware-negative.test`
  - `tests/indexing/risk/interprocedural/flows-conservative.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match flows-conservative.test`
  - `tests/indexing/risk/interprocedural/flows-sanitizer-policy.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match flows-sanitizer-policy.test`
  - `tests/indexing/risk/interprocedural/flows-timeout.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match flows-timeout.test`
  - `tests/indexing/risk/interprocedural/runtime-gating.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match runtime-gating.test`
  - `tests/indexing/risk/interprocedural/summaries-determinism.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match summaries-determinism.test`
  - `tests/indexing/risk/interprocedural/summaries-schema.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match summaries-schema.test`
  - `tests/indexing/risk/interprocedural/summaries-truncation.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match summaries-truncation.test`
  - `tests/unit` (NEW fixture/dir  -  create as part of this phase)
  - `tests/indexing/validate/validator/risk-interprocedural.test.js` (NEW)  -  intended lane: `integration`; run (once created): `npm run test:integration -- --match risk-interprocedural.test`












## Phase 10 — Interprocedural risk propagation + explainability artifacts (Completed)
- Phase 10 completed on quantum-leviathan-protocol; artifacts, validation, CLI explain, and robustness/test updates finished (see QUANTUM_LEVIATHAN_PROTOCOL.md).

## Phase 11 — Graph-powered product features (context packs, impact, explainability, ranking)

### Objective
Turn graph and identity primitives into **safe, bounded, deterministic** product surfaces: graph context packs, impact analysis, explainable graph-aware ranking (opt-in), and structured outputs suitable for both CLI use and future API/MCP consumers.

- Assumes canonical identities exist (e.g., chunkUid/SymbolId and a canonical reference envelope for unresolved/ambiguous links).
- Any graph expansion MUST be bounded and MUST return truncation metadata when caps trigger (depth/fanout/paths/nodes/edges/candidates/work-units/wall-clock).
- The default search contract must remain stable: graph features can change ordering when enabled, but must not change membership/correctness.
- Outputs are JSON-first (schema-validated); Markdown render is optional and deterministic.

---

### 11.0 Shared foundations (contracts, determinism, config)

- [x] Define Phase 11 shared contract types (authoritative spec: `docs/phases/phase-11/spec.md`):
  - `NodeRef` (chunk/symbol/file)
  - `ReferenceEnvelope` (resolved/ambiguous/unresolved + bounded candidates)
  - `WarningRecord`
  - `TruncationRecord`
  - stable ordering rules (nodeKey/edgeKey)
- [x] Add provenance metadata requirements for all Phase 11 JSON outputs:
  - `generatedAt`
  - `indexCompatKey` or `indexSignature`
  - `capsUsed`
  - optional `repo` / `indexDir`
- [x] Add schemas in `src/contracts/schemas/analysis.js`:
  - `GRAPH_CONTEXT_PACK_SCHEMA`
  - `GRAPH_IMPACT_SCHEMA`
  - `COMPOSITE_CONTEXT_PACK_SCHEMA`
  - `API_CONTRACTS_SCHEMA`
  - `ARCHITECTURE_REPORT_SCHEMA`
  - `SUGGEST_TESTS_SCHEMA`
- [x] Add validators in `src/contracts/validators/analysis.js`.

- [x] Determinism helpers + work-budget caps.
  - Add stable comparator utilities for NodeRef/edges/paths.
  - Add deterministic `maxWorkUnits` tracking (recommended for all traversals).
  - Treat `maxWallClockMs` as optional fuse; always record truncation when it triggers.
- [x] Define deterministic `maxWallClockMs` semantics:
  - check cadence (e.g., every N work units)
  - stop only at step boundaries
  - emit truncation metadata with observed/omitted counts

- [x] Config surface.
  - `indexing.graph.caps`
  - `retrieval.graph.caps`
  - `retrieval.graphRanking.*`
  - `retrieval.contextExpansion.*`
  - Touchpoints:
    - `docs/config/schema.json`
    - `tools/dict-utils/config.js`
    - `tools/validate-config.js`
    - `src/config/validate.js`

- [x] Standardize module home for new graph tooling commands.
  - Use `src/integrations/tooling/` for new command handlers and renderers.
  - Keep graph primitives under `src/graph/` and pack assembly under `src/context-pack/`.

- [x] Centralize artifact presence + loading for graph-powered features.
  - Add a single GraphStore + loader path used by all Phase 11 commands.
  - Touchpoints:
    - `src/shared/artifact-io/manifest.js`
    - `src/shared/artifact-io/loaders.js`
    - `src/graph/store.js`
    - `src/index/validate/presence.js` (optional artifacts)

- [x] Move graph build caps + identity-first node IDs earlier (dependency for all consumers).
  - Update `src/index/build/graphs.js` to use config-driven caps and record which cap triggered.
  - Enforce identity-first graph node IDs for new writes (legacy read-compat only).
  - Touchpoints:
    - `src/index/build/graphs.js`
    - `src/index/build/indexer/steps/relations.js`
    - `src/index/build/artifacts/graph-relations.js` (if present) or the current writer location

- [x] Define harness determinism controls:
  - `--outDir`, `--runId`
  - injectable date/time for CI to avoid `<date>` path drift

#### Tests
- [x] `tests/shared/contracts/phase11-schemas-validate.test.js`
  - Validate representative payload fixtures against each Phase 11 schema.

---

### 11.1 Graph context packs (bounded neighborhood extraction) + retrieval context-expansion hardening

- [x] Define a graph context pack contract (JSON-first; Markdown render optional).
  - Output shape (minimum):
    - `seed` (canonical id + type)
    - `nodes[]` (bounded; stable ordering)
    - `edges[]` (bounded; stable ordering; include direction and edge type)
    - `paths[]` (optional; bounded witness paths when requested)
    - `truncation[]` (one or more truncation records; absent only when no caps trigger)
    - `warnings[]` (e.g., missing artifacts, partial/unresolved edges)
  - Link safety:
    - Any edge endpoint that fails to resolve MUST use a reference envelope (resolved/ambiguous/unresolved + candidates + reason + confidence).
  - Graph filters (optional):
    - `graphs` (callGraph/importGraph/usageGraph/symbolEdges)
    - `edgeTypes` (call/usage/import/export/dataflow; `symbol_edges.type` when graph = symbolEdges)
    - `minConfidence` (0..1)
    - `includePaths` (emit witness paths)
  - Cap surface (configurable):
    - `maxDepth`, `maxFanoutPerNode`, `maxNodes`, `maxEdges`, `maxPaths`, `maxCandidates`, `maxWorkUnits`, `maxWallClockMs`.

- [x] Add deterministic Markdown renderer for graph context packs.
  - `src/retrieval/output/graph-context-pack.js` (new; stable section ordering and formatting)

- [x] Implement deterministic neighborhood extraction for a seed id (k-hop).
  - Prefer graph source artifacts when present:
    - `graph_relations` for call/usage/import graphs (baseline).
    - `symbol_edges` / callsite artifacts (when available) for evidence and SymbolId identity.
  - Deterministic traversal:
    - Stable adjacency ordering (lexicographic by canonical id, then edge type).
    - Deterministic tie-breaking when budgets are hit (e.g., keep lowest id first, or keep highest confidence first, but make it explicit and stable).
  - Strict bounding:
    - Enforce caps during traversal (no “collect everything then slice”).
    - Record truncation metadata with which cap triggered and how much was omitted.

- [x] Refactor `src/retrieval/context-expansion.js` to use the shared graph neighborhood utilities (do not make it the engine).
  - Touchpoints:
    - `src/retrieval/context-expansion.js`
    - `src/shared/artifact-io/manifest.js` (artifact presence checks via manifest)
  - [x] Eliminate eager `{id, reason}` candidate explosion.
    - Convert candidate generation to a streaming/short-circuit loop that stops as soon as `maxPerHit` / `maxTotal` / `maxWorkUnits` is satisfied.
    - Add per-source caps (e.g., max call edges examined, max import links examined) so worst-case repos cannot allocate unbounded candidate sets.
  - [x] Remove duplicate scanning and make reason selection intentional.
    - Track candidates in a `Map<id, { bestReason, bestPriority, reasons? }>` rather than pushing duplicates into arrays.
    - Define a fixed reason priority order (example: call > usage > export > import > nameFallback) and document it.
    - When `--explain` is enabled, optionally retain the top-N reasons per id (bounded).
  - [x] Stop assuming `chunkMeta[id]` is a valid dereference forever.
    - Build a `byDocId` (and/or `byChunkUid`) lookup once and use it for dereferencing.
    - If a dense array invariant is still desired for performance, validate it explicitly and fall back to map deref when violated.
  - [x] Prefer identity-first joins.
    - When graph artifacts exist, resolve neighbors via canonical ids rather than `byName` joins.
    - Keep name-based joins only as an explicit fallback mode with low-confidence markers.

#### Tests (path-corrected for current test layout)
- [x] `tests/retrieval/graph/context-pack-basic.test.js`
  - Build a small fixture graph; request a context pack for a known seed; assert expected caller/callee/import/usage neighbors are present.
- [x] `tests/retrieval/graph/context-pack-caps.test.js`
  - Use a large synthetic graph fixture; assert truncation metadata is present and stable when caps trigger.
- [x] `tests/retrieval/graph/context-pack-determinism.test.js`
  - Run the same request twice; assert stable ordering and identical payloads.
- [x] `tests/retrieval/context-expansion/context-expansion-no-candidate-explosion.test.js`
  - Stress fixture with many relations; assert expansion completes within a time/memory budget and does not allocate unbounded candidate arrays.
- [x] `tests/retrieval/context-expansion/context-expansion-reason-precedence.test.js`
  - A chunk reachable via multiple relation types records the highest-priority reason deterministically.
- [x] `tests/retrieval/context-expansion/context-expansion-shuffled-chunkmeta.test.js`
  - Provide a shuffled `chunkMeta` where array index != docId; assert expansion still resolves correct chunks via a map-based dereference.
- [x] `tests/retrieval/context-expansion/context-expansion-determinism.test.js`
  - Run expansion twice on the same fixture; assert stable ordering and identical results.

Fixture sources:
- `tests/fixtures/graph/context-pack/`
- `tests/fixtures/retrieval/context-expansion/`

Touchpoints (consolidated; anchors are approximate):
- `src/retrieval/context-expansion.js` (~L1 `pushIds`, ~L8 `buildContextIndex`, ~L77 `expandContext`)
- `src/shared/artifact-io/manifest.js` (~L254 `resolveArtifactPresence`)
- `src/shared/artifact-io/loaders.js` (~L312 `loadGraphRelations`)
- `src/graph/store.js` (new; manifest-aware graph loader + adjacency access)
- `src/graph/neighborhood.js` (new; deterministic bounded traversal)
- `src/graph/context-pack.js` (new; pack construction + truncation metadata)
- `src/retrieval/output/graph-context-pack.js` (new; deterministic Markdown renderer)
- `src/integrations/tooling/graph-context.js` (new; CLI command implementation)
- `src/retrieval/cli/index-loader.js` (~L73 `loadFileRelations`, ~L89 `loadRepoMap`; add `loadGraphRelations`)
- `src/retrieval/cli/run-search-session.js` (~L86 `contextExpansionEnabled`, ~L486 expansion block)
- `src/retrieval/cli/normalize-options.js` (~L173 `contextExpansionEnabled`)
- `src/retrieval/cli/options.js` + `src/retrieval/cli-args.js` (CLI flags/help)
- `src/retrieval/cli/render.js` (~L4 `renderSearchOutput`)
- `src/retrieval/output/context.js` (~L1 `cleanContext` for context-pack rendering)
- `bin/pairofcleats.js` (CLI wiring: `graph-context`)
- `src/contracts/schemas/analysis.js` (add `GRAPH_CONTEXT_PACK_SCHEMA`)
- `src/contracts/validators/analysis.js` (add `validateGraphContextPack`)
- `docs/contracts/analysis-schemas.md` + `docs/contracts/search-cli.md` (schema + CLI JSON)



---

### 11.2 Impact analysis (callers/callees + k-hop impact radius) with witness paths

- [x] Implement bounded impact analysis on top of the same neighborhood extraction primitives.
  - Provide `impactAnalysis(seed, { direction, depth, caps, edgeFilters })` returning:
    - impacted nodes (bounded; stable ordering)
    - at least one witness path per impacted node when available (bounded; do not enumerate all paths)
    - explicit unresolved/partial path markers when edges cannot be resolved.
  - Deterministic ordering:
    - stable sort by `(distance, confidence desc, name/id asc)` (or equivalent stable rule), and document it.

- [x] CLI surface (API-ready internal design).
  - Add `pairofcleats impact --repo … --seed <id> --direction upstream|downstream --depth 2 --format json|md`.
  - Add graph filters: `--graphs`, `--edgeTypes`, `--minConfidence`.
  - Ensure the implementation is factored so an API/MCP handler can call the same core function with the same caps and output schema.

- [x] Optional “changed-set” impact mode (non-blocking in this phase).
  - Accept `--changed <file>` repeated and `--changed-file <path>` (newline-separated paths) and compute:
    - impacted symbols in and around changed files, then traverse upstream/downstream bounded.
  - If `seed` is omitted, derive candidate seeds deterministically and emit a `ReferenceEnvelope` with bounded candidates.
  - If SCM integration is unavailable, degrade gracefully (explicit warning; still supports explicit `--changed` lists).
  - Specify deterministic changed-set → seed derivation:
    - ordering of derived seeds
    - max seeds cap + truncation behavior

#### Tests (path-corrected for current test layout)
- [x] `tests/retrieval/graph/impact-analysis-downstream.test.js`
  - Seed a function; assert downstream impacted nodes include an expected callee and a witness path is returned.
- [x] `tests/retrieval/graph/impact-analysis-upstream.test.js`
  - Seed a function; assert upstream impacted nodes include an expected caller and a witness path is returned.
- [x] `tests/retrieval/graph/impact-analysis-caps-and-truncation.test.js`
  - Trigger caps deterministically; assert truncation metadata identifies which cap fired and results remain stable.
- [x] `tests/retrieval/graph/impact-analysis-determinism.test.js`
  - Run the same request twice; assert stable ordering and identical payloads.
- [x] `tests/retrieval/graph/impact-analysis-changed-set.test.js`
  - Provide `--changed` inputs; assert deterministic seed derivation and bounded output.

Fixture sources:
- `tests/fixtures/graph/impact/`

Touchpoints (consolidated; anchors are approximate):
- `src/graph/impact.js` (new; bounded impact analysis)
- `src/graph/witness-paths.js` (new; witness path reconstruction)
- `src/graph/neighborhood.js` (shared traversal primitives)
- `src/integrations/tooling/impact.js` (new; CLI command implementation)
- `src/integrations/tooling/render-impact.js` (new; stable human + JSON renderers)
- `bin/pairofcleats.js` (CLI wiring: `impact`)
- `src/contracts/schemas/analysis.js` (add `GRAPH_IMPACT_SCHEMA`)
- `src/contracts/validators/analysis.js` (add `validateGraphImpact`)
- `docs/contracts/analysis-schemas.md` + `docs/contracts/graph-tools-cli.md` (schema + CLI JSON)



---

### 11.3 Context pack assembly for tooling/LLM (chunk text + graph + types + risk) + explainability rendering

- [x] Implement a “context pack assembler” that composes multiple bounded slices into a single package.
  - Inputs:
    - `seed` (chunkUid/SymbolId)
    - budgets (`maxTokens` and/or `maxBytes`, plus graph caps)
    - toggles (includeGraph, includeTypes, includeRisk, includeImports, includeUsages, includeCallersCallees)
    - per-slice caps (`maxTypeEntries`, `maxRiskFlows`, `maxRiskEvidencePerFlow`)
  - Output (recommended minimum):
    - `primary` (chunk excerpt + stable identifiers + file/segment provenance)
    - `graph` (from 11.1; bounded neighborhood)
    - `types` (bounded: referenced/declared/inferred/tooling-backed summaries when available)
    - `risk` (bounded: top-N flows/summaries crossing the seed, with callsite evidence when present)
    - `truncation[]` (aggregate truncation across slices)
    - `warnings[]` (missing artifacts, partial resolution, disabled features)
  - Notes:
    - Do not embed large raw code blobs; prefer bounded excerpts and (when needed) snippet hashes + location coordinates.
    - Use stable ordering inside each slice so context packs are deterministic across runs.

- [x] Add CLI surface:
  - `pairofcleats context-pack --repo … --seed <id> --hops 2 --maxTokens 4000 --format json|md`
  - Add toggles: `--includeGraph`, `--includeTypes`, `--includeRisk`, `--includeImports`, `--includeUsages`, `--includeCallersCallees`
  - Add per-slice caps: `--maxTypeEntries`, `--riskMaxFlows`, `--riskMaxEvidencePerFlow`
  - For Markdown output, use consistent sections and a deterministic ordering (primary first, then callers/callees, then imports/usages, then risk).

- [x] Add explain-risk rendering for flows when risk artifacts exist.
  - Provide an output mode (flag or subcommand) that prints:
    - the path of symbols/chunks
    - file/line evidence (callsites) when present
    - rule ids/categories and confidence
    - bounded snippets or snippet hashes (never unbounded)
  - Ensure output is stable, capped, and does not assume optional color helpers exist.

- [x] Define excerpt whitespace policy:
  - clarify when indentation is preserved (code excerpts) vs normalized (summary/output cleaning)
  - document how `cleanContext()` interacts with excerpt rendering

- [x] Harden retrieval output helpers used by these features (integrate known bugs in touched files).
  - Touchpoints:
    - `src/retrieval/output/context.js`
    - `src/retrieval/output/explain.js`
  - [x] `cleanContext()` must remove fence lines that include language tags.
    - Treat any line whose trimmed form starts with ``` as a fence line.
  - [x] `cleanContext()` must not throw on non-string items.
    - Guard/coerce before calling `.trim()`.
  - [x] Explain formatting must not assume `color.gray()` exists.
    - Provide a no-color fallback when `color?.gray` is not a function.

#### Tests (path-corrected for current test layout)
- [x] `tests/retrieval/context-pack/context-pack-assembly.test.js`
  - Build fixture; assemble a context pack; assert it contains primary + at least one neighbor + deterministic truncation structure.
- [x] `tests/retrieval/output/risk-explain-render.test.js`
  - Use a risk-flow fixture; assert output includes a call path and evidence coordinates and remains bounded.
- [x] `tests/retrieval/output/clean-context-fences.test.js`
  - Ensure ```ts / ```json fences are removed (not just bare ```).
- [x] `tests/retrieval/output/clean-context-nonstring-guard.test.js`
  - Feed non-string items; assert no crash and only string lines survive.
- [x] `tests/retrieval/output/explain-color-fallback.test.js`
  - Provide a partial color impl; assert explain rendering does not throw.

Fixture sources:
- `tests/fixtures/context-pack/`
- `tests/fixtures/risk/`

Touchpoints (consolidated):
- `src/context-pack/assemble.js` (new; bounded pack assembly)
- `src/graph/context-pack.js` + `src/graph/neighborhood.js` (graph slice + traversal)
- `src/retrieval/output/context.js` (~L1 `cleanContext`; hardening: fence stripping, type guards)
- `src/retrieval/output/explain.js` (~L1 `formatExplainLine`; null-safe + color fallback)
- `src/retrieval/output/graph-context-pack.js` (new; deterministic Markdown renderer)
- `src/integrations/tooling/context-pack.js` (new; CLI command implementation)
- `bin/pairofcleats.js` (CLI wiring: `context-pack`)
- `docs/contracts/analysis-schemas.md` + `docs/contracts/graph-tools-cli.md` (schema + CLI JSON)



---

### 11.4 Graph-aware ranking hooks (opt-in) + explainability

- [x] Introduce optional graph-aware ranking features that can be enabled without changing result membership.
  - Candidate feature families (bounded, deterministic):
    - node degree / in-degree / out-degree (prefer precomputed analytics artifacts when available)
    - proximity to the query-hit seed within the graph neighborhood (bounded k-hop)
    - proximity to risk hotspots (if risk summaries/flows exist)
    - same-cluster bonus (only if clustering artifacts exist; otherwise skip and emit a warning)
  - Guardrails:
    - Never compute expensive global graph metrics per query unless explicitly cached and bounded.
    - Default behavior remains unchanged unless explicitly enabled.
  - Define caching/analytics plan:
    - precomputed artifact vs session cache decision
    - schema and loader if artifact-based
  - Define tie-breaker rules for equal graph deltas/features.

- [x] Integrate into retrieval ranking with an explicit feature-hook layer.
  - Touchpoints (expected; anchors are approximate):
    - `src/retrieval/pipeline.js` (~L25 `createSearchPipeline`; scoring assembly + explain output)
    - `src/retrieval/cli/run-search-session.js` (~L86 context options + ~L486 expansion block)
    - `src/retrieval/cli/normalize-options.js` (~L173 context defaults; add graph ranking config)
    - `src/retrieval/cli/options.js` + `src/retrieval/cli-args.js` (flag plumbing + help text)
    - `src/retrieval/output/explain.js` (~L12 `formatScoreBreakdown` for graph section)
  - Configuration:
    - `retrieval.graphRanking.enabled` (default false)
    - `retrieval.graphRanking.weights` (explicit; versioned defaults)
    - `retrieval.graphRanking.maxGraphWorkUnits` (deterministic cap)
    - optional `retrieval.graphRanking.maxWallClockMs` (fuse)
    - optional `retrieval.graphRanking.seedSelection`
    - optional `retrieval.graphRanking.seedK`
    - CLI mapping (must remain in sync with docs):
      - `--graph-ranking-max-work` -> `retrieval.graphRanking.maxGraphWorkUnits`
      - `--graph-ranking-max-ms` -> `retrieval.graphRanking.maxWallClockMs`
      - `--graph-ranking-seeds` -> `retrieval.graphRanking.seedSelection`
      - `--graph-ranking-seed-k` -> `retrieval.graphRanking.seedK`
  - Explainability:
    - When `--explain` (or a dedicated `--explain-ranking`) is enabled, include a `graph` section in the score breakdown:
      - feature contributions and the final blended delta.

#### Tests (path-corrected for current test layout)
- [x] `tests/retrieval/ranking/graph-ranking-toggle.test.js`
  - Run the same query with graph ranking off/on; assert result sets are identical but ordering may differ.
- [x] `tests/retrieval/ranking/graph-ranking-explain.test.js`
  - With explain enabled, assert output includes named graph feature contributions.
- [x] `tests/retrieval/ranking/graph-ranking-determinism.test.js`
  - Re-run the same query twice with graph ranking enabled; assert ordering and explain payload are stable.
- [x] `tests/retrieval/ranking/graph-ranking-membership-invariant.test.js`
  - Run the same query with graph ranking on/off; assert result membership is identical.

---

### 11.5 Graph expansion caps as a config surface + calibration harness (language × size tier)

- [x] Align cap vocabulary across indexing + retrieval (depends on 11.0 graph caps update).
  - Ensure all expansions use the same cap names and truncation metadata semantics.
  - Touchpoints:
    - `src/retrieval/context-expansion.js` (cap naming + truncation records)
    - `src/graph/neighborhood.js`
    - `docs/perf/graph-caps.md`
  - Required behavior:
    - Every expansion returns truncation metadata when it truncates.
    - Truncation metadata indicates which cap fired and provides counts (omitted nodes/edges/paths) when measurable.

- [x] Implement a metrics-harvesting harness to justify default caps.
  - Inputs:
    - Use/extend `benchmarks/repos.json` to define repos.
    - Normalize into tiers: small / typical / large / huge / problematic(massive).
    - Define numeric tier thresholds for `small/typical/large/huge/problematic`.
  - For each repo/tier (outside CI for huge/problematic):
    - run indexing with graphs enabled
    - compute graph distributions (node/edge counts, degree stats, SCC size)
    - run bounded neighborhood expansions for representative seeds (random, top-degree, entrypoints)
    - record timing and output sizes
  - Outputs:
    - versioned bundle under `benchmarks/results/<date>/graph-caps/`
    - machine-readable defaults: `docs/perf/graph-caps-defaults.json` (new; keyed by language and optional tier)
    - documentation: `docs/perf/graph-caps.md` (p95 behavior for typical tier + presets for huge/problematic)
  - Define default-selection logic:
    - explicit rule for converting harness measurements into `graph-caps-defaults.json`

#### Tests (path-corrected for current test layout)
- [x] `tests/indexing/graphs/caps-enforced-and-reported.test.js`
  - Build a small fixture; request deep expansion; assert caps trigger deterministically and truncation metadata is present.
- [x] `tests/perf/bench/graph-caps-harness-smoke.test.js`
  - Run the harness on a tiny in-tree fixture; assert it writes a results JSON file with required fields and deterministic ordering.

---

### 11.6 Cross-file API contracts (report + optional artifact)

- [x] Provide an API-contract extraction/report surface based on existing artifacts (do not require new parsing).
  - For each exported symbol (as available via symbol artifacts):
    - canonical signature (declared + tooling-backed when available)
    - observed call signatures (from bounded callsite evidence / callDetails summaries)
    - compatibility warnings (arity mismatches, incompatible argument kinds, unresolved targets)
  - Output formats:
    - JSON (machine; versioned schema)
    - Markdown (human; deterministic ordering)
  - Strict caps:
    - max symbols analyzed per run
    - max calls sampled per symbol
    - max warnings emitted (with truncation metadata)
  - Define API contract source precedence + sampling rules:
    - exported symbol identification precedence
    - canonical signature source precedence
    - deterministic call sampling rules
    - warning/mismatch criteria (language-aware + confidence)

- [x] CLI surface:
  - `pairofcleats api-contracts --repo … [--only-exports] [--fail-on-warn] --format json|md`

- [x] Optional: enable an artifact emitter for downstream automation.
  - `api_contracts.jsonl` (one record per symbol) with strict schema validation and caps.

#### Tests (path-corrected for current test layout)
- [x] `tests/tooling/api-contracts/api-contracts-basic.test.js`
  - Fixture with an exported function called with multiple shapes; assert contract report includes observed calls and a mismatch warning.
- [x] `tests/tooling/api-contracts/api-contracts-caps.test.js`
  - Trigger caps; assert truncation metadata is present and stable.
- [x] `tests/tooling/api-contracts/api-contracts-fail-on-warn.test.js`
  - Ensure `--fail-on-warn` yields non-zero exit when warnings are present.
- [x] `tests/tooling/api-contracts/api-contracts-schema-validate.test.js`
  - Validate output against `API_CONTRACTS_SCHEMA` (including truncation + warnings).

Fixture sources:
- `tests/fixtures/tooling/api-contracts/`

Touchpoints (consolidated; anchors are approximate):
- `src/integrations/tooling/api-contracts.js` (new; report builder)
- `src/shared/artifact-io/loaders.js` (~L312 `loadGraphRelations`; add loaders for call_sites/symbols as needed)
- `src/contracts/schemas/analysis.js` (add `API_CONTRACTS_SCHEMA`)
- `src/contracts/validators/analysis.js` (add `validateApiContracts`)
- `src/contracts/schemas/artifacts.js` (add `api_contracts` artifact schema if emitted)
- `src/index/validate.js` (strict validation for new artifact)
- `bin/pairofcleats.js` (CLI wiring: `api-contracts`)
- `docs/contracts/analysis-schemas.md` + `docs/contracts/graph-tools-cli.md` (schema + CLI JSON)

---

### 11.7 Architecture slicing and boundary enforcement (rules + CI-friendly output)

- [x] Add a rules format for architectural constraints over graphs.
  - Rule types (minimum viable):
    - forbidden edges by path glob/module group (importGraph)
    - forbidden call edges by symbol tags or file globs (callGraph)
    - layering rules (optional; best-effort) that detect edges going “up-layer”
  - Outputs:
    - bounded report with counts, top offending edges, and a deterministic ordering
    - CI-friendly JSON (versioned schema)
  - Add reusable module groups:
    - named selector sets referenced by rules

- [x] CLI surface:
  - `pairofcleats architecture-check --repo … --rules <path> --format json|md [--fail-on-violation]`

#### Tests (path-corrected for current test layout)
- [x] `tests/tooling/architecture/forbidden-import-edge.test.js`
  - Fixture with a forbidden import; assert violation is reported deterministically.
- [x] `tests/tooling/architecture/forbidden-call-edge.test.js`
  - Fixture with a forbidden call edge; assert violation is reported deterministically.
- [x] `tests/tooling/architecture/report-is-bounded.test.js`
  - Large fixture triggers caps; assert truncation metadata exists and report remains parseable.
- [x] `tests/tooling/architecture/report-determinism.test.js`
  - Run the same rules twice; assert ordering and output are identical.

Fixture sources:
- `tests/fixtures/tooling/architecture/`

Touchpoints (consolidated; anchors are approximate):
- `src/graph/architecture.js` (new; rule evaluation)
- `src/graph/neighborhood.js` (shared traversal primitives)
- `src/integrations/tooling/architecture-check.js` (new; CLI command implementation)
- `src/contracts/schemas/analysis.js` (add `ARCHITECTURE_REPORT_SCHEMA`)
- `src/contracts/validators/analysis.js` (add `validateArchitectureReport`)
- `bin/pairofcleats.js` (CLI wiring: `architecture-check`)
- `docs/contracts/analysis-schemas.md` + `docs/contracts/graph-tools-cli.md` (schema + CLI JSON)

---

### 11.8 Test selection heuristics (suggest tests impacted by a change set)

- [x] Implement a bounded, deterministic test suggestion tool that uses graphs when available.
  - Identify tests using path conventions and language-aware patterns:
    - `*.test.*`, `*_test.*`, `/tests/`, `__tests__/`, etc.
  - Given a changed set (`--changed <file>` repeated or a file list):
    - map changed files/symbols to seed nodes
    - traverse upstream/downstream within caps
    - rank candidate tests based on witness paths, proximity, and (optional) centrality
  - Output:
    - top-K suggested tests + brief rationale (witness path summary), bounded and deterministic
  - Specify deterministic changed-set → seed derivation:
    - ordering of derived seeds
    - max seeds cap + truncation behavior
  - Define fallback behavior when graph artifacts are missing:
    - heuristic fallback (e.g., path-based test discovery)
    - required warning codes

- [x] CLI surface:
  - `pairofcleats suggest-tests --repo … --changed <...> --max 50 --format json|md`

#### Tests (path-corrected for current test layout)
- [x] `tests/tooling/test-selection/suggest-tests-basic.test.js`
  - Fixture where a changed function is called by a test; assert the test is suggested.
- [x] `tests/tooling/test-selection/suggest-tests-bounded.test.js`
  - Trigger caps; assert truncation metadata is present and ordering is stable.
- [x] `tests/tooling/test-selection/suggest-tests-determinism.test.js`
  - Run the same input twice; assert stable ordering and identical output.
- [x] `tests/tooling/test-selection/suggest-tests-witness-path.test.js`
  - Ensure witness path summary is present and bounded when available.

Fixture sources:
- `tests/fixtures/tooling/suggest-tests/`

Touchpoints (test selection):
- `src/integrations/tooling/suggest-tests.js` (new; core suggestion engine)
- `src/graph/store.js` + `src/graph/neighborhood.js` (shared traversal + loading)
- `bin/pairofcleats.js` (CLI wiring: `suggest-tests`)
- `docs/contracts/analysis-schemas.md` + `docs/contracts/graph-tools-cli.md` (schema + CLI JSON)

---

### 11.9 Docs + CLI wiring

#### 11.9.1 CLI wiring
- [x] Update `bin/pairofcleats.js`:
  - add new commands (graph-context, impact, context-pack, api-contracts, architecture-check, suggest-tests)
  - remove/repair stale `search` flag allowlist validation so wrapper accepts all supported search flags
- [x] Implement per-command handlers under `src/integrations/tooling/`:
  - `graph-context.js`, `impact.js`, `context-pack.js`, `api-contracts.js`, `architecture-check.js`, `suggest-tests.js`

#### 11.9.2 Documentation updates
- [x] Update:
  - `docs/contracts/analysis-schemas.md`
  - `docs/contracts/search-cli.md`
  - `docs/contracts/mcp-api.md`
- [x] Add:
  - `docs/contracts/graph-tools-cli.md`
  - `docs/perf/graph-caps.md`
  - `docs/phases/phase-11/spec.md`

---

### Phase 11 schema summary (authoritative spec: `docs/phases/phase-11/spec.md`)

- Shared types:
  - `NodeRef` (chunk/symbol/file)
  - `ReferenceEnvelope` (resolved/ambiguous/unresolved + bounded candidates)
  - `TruncationRecord` + `WarningRecord` (bounded)
- Graph context pack:
  - `{ version, seed, nodes[], edges[], paths?, truncation?, warnings?, stats? }`
- Impact analysis:
  - `{ version, seed, direction, depth, impacted[], truncation?, warnings? }`
- Composite context pack:
  - `{ version, seed, primary, graph?, types?, risk?, truncation?, warnings? }`
- API contracts report:
  - `{ version, generatedAt, options, symbols[], truncation?, warnings? }`
- Architecture report:
  - `{ version, rules[], violations[], truncation?, warnings? }`
- Suggest-tests:
  - `{ version, changed[], suggestions[], truncation?, warnings? }`


---


## Phase 12 — MCP Migration + API/Tooling Contract Formalization

### Objective
Modernize and stabilize PairOfCleats’ integration surface by (1) migrating MCP serving to the **official MCP SDK** (with a safe compatibility window), (2) formalizing MCP tool schemas, version negotiation, and error codes across legacy and SDK transports, and (3) hardening cancellation/timeouts so MCP requests cannot leak work or hang.

- Current grounding: MCP entrypoint is `tools/mcp-server.js` (custom JSON-RPC framing via `tools/mcp/transport.js`), with tool defs in `src/integrations/mcp/defs.js` and protocol helpers in `src/integrations/mcp/protocol.js`.
- This phase must keep existing tools functioning while adding SDK mode, and it must not silently accept inputs that do nothing.

---

### 12.1 Dependency strategy and capability gating for the official MCP SDK

- [x] Decide how the MCP SDK is provided and make the decision explicit in code + docs.
  - Options:
    - [ ] Dependency (always installed)
    - [x] Optional dependency (install attempted; failures tolerated)
    - [ ] External optional peer (default; capability-probed)
  - [x] Implement the chosen strategy consistently:
    - [x] `package.json` (if dependency/optionalDependency is chosen)
    - [x] `src/shared/capabilities.js` (probe `@modelcontextprotocol/sdk` and report clearly)
    - [x] `src/shared/optional-deps.js` (ensure `tryImport()` handles ESM correctly for the SDK)
  - [x] Define the SDK import path and the capability surface it drives (e.g., `@modelcontextprotocol/sdk` + which subpath).

- [x] Ensure MCP server mode selection is observable and capability-gated.
  - Touchpoints:
    - [x] `tools/mcp-server.js` — entrypoint dispatch
    - [x] `tools/config-dump.js` (or MCP status tool) — report effective MCP mode + SDK availability
    - [x] `docs/config/schema.json` — add `mcp.mode` (legacy|sdk|auto) and `mcp.sdk` capability note
  - [x] Define precedence for MCP mode per `docs/config/surface-directives.md` (CLI > config; env vars only if explicitly allowed as exceptions).
    - [x] If an env override is retained (e.g., `MCP_MODE`), document the exception in `docs/config/contract.md` and surface it in config inventory.

Touchpoints (anchors; approximate):
- `tools/mcp-server.js` (~L4 `getToolDefs`, ~L8 `handleToolCall`, ~L31 `mcpConfig`)
- `src/shared/capabilities.js` (~L7 `getCapabilities`, ~L38 `mcp.sdk`)
- `src/shared/optional-deps.js` (~L22 `tryRequire`, ~L33 `tryImport`)
- `tools/mcp/repo.js` (~L7 `parseTimeoutMs`)
- `tools/config-dump.js` (if used; otherwise define a new MCP status tool under `tools/mcp/`)
  - Reference docs: `docs/api/mcp-server.md`, `docs/phases/phase-12/tooling-and-api-contract.md`

#### Tests / Verification

- [x] Unit: capabilities probe reports `mcp.sdk=true/false` deterministically.
- [x] CI verification: when SDK is absent, SDK-mode tests are skipped cleanly with a structured reason.

---

### 12.2 SDK-backed MCP server (parallel mode with explicit cutover flag)

- [x] Implement an SDK-backed server alongside the legacy transport.
  - Touchpoints:
    - [x] `tools/mcp-server-sdk.js` (new) — SDK-backed server implementation
    - [x] `tools/mcp-server.js` — dispatch `--mcp-mode legacy|sdk` (or env var), defaulting to legacy until parity is proven
      - [x] Add `--mcp-mode` (and `MCP_MODE`) parsing here; bind to `mcp.mode` config.
  - [x] Requirements for SDK server:
    - [x] Register tools from `src/integrations/mcp/defs.js` as the source of truth.
    - [x] Route tool calls to the existing implementations in `tools/mcp/tools.js` (no behavior fork).
    - [x] Support stdio transport as the baseline.
    - [x] Emit a capabilities payload that allows clients to adapt (e.g., doc extraction disabled, SDK missing, etc.).
      - [x] Explicitly define whether this is returned via `initialize` or a separate tool response (see 12.4).

- [x] Add a deprecation window for the legacy transport.
  - [x] Document the cutover plan and timeline in `docs/contracts/mcp-api.md`.
  - [x] Keep legacy transport only until SDK parity tests are green, then remove or hard-deprecate with warnings.

Touchpoints (anchors; approximate):
- `tools/mcp-server.js` (~L4 `getToolDefs`, ~L8 `handleToolCall`; add SDK dispatch flag)
- `tools/mcp-server-sdk.js` (new; SDK wiring)
- `tools/mcp/tools.js` (tool execution entrypoint)
- `src/integrations/mcp/defs.js` (tool definitions + schemaVersion)
  - Reference docs: `docs/api/mcp-server.md`, `docs/phases/phase-12/tooling-and-api-contract.md`

#### Tests / Verification

- [x] Services: `tests/services/mcp/sdk-mode.test.js` (new)
  - Skip if SDK is not installed.
  - Start `tools/mcp-server-sdk.js` and run at least:
    - `tools/list`
    - one representative `tools/call` (e.g., `index_status`)
  - Assert: response shape is valid, errors have stable codes, and server exits cleanly.

---

### 12.3 Tool schema versioning, conformance, and drift guards

- [x] Make tool schemas explicitly versioned and enforce bump discipline.
  - Touchpoints:
    - [x] `src/integrations/mcp/defs.js` — add `schemaVersion` (semver or monotonic integer) and `toolVersion` (package.json)
    - [x] `docs/contracts/mcp-api.md` — document compatibility rules for schema changes
    - [x] `docs/contracts/mcp-tools.schema.json` (new) — canonical tool schema snapshot
    - [x] `src/integrations/mcp/validate.js` (new) — validate tool schemas against snapshot
  - [x] Define the canonical initialize response shape (schema + example).
    - [x] `docs/contracts/mcp-api.md` — `initialize` response structure
    - [x] `docs/contracts/mcp-initialize.schema.json` (new) — schema for response payload

- [x] Consolidate MCP argument → execution mapping to one audited path.
  - Touchpoints:
    - [x] `tools/mcp/tools.js` (search/build tools)
    - [x] `src/integrations/core/index.js` (shared arg builder, if used)
  - [x] Create a single mapping function per tool (or a shared builder) so schema additions cannot be “accepted but ignored”.

- [x] Conformance requirement for the `search` tool:
  - [x] Every field in the MCP `search` schema must either:
    - [x] affect emitted CLI args / search execution, or
    - [x] be removed from schema, or
    - [x] be explicitly marked “reserved” and rejected if set.
  - [x] Avoid duplicative builders (do not maintain two separate lists of flags).

- [x] Fix known MCP tool wiring correctness hazards in modified files:
  - [x] In `tools/mcp/tools.js`, remove variable shadowing that breaks cancellation/AbortSignal handling (numeric arg is now `contextLines`; `context` remains the `{ signal }` object).

Touchpoints (anchors; approximate):
- `src/integrations/mcp/defs.js` (~L1 exports; add `schemaVersion`)
- `tools/mcp/tools.js` (~L? `runSearchTool` / arg mapping)
- `src/integrations/mcp/protocol.js` (error + envelope helpers)
- `docs/contracts/mcp-api.md` (schema versioning rules)

#### Tests / Verification

- [x] Unit: `tests/services/mcp/mcp-schema-version.test.js` (new; keep it in services lane for MCP)
  - Assert `schemaVersion` exists.
  - Assert changes to tool defs require bumping `schemaVersion` (enforced by snapshot contract or explicit check).

- [x] Unit: `tests/services/mcp/mcp-search-arg-mapping.test.js` (new; keep it in services lane for MCP)
  - For each supported schema field, assert mapping produces the expected CLI flag(s).
  - Include a negative test: unknown fields are rejected (or ignored only if policy says so, with an explicit warning).

- [x] Update existing: `tests/services/mcp/mcp-schema.test.js`
  - Keep snapshotting tool property sets.
  - Add schemaVersion presence check.
  - Add toolVersion presence check.
  - Update `docs/contracts/coverage-ledger.md` to include new MCP schema tests.

---

### 12.4 Error codes, protocol negotiation, and response-shape consistency

- [x] Standardize tool error payloads and map internal errors to stable MCP error codes.
  - Touchpoints:
    - [x] `src/integrations/mcp/protocol.js` — legacy transport formatting helpers
    - [x] `tools/mcp/transport.js` — legacy transport handler
    - [x] `tools/mcp-server-sdk.js` — SDK error mapping
    - [x] `src/shared/error-codes.js` — canonical internal codes
  - [x] Define stable, client-facing codes (examples):
    - [x] invalid args
    - [x] index missing
    - [x] tool timeout
    - [x] not supported / capability missing
    - [x] cancelled
  - [x] Add `docs/contracts/mcp-error-codes.md` (or a section in `docs/contracts/mcp-api.md`) defining the canonical MCP error registry.
  - [x] Ensure both transports emit the same logical error payload shape (even if wrapper envelopes differ).

- [x] Implement protocol/version negotiation and expose capabilities.
  - [x] On `initialize`, echo supported protocol versions, the tool schema version, toolVersion, and effective capabilities.
  - [x] Define the authoritative initialize response builder in `src/integrations/mcp/protocol.js`.
  - [x] Define a capabilities schema (or a section in `docs/contracts/mcp-api.md`) with required keys and value semantics.

#### Tests / Verification

- [x] Unit: protocol negotiation returns consistent `protocolVersion` + `schemaVersion`.
- [x] Regression: error payload includes stable `code` and `message` across both transports for representative failures.
  - [x] Add `mcp-mode` selection test (legacy vs sdk) based on CLI/config/env.
  - [x] Add capability payload test for both transports (initialize contains capabilities).
  - [x] Align test path references with `docs/phases/phase-12/test-strategy-and-conformance-matrix.md` (services lane vs `tests/mcp/*`).

Touchpoints (anchors; approximate):
- `src/integrations/mcp/protocol.js` (error payload shaping + initialize response)
- `tools/mcp/transport.js` (legacy transport)
- `tools/mcp-server-sdk.js` (SDK error mapping)
- `src/shared/error-codes.js` (canonical internal codes)

---

### 12.5 Cancellation, timeouts, and process hygiene (no leaked work)

- [x] Ensure cancellation/timeout terminates underlying work within a bounded time.
  - Touchpoints:
    - [x] `tools/mcp/transport.js`
    - [x] `tools/mcp/runner.js`
    - [x] `tools/mcp/tools.js`
  - [x] Cancellation correctness:
    - [x] Canonicalize JSON-RPC IDs for in-flight tracking (`String(id)`), so numeric vs string IDs do not break cancellation.
    - [x] Ensure `$/cancelRequest` cancels the correct in-flight request and that cancellation is observable (result marked cancelled, no “success” payload).
  - [x] Timeout correctness:
    - [x] Extend `runNodeAsync()` to accept an `AbortSignal` and kill the child process (and its process tree) on abort/timeout.
    - [x] Thread AbortSignal through `runToolWithProgress()` and any spawned-node tool helpers.
    - [x] Ensure `withTimeout()` triggers abort and does not merely reject while leaving work running.
  - [x] Progress notification hygiene:
    - [x] Throttle/coalesce progress notifications (max ~1 per 250ms per tool call, coalesced) to avoid overwhelming clients.

- [x] Tighten MCP test process cleanup.
  - [x] After sending `shutdown`/`exit`, explicitly await server process termination (bounded deadline, then kill) to prevent leaked subprocesses during tests.

#### Tests / Verification

- [x] Update existing: `tests/services/mcp/mcp-robustness.test.js`
  - Add “wait for exit” after `exit` (bounded).
  - Add cancellation test:
    - Start a long-ish operation, send `$/cancelRequest`, assert the tool response is cancelled and that work stops (no continuing progress after cancellation).
  - [x] Add progress-throttle assertion (if practical): bursty progress is coalesced.

- [x] Unit: `tests/services/mcp/mcp-runner-abort-kills-child.test.js` (new)
  - Spawn a child that would otherwise run long; abort; assert child exit occurs quickly and no orphan remains.
  - [x] Update `docs/testing/truth-table.md` and `docs/testing/test-decomposition-regrouping.md` to reflect new MCP tests.

---

### 12.6 Documentation and migration notes

- [x] Add `docs/guides/mcp.md` (new) describing:
  - [x] how to run legacy vs SDK server modes
  - [x] how to install/enable the SDK (per the chosen dependency strategy)
  - [x] tool schemas and `schemaVersion` policy
  - [x] stable error codes and cancellation/timeout semantics
  - [x] capability reporting and expected client behaviors
  - [x] Link from `docs/guides/commands.md` (or another index doc) so discoverability is maintained.
  - [x] Update `docs/api/mcp-server.md` to describe legacy + SDK modes and capability reporting.
  - [x] Update `docs/contracts/mcp-api.md` for schemaVersion/toolVersion + error code registry.
  - [x] Ensure `docs/phases/phase-12/tooling-and-api-contract.md` and `docs/phases/phase-12/test-strategy-and-conformance-matrix.md` remain in sync.

**Mapping (source docs, minimal):** `GIGAMAP_FINAL_UPDATED.md` (M12), `GIGAMAP_ULTRA_2026-01-22_FULL_COVERAGE_v3.md` (M12 overlap notes), `CODEBASE_STATIC_REVIEW.md` (MCP schema mapping), `GIGASWEEP.md` (MCP timeout/cancellation/progress/test cleanup)


---


# GIGASWEEP 2

## Phase 0 — Hard failures (repo/CI/scripts break *today*)

### Objective
Make sure the repo’s declared entrypoints (npm scripts + CI workflows) actually exist and run.

- [x] Fix missing tooling file referenced by script-coverage/tests.
  - Symptom: script-coverage references `tools/mergeAppendOnly.js` which does not exist.
  - Touchpoints:
    - `tests/tooling/script-coverage/actions.js` — expects `tools/mergeAppendOnly.js`
    - `docs/tooling/repo-inventory.json` — still lists `merge-append`
  - Action:
    - [x] Add `tools/mergeAppendOnly.js` **or** remove/replace the script-coverage action + scrub inventory docs.

- [x] Fix CI workflow referencing a non-existent npm script.
  - Symptom: `.github/workflows/ci-long.yml` runs `npm run test:ci-long`, but `package.json` has no `test:ci-long`.
  - Touchpoints:
    - `.github/workflows/ci-long.yml`
    - `package.json`
  - Action:
    - [x] Add `test:ci-long` script **or** update workflow to use `node tools/ci/run-suite.js ...`.

- [x] Fix release-check script failing in clean checkout.
  - Symptom: `tools/release-check.js` requires `CHANGELOG.md` which is not present.
  - Touchpoints:
    - `tools/release-check.js`
    - `docs/guides/release-discipline.md`
  - Action:
    - [x] Add `CHANGELOG.md` **or** relax/check conditionally.

- [x] Fix critical-deps validator pointing at the wrong docs directory.
  - Symptom: `tools/validate-critical-deps.js` expects `docs/references/dependency-bundle/*` but repo uses `docs/dependency_references/dependency-bundle/*`.
  - Touchpoints:
    - `tools/validate-critical-deps.js`
    - `docs/dependency_references/dependency-coverage.md`
  - Action:
    - [x] Update expected paths or move docs folder (prefer updating script).

---

## Phase 1 — CLI surface vs docs (major drift)

### Objective
Stop shipping docs that describe commands, endpoints, and flags that don’t exist.

- [x] Implement or de-document the `pairofcleats report ...` command family.
  - Docs reference:
    - `docs/guides/code-maps.md` (`pairofcleats report map`)
    - `docs/benchmarks/evaluation.md` (`pairofcleats report eval`)
    - `docs/benchmarks/model-comparison.md` (`pairofcleats report compare-models`)
    - `docs/guides/repometrics-dashboard.md` (`pairofcleats report repometrics`)
  - Reality:
    - `bin/pairofcleats.js` does **not** implement `report`.
    - Some underlying tools exist (e.g., `tools/report-code-map.js`) but are not routed.
  - Action:
    - [x] Either wire these into `bin/pairofcleats.js` (`report` dispatch) **or**
    - [x] Update docs to use `node tools/...` or `npm run ...`.

- [x] Implement or de-document `pairofcleats sqlite ...`.
  - Docs reference: `docs/sqlite/incremental-updates.md` (`pairofcleats sqlite build --incremental`)
  - Reality: `bin/pairofcleats.js` has no `sqlite` group.
  - Action: wire a `sqlite` command group or change docs to `npm run build-sqlite-index ...`.

- [x] Implement or de-document `pairofcleats service indexer ...`.
  - Docs reference: `docs/guides/service-mode.md` (`service indexer start/status/stop`)
  - Reality: CLI only supports `pairofcleats service api`. `tools/indexer-service.js` exists but is not routed.
  - Action: route `service indexer` or change docs to `npm run indexer-service`.

- [x] Fix broken doc links and API surface claims.
  - `docs/guides/code-maps.md` links to `./api-server.md` which does not exist.
  - Map endpoints described in docs don’t appear in the API router.
  - Action: fix link + reconcile endpoints vs router.

- [x] README drift and missing references.
  - Missing/incorrect references:
    - README references `GIGAROADMAP.md` but file is `GIGAROADMAP_2.md`.
    - README implies a license file exists; none found at repo root.
    - README references scripts not present (e.g., `test:pr`).
  - CLI behavior drift:
    - README lists `--mode code|prose|both`; code supports `code|prose|extracted-prose|records|all`.
    - README references env var `PAIROFCLEATS_DOC_EXTRACT` not implemented (behavior appears config-driven).
    - README mentions backends/flags not supported by `bin/pairofcleats.js` (e.g., `sqlite-fts`, `memory`, `--why` vs `--explain`).
  - Action: reconcile README with current CLI and config reality.

---

## Phase 2 — Config correctness (schema, validation, normalization)

### Objective
Ensure the config file (`.pairofcleats.json`) is:
1) validated correctly, and
2) actually applied by runtime.

#### 2.1 Normalization drops supported keys (user config silently ignored)
- [x] Fix `quality` and `threads` being validated/documented but then silently dropped.
  - Symptoms:
    - `docs/config/schema.json` defines top-level `quality` and `threads`.
    - default config template emits `quality: "auto"`.
    - `tools/dict-utils/config.js` normalization does **not** carry `quality` or `threads` through.
    - Runtime reads `config.quality` (`src/shared/auto-policy.js`) and `userConfig.threads` (`src/shared/runtime-envelope.js`) → user settings never take effect.
  - Action:
    - [x] Pass-through `quality` and `threads` in normalization.
    - [x] Add tests proving config changes behavior (not just schema validation).

#### 2.2 Validator vs schema mismatch (schema features ignored / mis-evaluated)
- [x] Align `docs/config/schema.json` with the actual validator (`src/config/validate.js`) *or* adopt a real JSON Schema validator.
  - Issues observed:
    - Schema uses `anyOf` and union types (e.g., `"type": ["number","null"]`) but validator ignores `anyOf` and mishandles array-`type`.
    - Root `additionalProperties:false` rejects many keys the code expects/normalizes (`sqlite`, `lmdb`, etc.) unless schema is expanded.
    - `tools/generate-demo-config.js` assumes `anyOf/oneOf` exists, reinforcing that the schema is “real JSON Schema”.
  - Action (recommended):
    - [x] Switch to Ajv (or equivalent) and treat `docs/config/schema.json` as authoritative.
    - [x] Add tests for `anyOf` + union types + unknown top-level keys.
  - Alternative (not chosen; Ajv path implemented):
    - Restrict schema to the validator’s supported subset and adjust doc tooling accordingly.

#### 2.3 Additional normalization/validation defects
- [x] Fix conditional drop: `search.sqliteAutoArtifactBytes` is ignored unless `sqliteAutoChunkThreshold` is set.
  - Touchpoint: `tools/dict-utils/config.js` (`sqliteAutoArtifactBytes` parsing is gated on threshold existence).
- [x] Fix `validateConfig()` “required bypass” under `additionalProperties:false`.
  - Touchpoint: `src/config/validate.js` (unknown property is skipped if the key is also in `required`).

#### 2.4 Generated “inventory” docs drift / contract not enforced
- [x] Keep generated docs in sync:
  - `docs/config/inventory.json` vs `docs/config/inventory.md` public flags list mismatch.
  - `docs/guides/commands.md` appears out of sync with its generator.
  - Action:
    - [x] Add CI test: regenerate artifacts and assert no diff.
    - [x] Document the generator command(s) as the single source of truth.

---

## Phase 3 — Path safety / filesystem hardening (high priority)

### Objective
Manifest-driven and output-driven filesystem reads must be safe **regardless of “strict” mode**.

- [x] Always enforce manifest path containment, even in non-strict mode.
  - Findings:
    - `src/index/validate/manifest.js` only validates entry paths when `strict===true`, but still `existsSync()` / hashes resolved paths when non-strict.
    - `src/shared/artifact-io/manifest.js` similarly only enforces safety when strict.
    - `tools/ci-restore-artifacts.js` joins `piece.path` under indexDir without containment checks.
  - Risk: path traversal (`../`) can read outside indexDir if manifest is corrupted/untrusted.
  - Action:
    - [x] Always enforce: no absolute paths, no `..` segments, and resolved path must remain under root.
    - [x] In non-strict mode: downgrade to warnings + skip unsafe entries (but do not read them).

- [x] Fix path safety predicate false-positives.
  - Current logic uses substring `normalized.includes('..')`, which rejects benign strings like `foo..bar`.
  - Action: check path segments for equality to `'..'`.

- [x] Fix output summarization path traversal.
  - `src/retrieval/output/summary.js` uses `path.join(rootDir, chunk.file)` without containment validation.
  - Action: resolve and ensure resulting path remains under `rootDir` before reading.

---

## Phase 4 — Retrieval/search: backend selection, ranking knobs, and flag surface

### Objective
Make search behavior deterministic, debuggable, and aligned with its public CLI surface.

#### 4.1 SQLite FTS auto-enable inconsistency (backend initialization vs downstream usage)
- [x] Fix divergent booleans for FTS enablement.
  - In `src/retrieval/cli.js`, FTS is derived as:
    - `sqliteFtsEnabled = sqliteFtsRequested || (autoBackendRequested && useSqliteSelection)`
  - But `createBackendContext(...)` receives the **original** `sqliteFtsRequested`, while index-loading receives `sqliteFtsEnabled`.
  - Consequences:
    - backend label and required-table checks can behave as “non-FTS” even while pipeline behaves as “FTS enabled”.
    - can cause unnecessary fallback away from SQLite.
  - Action: compute one canonical “FTS enabled” boolean and pass it everywhere.

#### 4.2 Flag surface is far larger than yargs declarations (types/missing-value hazards)
- [x] Declare every consumed `argv.*` option in yargs (or intentionally mark them as “advanced” but still declare them).
  - Current state:
    - ~70+ `argv.*` keys are read in the search path; ~40+ are not declared in yargs.
    - `.strict(false)` means unknown flags are accepted but are not typed/coerced and are absent from `--help`.
  - High-risk cases (missing value → `true`):
    - `--repo` can cause hard throw (`path.resolve(true)`).
    - string filters can silently become `"true"`.
    - numeric knobs can silently become `1` (`Number(true) === 1`) (e.g., `--bm25-k1`, `--modified-since`).
  - Action:
    - [x] Add yargs declarations for all read flags with correct types and `.requiresArg()` where applicable.
    - [x] Expand `getMissingFlagMessages()` beyond `type/author/import` to include “must-have-value” flags.
    - [x] Add tests for missing-value behavior (`--repo`, `--modified-since`, `--bm25-k1`, `--path`, etc.).

- [x] Fix `--context` dead flag.
  - `contextLines` is computed from `argv.context` but not used downstream.
  - Action: wire it to output context, or remove the flag.

- [x] Fix Windows drive-letter token parsing in `--filter`.
  - `parseFilterExpression()` splits on `:`; `C:\...` becomes key `c`.
  - Action: special-case `/^[A-Za-z]:[\\/]/` as a file path token.

- [x] Fix LMDB chunk hydration overwriting valid zeros.
  - `src/retrieval/lmdb-helpers.js` uses falsy checks (`if (!chunk.churn)`) causing `0` to be overwritten.
  - Action: use nullish checks (`== null`).

#### 4.3 Retrieval pipeline safety and determinism
- [x] Propagate abort/cancellation signals into provider calls.
  - Current pattern checks `signal` at boundaries but providers don’t accept/obey it.
- [x] Validate unknown ANN backend strings rather than silently defaulting.
- [x] Add candidate set caps to prevent “candidate explosion” on pathological tokens.
- [x] Document and/or wire search config knobs.
  - Current normalization hard-codes several behaviors (`contextExpansionEnabled=false`, `scoreBlendEnabled=false`, etc.) while docs imply configurability.
  - Many backend config normalizers are called with `{}` (ignoring `userConfig`), limiting real-world configurability.

---

## Phase 5 — SQLite/Tantivy/index build tooling correctness

### Objective
Remove dead code paths, misleading cleanup, and brittle precondition assumptions.

- [x] Clean up SQLite build runner resource handling.
  - `tools/build-sqlite-index/runner.js` treats returned stats as a DB handle and calls `.close()` (swallowed).
  - Unused variables like `hasVectorTableBefore` and wording mismatches in warnings.
  - Action: make return types explicit, remove dead cleanup, fix warnings.

- [x] Improve Tantivy build error messaging and prerequisite checks.
  - `tools/build-tantivy-index.js` assumes artifacts exist and can fail with low-signal errors.
  - Action: explicitly detect required artifacts and print remediation steps.

- [x] Optional doc extraction deps are capability-probed but not declared.
  - `src/shared/capabilities.js` checks `pdfjs-dist`/`mammoth`, but `package.json` doesn’t declare them.
  - Action: either document “install to enable” or move them to `optionalDependencies`.

- [x] Fix unused/leftover build-state variable.
  - `build_index.js` defines `buildStatePath` but doesn’t use it.

---

## Phase 6 — MCP robustness

### Objective
No request should hang without a response; cancellation/timeout semantics should be deterministic.

- [x] Fix tool-call cancellation: ensure a response is emitted even if handler resolves after cancellation.
  - Current behavior: if cancelled flag is set, success path returns without sending a reply.
  - Touchpoints:
    - `tools/mcp/transport.js`
    - tool handlers (e.g., `tools/mcp/tools/handlers/search.js`)
  - Action:
    - [x] On cancellation: send a deterministic “cancelled” response for the original request id.
    - [x] Add a `$ /cancelRequest` test asserting a response always arrives.

---

## Phase 7 — Risk analysis & type inference correctness + tests

### Objective
Fix correctness bugs in local risk detection and close test gaps in type inference.

#### 7.1 Local risk detector correctness gaps
- [x] Fix “taint confidence” bug (reads the wrong field).
  - `src/index/risk.js` uses `entry.confidence` where entries are `{ rule, evidence }`.
  - Action: use `entry.rule.confidence` (or remove if unused).
- [x] Fix rule-id aggregation mismatch in `combineSourceEvidence()`.
- [x] Document/expand assignment heuristics:
  - current parsing skips `=>` and misses destructuring/multi-line patterns.
- [x] Sanitizer matching is overly broad (clears taint if variable name appears on any matching line).

#### 7.2 Risk rules diagnostics shape
- [x] `src/index/risk-rules.js` has an `errors` array that is never used.
  - Action: either classify fatal issues into `errors` or remove it for clarity.

#### 7.3 Interprocedural risk behavior clarity
- [x] Document and surface “timeout ⇒ zero flows” behavior (it’s deterministic and tested but surprising).
- [x] Clarify/verify `taintHints` production wiring (appears optional/dormant in some paths).
- [x] Consider artifact metadata clarity for sharded JSONL (entrypoint is `.meta.json` but format labeled `jsonl`).

#### 7.4 Type inference coverage and unused outputs
- [x] Local type inference exports `aliases` but caller ignores it.
  - Action: remove dead output or wire alias propagation.
- [x] Add unit tests for `src/index/type-inference.js` (cross-file tests exist; local inference is largely untested).

#### 7.5 Cross-file pipeline implementation smells
- [x] Avoid attaching private `_keys` Sets to arrays for dedupe.
  - Action: use local Sets/Maps or a `WeakMap`.
- [x] Layering concern: `src/index/*` importing from `tools/*` may complicate packaging boundaries.
  - Action: route shared helpers through `src/shared/*` wrappers to avoid direct `tools/*` imports.

---

## Phase 8 — Test & drift-guard improvements (prevent recurrence)

### Objective
Turn current failures/drifts into permanent guardrails.

- [x] Add workflow contract coverage for **all** workflows.
  - Current workflow-contract tests cover `ci.yml` but not `ci-long.yml` (which is broken).
- [x] Add “npm scripts target exists” test in PR lane.
  - Catch missing `tools/*.js` targets early (e.g., `mergeAppendOnly.js`).
- [x] Add Markdown link checker test.
  - Catch broken doc links (e.g., `docs/guides/code-maps.md -> api-server.md`).
- [x] Add generator sync tests for doc inventories (`commands.md`, `inventory.md/json`).
- [x] Remove brittle cross-test ordering via marker files in summary-report tests.
  - Replace polling loop with a shared helper or a single orchestrated integration test.

---

## Phase 9 — Tooling and docs hygiene (quality-of-life)

### Objective
Reduce “mystery behavior” and make internal tooling more robust.

- [x] Improve `tools/check-env-usage.js` detection patterns.
  - Currently misses bracket access, destructuring, and other env read patterns.
  - Consider AST-based linting.

- [x] Fix `tools/download-extensions.js` chmod contradiction and improve download safety.
  - `chmod 0755` is immediately overwritten by `chmod 0644`.
  - Archive downloads are buffered in memory without size caps.
  - Consider forcing HTTPS or requiring hashes for HTTP.

- [x] Fix `tools/download-models.js` ONNX copy logic.
  - Current logic checks `!existsSync(onnxTarget)` then calls `statSync(onnxTarget)`, making directory handling dead.
  - Also doesn’t copy when target dir already exists.

- [x] Fix `tools/compare-models.js` index existence probe.
  - Checks only for `chunk_meta.json` and may miss valid indexes in other shapes.

- [x] Tool detection should verify executability, not just filename presence.
  - `tools/tooling-detect.js` should run `--version` before claiming “found”.

- [x] Fix `src/integrations/core/status.js` payload naming ambiguity.
  - `repo.root` appears to report cache root, not repository root.

- [x] Compact/shard tooling scalability:
  - `tools/compact-pieces.js` now streams gzip + zstd JSONL shards.
  - `tools/ctags-ingest.js` backpressure handled.

---

# Appendix A — Sweep coverage (what was reviewed)

This repo was reviewed in multiple sweeps. Below is a high-level list of the file clusters covered (full per-turn lists were provided in the chat):

1) **Project wiring:** `package.json`, root scripts, bin entrypoints, GitHub workflows, core CLI plumbing.
2) **Docs surface:** README, docs guides/contracts/specs, generated inventories, link integrity.
3) **Config system:** schema docs, validator, normalization, demo/template generators.
4) **Install/build tooling:** extensions/models/dicts downloads, indexing builders, CI artifact restore/build scripts.
5) **MCP integration:** protocol/transport, tool handlers, robustness tests.
6) **Index internals:** manifest/path validation, incremental state, locking, map building.
7) **Risk analysis & type inference:** local detector, interprocedural engine, cross-file inference pipeline.
8) **Retrieval/ranking:** sqlite/lmdb/tantivy providers, rankers/scoring knobs, filters, caching, flag surface.

---

# Appendix B — “Highest ROI” patch set (suggested ordering)

If you want a focused sequence that quickly stabilizes the repo:

1) Fix immediate hard failures: missing `tools/mergeAppendOnly.js`, missing `test:ci-long`, `validate-critical-deps` path, `CHANGELOG.md` gate.
2) Fix config normalization dropping `quality` + `threads`.
3) Fix manifest/output path traversal hazards (always enforce containment).
4) Fix SQLite FTS enablement mismatch (auto path).
5) Declare the full search flag surface in yargs and add missing-value tests.
6) Add drift-guards: workflow/script/link/inventory sync tests.
7) MCP cancellation always responds.
8) Clean up SQLite build runner + downloads tooling (chmod + streaming + onnx copy).

---

# Appendix C — Incorrect Findings

- Phase 0: The symptom “npm run merge-append targets a missing file” is stale. The `merge-append` script no longer exists in `package.json`; the missing file issue now stems from script-coverage/tests still referencing `tools/mergeAppendOnly.js` (and repo-inventory docs listing `merge-append`).

---

# AVISPROVOC

## Action items
[x] Inventory tests at tests/ root and all subfolders; build a mapping table (current path -> new path, rename, helper extraction notes).
[x] Define the target taxonomy: subsystem-first folders with feature subfolders; keep unit/integration only as lanes (not as folders).
[x] Create missing top-level folders (runner, smoke, shared) and subsystem feature subfolders (indexing/watch, indexing/imports, retrieval/ann, storage/lmdb, tooling/reports, etc.).
[x] Move all root-level test files into subsystem/feature folders; leave only run.js, run.rules.jsonc, run.config.jsonc, and README.md at tests/ root.
[x] Move runner-related files (all.js, test-runner.js, discovery/reporting helpers) into tests/runner and update their import paths.
[x] Rehome CLI tests into tests/cli/build-index and tests/cli/search subfolders; update references in docs and runner config.
[x] Rehome indexing tests into tests/indexing/<feature> (chunking, watch, ignore, imports, incremental, promotion, embeddings, relations, etc.).
[x] Rehome indexer tests into tests/indexer/<feature> (metav2, sharded-meta, signatures, artifacts, pipeline, service, etc.).
[x] Rehome retrieval tests into tests/retrieval/<feature> (ann, postings, query, ranking, filters, cache, output, explain, etc.).
[x] Rehome storage tests into tests/storage/<backend> (sqlite, lmdb, vector-extension) and keep other storage-related tests adjacent.
[x] Rehome tooling tests into tests/tooling/<feature> (reports, ingest, script-coverage, structural, vscode, doctor, etc.).
[x] Rehome crossfile/type-inference/identity/map/relations/risk tests into the most natural subsystem folder with feature subfolders.
[x] Rename all test files to \*.test.js and ensure helpers remain \*.js; update any references, lists, and docs that mention old names.
[x] Centralize repeated test setup (fixtures, env sync, spawn wrappers, build_index helpers) into tests/helpers; remove duplicated logic in tests.
[x] Create or update shared helpers for common build-index and fixture operations; refactor tests to consume them.
[x] Update tests/run.rules.jsonc lane and tag rules to match new paths; keep unit/integration lanes as tags only.
[x] Update tests/run.config.jsonc, tests/ci/ci.order.txt, tests/ci-lite/ci-lite.order.txt, and tools/test_times/* for the new paths.
[x] Update any docs referencing test paths or layout (README.md, docs guides, AGENTS.md as needed).
[x] Verify helpers/support folders remain excluded in test discovery (excludedDirs) and that tests/shared contains only src/shared tests.
[x] Run test discovery (node tests/run.js --list) and a small smoke subset to validate moves; stop any test > 1 minute and ask you to run it.
[x] Final sweep: confirm no test files remain at tests/ root and no stale paths remain in repo search.
[x] Update AVISPROVOC.md progress log with each batch move, helper extraction, and any conflicts or ambiguities.

---

## Phase 13 — SCM Provider Abstraction (Git Migration) + JJ Provider

### Objective

Make SCM integration **pluggable and explicit** so indexing and incremental workflows can run against:

- Git repos (current default)
- Jujutsu (`jj`) repos (Phase 13 deliverable)
- Non-SCM directories (filesystem-only; reduced provenance but still indexable)

This phase introduces an **SCM provider interface**, migrates all Git behavior onto that interface, then implements a JJ provider using the same contract. The result is a single, coherent place to reason about: tracked file discovery, repo provenance, per-file metadata (churn / blame), and “changed files” queries used by incremental reuse.

Authoritative specs to align with (existing in repo):
- `docs/specs/scm-provider-config-and-state-schema.md`
- `docs/specs/jj-provider-commands-and-parsing.md`
- `docs/specs/scm-provider-contract.md` (to be added in 13.0, or extend the config/state spec)

---

### Exit criteria (must all be true)

- [x] There is a single SCM provider interface used everywhere (no direct `git`/`jj` shelling from random modules).
- [x] `indexing.scm.provider` is supported: `auto | git | jj | none` (default: `auto`).
- [x] Git provider is fully migrated onto the interface and remains the default when `.git/` exists.
- [x] JJ provider supports (at minimum): repo detection, tracked-file enumeration, and repo “head” provenance recorded in `build_state.json`.
- [x] When no SCM is present (or `provider=none`), indexing still works using filesystem discovery, but provenance fields are explicitly `null` / unavailable (no silent lies).
- [x] Build signatures and cache keys include SCM provenance in a **stable** and **portable** way (no locale-dependent sorting).
- [x] Tests cover provider selection + the most failure-prone parsing paths; CI can run without `jj` installed.
- [x] `build_state.json` contract/validator updated to include SCM provider fields and referenced from docs.

---

### Phase 13.0 — Authoritative docs + provider contract + build state schema alignment

- [x] Update authoritative docs that must change with the SCM provider migration:
  - [x] `docs/contracts/indexing.md` (build_state shape + repo provenance + provider semantics)
  - [x] `docs/specs/identity-contract.md` (build signature inputs and stability; provider head must be included)
  - [x] `docs/specs/workspace-config.md` (if it enumerates indexing config keys, update to include `indexing.scm.*`)
  - [x] `docs/config/schema.json` and `docs/config/contract.md` (official config surface + precedence)
  - [x] `docs/guides/commands.md` (new CLI flags introduced in 13.4)

- [x] Add/extend a **provider contract spec**:
  - [x] New: `docs/specs/scm-provider-contract.md` (or extend `docs/specs/scm-provider-config-and-state-schema.md`)
  - Must define:
    - [x] return shapes for all provider APIs
    - [x] required vs optional fields (esp. `head` shape and `dirty` semantics)
    - [x] path normalization rules (repo-relative POSIX paths)
    - [x] detection precedence and fallback behavior
    - [x] capability/skip semantics when binaries are missing
    - [x] decision table for provider selection (`auto|git|jj|none`), including:
      - [x] explicit provider set
      - [x] `.git/` + `.jj/` both present (hard fail)
      - [x] missing binaries / unreadable repo roots
    - [x] buildId/signature provenance rules (how head fields affect buildId)

- [x] Build-state schema contract must be referenced and updated:
  - [x] Add a formal build_state contract + validator (none exists today):
    - [x] `src/contracts/schemas/build-state.js` (new) — JSON schema for build_state.json
    - [x] `src/contracts/validators/build-state.js` (new) — validator + error formatting
    - [x] `src/contracts/registry.js` — register the build_state contract
  - [x] Schema must be **exhaustive**:
    - [x] `repo.provider`, `repo.head`, `repo.dirty`, `repo.root`
    - [x] buildId + signatureVersion + schemaVersion
    - [x] explicit nullability rules for provider=none
  - [x] Ensure `docs/contracts/indexing.md` references the new contract location and examples.
  - [x] Add a migration checklist section (legacy repo.* fields to deprecate/remove and timeline).

Touchpoints:
- `docs/contracts/indexing.md`
- `docs/specs/identity-contract.md`
- `docs/specs/workspace-config.md`
- `docs/specs/scm-provider-config-and-state-schema.md` (or new `docs/specs/scm-provider-contract.md`)
- `docs/config/schema.json`
- `docs/config/contract.md`
- `docs/guides/commands.md`
- `src/contracts/**` (build_state schema + validators)

Touchpoints (anchors; approximate):
- `src/index/build/build-state.js` (~L5 `STATE_FILE`, ~L104 `repoRoot`, ~L133 `repo`)
- `src/index/build/runtime/runtime.js` (~L170 `repoProvenance`, ~L174 `buildId`)
- `src/contracts/registry.js` (~L1 `registry`)

---

### Phase 13.1 — Introduce `ScmProvider` interface + registry + config/state schema wiring

- [x] Create a new module boundary for SCM operations:
  - [x] `src/index/scm/types.js` (new) — shared types and normalized shapes
  - [x] `src/index/scm/provider.js` (new) — interface contract + docs-in-code
  - [x] `src/index/scm/registry.js` (new) — provider selection (`auto|git|jj|none`)
  - [x] `src/index/scm/providers/none.js` (new) — filesystem-only provider (no provenance; uses existing fdir fallback)
  - [x] `src/index/scm/providers/git.js` (new) — migrated in 13.2
  - [x] `src/index/scm/providers/jj.js` (new) — implemented in 13.3

- [x] Add a shared path normalization helper (single source of truth):
  - [x] `src/index/scm/paths.js` (new) — `toRepoPosixPath(filePath, repoRoot)`
  - [x] All providers + tests must use this helper.

- [x] Define the **canonical provider contract** (minimal required surface):
  - [x] `detect({ startPath }) -> { ok:true, repoRoot, provider } | { ok:false }`
  - [x] `listTrackedFiles({ repoRoot, subdir? }) -> { filesPosix: string[] }`
  - [x] `getRepoProvenance({ repoRoot }) -> { provider, root, head, dirty, branch/bookmarks?, detectedBy? }`
  - [x] `getChangedFiles({ repoRoot, fromRef, toRef, subdir? }) -> { filesPosix: string[] }` (may be “not supported” for `none`)
  - [x] `getFileMeta({ repoRoot, filePosix }) -> { churn?, lastCommitId?, lastAuthor?, lastModifiedAt? }` (best-effort; may be disabled)
  - [x] Optional (capability-gated): `annotate({ repoRoot, filePosix, timeoutMs }) -> { lines:[{ line, author, commitId, ... }] }`
  - [x] Define conflict policy:
    - [x] If both `.git/` and `.jj/` exist and no explicit provider is set, **hard fail** with a clear message to choose `--scm-provider`.

- [x] Config keys (align to `docs/specs/scm-provider-config-and-state-schema.md`):
  - [x] `indexing.scm.provider: auto|git|jj|none`
  - [x] `indexing.scm.timeoutMs`, `indexing.scm.maxConcurrentProcesses`
  - [x] `indexing.scm.annotate.enabled`, `maxFileSizeBytes`, `timeoutMs`
  - [x] `indexing.scm.jj.snapshotWorkingCopy` safety default (read-only by default)
  - [x] Define compatibility mapping for legacy git flags:
    - [x] `indexing.gitBlame` / `analysisPolicy.git.blame` -> `indexing.scm.annotate.enabled`
    - [x] document deprecation/precedence and avoid divergent settings
    - [x] No legacy mode: treat the SCM provider contract as authoritative

- [x] Add a mockable SCM command runner:
  - [x] `src/index/scm/runner.js` (new) — wraps spawn/exec with injectable fakes for tests
  - [x] Use it in Git/JJ providers to avoid shelling in unit tests.

- [x] Build-state schema updates:
  - [x] Extend `build_state.json` `repo` field to include:
    - [x] `repo.provider`
    - [x] normalized `repo.head` object (provider-specific fields nested, but stable keys)
    - [x] `repo.dirty` boolean (best-effort)
- [x] Keep Git back-compat fields where feasible (`repo.commit`, `repo.branch`) but treat `repo.provider` + `repo.head.*` as authoritative.
  - [x] Define deterministic buildId/signature rules:
    - [x] buildId uses `<timestamp>_<scmHeadShort>_<configHash8>`
    - [x] `scmHeadShort` comes from provider head primary id:
      - [x] git: commit SHA (short)
      - [x] jj: **changeId** when available, else commitId
    - [x] provider=none uses `noscm` marker (no git/jj fields leaked)

Touchpoints:
- `docs/specs/scm-provider-config-and-state-schema.md` (align / correct examples if needed)
- `src/index/build/build-state.js` (repo provenance shape)
- `src/index/build/indexer/signatures.js` (include SCM provenance in build signatures)
- `src/index/build/runtime/runtime.js` (thread config into runtime)
- `docs/config/schema.json` (document `indexing.scm.*` keys)
- `docs/config/contract.md` (document precedence + deprecations)

Touchpoints (anchors; approximate):
- `src/index/git.js` (~L63 `getGitMetaForFile`, ~L157 `getGitBranch`)
- `src/index/build/preprocess.js` (~L10 `discoverEntries`)
- `src/index/build/indexer/steps/discover.js` (~L34 `discoverFiles`)
- `src/index/build/discover.js` (~L138 `discoverRepoRoots`, ~L176 `listGitFiles`)
- `src/index/build/build-state.js` (~L1 `buildState`)
- `src/index/build/indexer/signatures.js` (~L46 `gitBlameEnabled`)
- `src/index/build/runtime/runtime.js` (~L172 `buildId`, ~L209 `gitBlameEnabled`)

#### Tests / verification (path-corrected for current test layout)
- [x] `tests/indexing/scm/scm-provider-selection.test.js` (new)
  - [x] `auto` selects `git` when `.git/` exists and git is runnable.
  - [x] `auto` selects `jj` when `.jj/` exists and `jj` is runnable.
  - [x] `auto` falls back to `none` when neither exists (or binaries missing).
  - [x] `auto` hard-fails when both `.git/` + `.jj/` exist and no provider is set.
  - [x] use fixture repo roots (`tests/fixtures/scm/git`, `tests/fixtures/scm/jj`, `tests/fixtures/scm/both`) rather than real repos.
- [x] `tests/indexing/scm/build-state-repo-provenance.test.js` (new)
  - [x] `build_state.json` includes `repo.provider` and normalized `repo.head`.
- [x] `tests/indexing/scm/signature-provenance-stability.test.js` (new)
  - [x] build signatures remain stable across locales and include provider head fields.

---

### Phase 13.2 — Migrate Git onto the provider interface

- [x] Implement `GitProvider` by **wrapping and consolidating** existing Git logic:
  - [x] Move/merge logic from:
    - [x] `src/index/git.js` (provenance + meta helpers)
    - [x] `src/index/build/discover.js` (`git ls-files` discovery)
  - [x] Ensure there is exactly one “source of truth” for:
    - [x] repo root resolution
    - [x] tracked file enumeration (`git ls-files -z`)
    - [x] dirty check
    - [x] head SHA + branch name

- [x] Remove direct Git shelling from non-provider modules:
  - [x] `src/index/build/discover.js` should call `ScmProvider.listTrackedFiles()` when an SCM provider is active, else use filesystem crawl (current behavior).
  - [x] Any provenance used for metrics/signatures must route through `ScmProvider.getRepoProvenance()`.
  - [x] Git metadata in file processing must use provider APIs (no direct `getGitMetaForFile` in CPU path).
  - [x] Chunk author attribution must use provider annotate (or explicit disable path when annotate is off).

Touchpoints:
- `src/index/build/discover.js`
- `src/index/git.js` (migrate or reduce to GitProvider internals)
- `src/index/scm/providers/git.js` (new)
- `src/index/scm/registry.js`
- `src/index/build/file-processor/cpu.js` (git meta)
- `src/index/build/file-processor/process-chunks/index.js` (chunk authors)
- `src/index/build/artifacts/metrics.js` (repo provenance)
- `src/index/build/runtime/runtime.js` (buildId uses provider head)
- `src/index/build/indexer/steps/incremental.js` (git meta cache -> provider cache config)

Touchpoints (anchors; approximate):
- `src/index/git.js` (~L69 `getGitMetaForFile`, ~L177 `getRepoProvenance`, ~L216 `computeNumstatChurn`)
- `src/index/build/discover.js` (~L136 `listGitFiles`, ~L176 `gitResult`)
- `src/index/build/preprocess.js` (~L90 `discoverEntries`)
- `src/index/build/indexer/steps/discover.js` (~L34 `discoverFiles`)
- `src/index/build/file-processor/cpu.js` (~L280 `getGitMetaForFile`)
- `src/index/build/file-processor/process-chunks/index.js` (~L411 `getChunkAuthorsFromLines`)
- `src/index/build/artifacts/metrics.js` (~L47 `repoProvenance`)
- `src/index/build/runtime/runtime.js` (~L170 `repoProvenance`, ~L174 `buildId`)
- `src/index/build/indexer/steps/incremental.js` (~L25 `configureGitMetaCache`)
- `src/index/build/runtime/policy.js` (~L18 `git` policy)
- `src/index/build/file-processor.js` (~L440 `gitBlameEnabled` plumbing)

#### Tests / verification (path-corrected for current test layout)
- [x] `tests/indexing/scm/index-build-git-provider.test.js` (new)
  - [x] Build index inside a git repo and assert:
    - [x] `build_state.json.repo.provider === "git"`
    - [x] tracked file discovery returns only git-tracked files (plus explicit records-dir behavior if enabled)
  - [x] annotate metadata is present only when enabled; otherwise explicitly absent with a reason
- [x] `tests/indexing/scm/git-provider-parse.test.js` (new)
  - [x] uses mockable SCM runner for unit coverage of git parsing without requiring git

---

### Phase 13.3 — Implement JJ provider (read-only default, robust parsing)

- [x] Implement `JjProvider` using `jj` CLI (no library dependency):
  - [x] Detection:
    - [x] find `.jj/` root
    - [x] validate `jj --version` runnable (capability gating)
  - [x] Tracked files:
    - [x] `jj file list --tracked -0` (prefer NUL delim where available)
  - [x] Repo provenance:
    - [x] resolve a stable head reference (commitId + changeId where available)
    - [x] record bookmarks (best-effort)
    - [x] `dirty` best-effort (explicitly document semantics)

- [x] Safety default: read-only by default
  - [x] When `indexing.scm.jj.snapshotWorkingCopy=false`:
    - [x] run JJ commands with `--ignore-working-copy` and `--at-op=@` (per spec)
  - [x] If enabled:
    - [x] allow exactly one controlled snapshot at start (and pin subsequent commands to that op)
    - [x] record the pinned op id in build state (so provenance is reproducible)

- [x] Implement changed-files support (for incremental reuse):
  - [x] Provide `getChangedFiles()` based on the spec in `docs/specs/jj-provider-commands-and-parsing.md`.
  - [x] Normalize to **repo-root-relative POSIX paths**.
  - [x] Define deterministic ordering and truncation caps for changed-file outputs.

Touchpoints:
- `docs/specs/jj-provider-commands-and-parsing.md` (align with implementation)
- `src/index/scm/providers/jj.js` (new)
- `src/index/scm/providers/jj-parse.js` (new: isolated parsing helpers)
- `src/index/build/indexer/signatures.js` (include JJ head/changeId + op pin when used)

Touchpoints (anchors; approximate):
- `docs/specs/jj-provider-commands-and-parsing.md` (definitions for `jj file list`, `jj log`, `jj status`)
- `src/index/build/indexer/signatures.js` (~L46 `gitBlameEnabled` placeholder to replace with provider head)

#### Tests / verification (path-corrected for current test layout)
- [x] Unit: parsing helpers
  - [x] `tests/indexing/scm/jj-changed-files-parse.test.js`
  - [x] `tests/indexing/scm/jj-head-parse.test.js`
- [x] `tests/indexing/scm/jj-changed-files-normalization.test.js` (new)
  - [x] ensure paths are POSIX, repo-root-relative, and sorted deterministically.
- [x] CI behavior:
  - [x] JJ parsing tests are self-contained and run without `jj` installed.
  - [x] add explicit lane/tag so JJ tests can be isolated if needed.

---

### Phase 13.4 — CLI + tooling visibility (make SCM selection obvious)

- [x] CLI flags (override config, optional but recommended):
  - [x] `pairofcleats index build --scm-provider <auto|git|jj|none>`
  - [x] `pairofcleats index build --scm-annotate / --no-scm-annotate`

- [x] Surface effective provider + provenance in diagnostics:
  - [x] `pairofcleats tooling doctor --json` should include:
    - provider selected
    - repo root
    - head id(s)
    - whether annotate is enabled

Touchpoints:
- `bin/pairofcleats.js` (flag plumbing)
- `src/shared/cli-options.js` (new flags)
- `tools/tooling-doctor.js` (report SCM provider)

Touchpoints (anchors; approximate):
- `bin/pairofcleats.js` (~L509 `tooling doctor` dispatch, ~L692 `index build` help)
- `src/shared/cli-options.js` (~L4 `INDEX_BUILD_OPTIONS`)
- `tools/tooling-doctor.js` (~L33 `runToolingDoctor`)
- `src/index/tooling/doctor.js` (~L139 `runToolingDoctor`)

---

### Phase 13.5 — Non-repo environments (explicitly supported)

- [x] Make filesystem-only behavior first-class:
  - [x] If `provider=none` (or auto selects none):
    - [x] file discovery uses filesystem crawl (current fallback)
    - [x] build state records `repo.provider="none"` and `repo.head=null`
    - [x] incremental reuse features that require SCM provenance must be disabled with an explicit reason (no silent partial behavior)
    - [x] buildId/signatures use a deterministic "no-scm" marker (do not leak git-specific fields)
- [x] Document this mode as “try it anywhere” for non-code/non-repo folders.

Touchpoints:
- `src/index/scm/providers/none.js` (new)
- `docs/contracts/indexing.md` (document provider="none" behavior)
- `docs/guides/commands.md` (CLI flags and behavior notes)

Touchpoints (anchors; approximate):
- `src/index/build/build-state.js` (~L104 `repoRoot`, ~L133 `repo`)
- `src/index/build/runtime/runtime.js` (~L170 `repoProvenance`, ~L174 `buildId`)
- `src/index/build/discover.js` (~L26 `discoverFiles`, ~L92 `discoverEntries`)

#### Tests / verification
  - [x] `tests/indexing/scm/index-build-no-scm.test.js` (new)
  - [x] Build index in a temp folder without `.git/` and assert build succeeds and provenance is explicitly null.
  - [x] `tests/indexing/scm/no-scm-build-id.test.js` (new)
    - [x] buildId/signatures do not include git/jj fields and remain stable across runs.

---

