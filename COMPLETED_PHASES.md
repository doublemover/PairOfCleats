# Completed Phases 

Any time a phase is fully completed, AFTER it has been merged into main:
  - The numbering and ordering of phases does not matter whatsoever
  - Remove the phase from the current roadmap
  - Append the Title and a brief, single item summary 
  - Some phase numbers are reused 
  - Nothing in this document should be treated as authoritative, refer to code for truth

Completed phase snapshots are archived here after being removed from GIGAROADMAP.md. 

---

- Phase R -- Make Monoliths Modular, My Man

## Phase R -- Refactor MegaCut 

---

### R.0 Refactor playbook (applies to every subtask)

**Goal:** Split “fat” modules into cohesive, testable, side-effect-minimized modules **without changing behavior**.

**Hard rules**
- **No behavior changes** unless explicitly called out in the task’s “Behavior deltas” section.
- **Preserve public entrypoints.** If you move code, keep a tiny compatibility shim at the old path that re-exports the same names.
- **Keep ESM import style** (repo is `"type": "module"`; keep `.js` extensions on relative imports).
- **No new global state**; prefer pure helpers and dependency injection (pass `log`, `signal`, configs, caches).
- **Avoid circular imports** by extracting shared primitives to `src/shared/**` and keeping “leaf” modules free of imports from high-level orchestrators.

**PR checklist**
- [x] New modules have a single responsibility and minimal export surface.
- [x] All call sites updated (or compatibility re-export added).
- [x] All relevant tests pass:
  - `node tests/run.js --lane pr` (preferred) or `npm run test:pr`
  - plus any targeted tests called out per task.
- [x] `npm run lint` passes.
- [x] File sizes: prefer < ~500 LOC for “leaf” modules; orchestrators may be larger but should be mostly glue.

---

### R.1 Script surface policy + docs (package.json sprawl)

**Spec conflict (resolved):** The original Phase R.1 demanded `package.json` scripts be reduced to <10.  
The current repo has already adopted a **policy-based approach** instead:
- `tools/script-inventory.js` generates `docs/tooling/script-inventory.json` and `docs/guides/commands.md`.
- `tests/policy/script-surface-policy.test.js` enforces that the inventory matches `package.json`.

This is a better trade-off than “<10 scripts” because:
- Many scripts are intentionally “debuggable entrypoints” for specific tests/tools.
- The repo has explicit policy + inventory tooling already; rewriting the entire script surface would be noisy and high-churn.

#### R.1.1 Script inventory + policy enforcement
- [x] Keep `tools/script-inventory.js` as the single generator for:
  - `docs/tooling/script-inventory.json`
  - `docs/guides/commands.md`
- [x] Keep `tests/policy/script-surface-policy.test.js` enforcing inventory ↔ package parity.

**Callouts**
- Generator: `tools/script-inventory.js`
- Inventory: `docs/tooling/script-inventory.json`
- Policy test: `tests/policy/script-surface-policy.test.js`

#### R.1.2 Fix doc drift: commands.md must be reproducible
- [x] Resolve the current mismatch where `docs/guides/commands.md` contains a “Phase 3 specs” section that **is not emitted** by `tools/script-inventory.js`.
  - **Best choice:** make `commands.md` purely generated; either:
    1) Update generator to also emit a “Phase specs” section (recommended), or  
    2) Remove the non-generated section from `commands.md` and move it to a separate doc (less ideal; increases doc surface).
- [x] Add a policy test to prevent future drift:
  - New test file: `tests/policy/script-inventory-docs.test.js`
  - It should run the generator in-memory and compare against `docs/guides/commands.md` OR at minimum assert:
    - the “generated by” header is present
    - the “Stable entrypoints” block matches the generator’s output
    - the script table contains the same script names as inventory

**Why option (1) is recommended:**  
The repo already treats `commands.md` as generated. Making the generator responsible for *all* its sections is the only way to keep it deterministic and enforceable.

#### R.1.3 Tighten the “stable entrypoints” contract
- [x] Document (and keep stable) the following script entrypoints:
  - `test`, `test:pr`, `test:nightly`, `lint`, `format`, `config:budget`, `env:check`, `verify`
- [x] Update any user-facing docs / error messages that reference non-stable scripts to prefer:
  - `pairofcleats ...` CLI entrypoints (preferred for users)
  - or `node <script>` for internal tools
- [x] Add a lightweight test that fails if “stable entrypoints” are removed/renamed without updating docs/tooling/script-inventory.json.

---

### R.2 Repo hygiene + drift-proofing

#### R.2.1 AGENTS.md coverage
- [x] Ensure `AGENTS.md` lists the primary docs to read and how to run tests/lint.
- [x] Add an explicit pointer to the script policy docs:
  - `docs/tooling/script-inventory.json`
  - `docs/guides/commands.md`
  - The enforcement test: `tests/policy/script-surface-policy.test.js`

#### R.2.2 Drift-proofing for docs ↔ code contracts
- [x] Keep the existing “policy tests” approach (see `tests/policy/**`) for anything that otherwise drifts silently.

#### R.2.3 Optional: sweep stale files (low-risk cleanup)
- [x] Add a non-destructive report script (no deletions) that inventories:
  - orphan docs (not referenced by any “Docs to read” list)
  - orphan tools (not referenced by any script/CLI)
  - orphan scripts (not referenced by docs/CI/tests)
- Suggested location: `tools/repo-inventory.js`
- Output: `docs/tooling/repo-inventory.json`
- [x] Add a policy test that only checks the file exists + JSON schema sanity (don’t gate PRs on the contents yet).

---

### R.3 Shared primitives (extract early, reuse everywhere)

These have landed and should be used as the canonical helpers.

#### R.3.1 Backoff/retry helper
- [x] `src/shared/retry.js` exports `retryWithBackoff({ attempts, minDelayMs, maxDelayMs, factor, jitter, shouldRetry, operation, signal })`
- [x] Used by `src/index/build/watch/lock.js` to implement `acquireIndexLockWithBackoff(...)`.
- Tests (existing): `tests/watch-lock-backoff.js`

**Follow-up**
- [x] Add a small direct unit test for `retryWithBackoff` itself (optional but improves locality):
  - New: `tests/retry-with-backoff.js`
  - Cover: abort signal, shouldRetry false, jitter bounds, attempts=1 behavior.

#### R.3.2 Debounce scheduler
- [x] `src/shared/scheduler/debounce.js` exports `createDebouncedScheduler({ delayMs, maxDelayMs, onFlush })`
- [x] Used by watch pipeline (via `src/index/build/watch.js`).
- Tests (existing): `tests/watch-debounce.js`

#### R.3.3 Ignore matcher helper (path + chokidar semantics)
- [x] `src/shared/fs/ignore.js` exports `buildIgnoredMatcher({ root, ignoreMatcher })` for chokidar-compatible ignores.
- [x] Add a dedicated test for “directory ignore vs file ignore” semantics:
  - New: `tests/ignore-matcher.js`
  - Cases:
    - ignoreMatcher matches a directory: should ignore descendants (simulate `stats.isDirectory()` true)
    - ignoreMatcher matches a file path: should ignore only that path
    - Windows path normalization (`\` → `/`) must not break matching
  - Import the helper directly from `src/shared/fs/ignore.js`.

#### R.3.4 Filter list merge helper
- [x] `src/shared/filter/merge.js` exports `mergeFilterLists(a, b)`
- [x] Used by `src/retrieval/filters.js` (`mergeExtFilters`, `mergeLangFilters`) and tested via:
  - `tests/lang-filter.js`

---

### R.4 Core indexing + build pipeline refactors

#### R.4.1 Watch pipeline split
- [x] `src/index/build/watch.js` is now an orchestrator that delegates to:
  - `src/index/build/watch/args.js` (args normalization)
  - `src/index/build/watch/chokidar-backend.js` / `polling-backend.js`
  - `src/index/build/watch/watch-event-queue.js`
  - `src/index/build/watch/stability.js` (stability guard)
  - `src/index/build/watch/lock.js` (index lock + backoff)
  - `src/index/build/watch/rebuild.js` (rebuild trigger)
- Tests (existing):
  - `tests/watch-backend-selection.js`
  - `tests/watch-debounce.js`
  - `tests/watch-lock-backoff.js`
  - `tests/watch-stability-guard.js`
  - (plus several watch E2E/atomicity tests)

**Remaining (optional)**
- [x] If `watch.js` grows again, prefer extracting additional “pure helpers” to `src/index/build/watch/*.js` rather than re-introducing large inline blocks. Note this in the docs for watch/build

#### R.4.2 Integrations/core split (spec drift fix)

**Spec drift:** The old roadmap targeted `src/integrations/core/index.js` as a 700+ LOC monolith.  
In the current codebase, `src/integrations/core/index.js` is a tiny re-export facade, and the largest module is now:

- **Current monolith target:** `src/integrations/core/build-index.js` (~735 LOC)

##### R.4.2.1 Keep the facade pattern
- [x] `src/integrations/core/index.js` should remain a small re-export surface for:
  - `buildIndex`, `buildSqliteIndex` (from `build-index.js`)
  - `search` (from `search.js`)
  - `status` (from `status.js`)
- [x] Other integration helpers already live in `src/integrations/core/*.js`

##### R.4.2.2 Split build-index integration logic
- [x] Refactor `src/integrations/core/build-index.js` into a folder:
  - `src/integrations/core/build-index/index.js` (orchestrator; exports `buildIndex`, `buildSqliteIndex`)
  - `src/integrations/core/build-index/progress.js` (overall progress aggregation; current inline “overallProgress” logic)
  - `src/integrations/core/build-index/compatibility.js` (compat key computation)
  - `src/integrations/core/build-index/runtime.js` (runtime bootstrap/teardown helpers)
  - `src/integrations/core/build-index/stages.js` (stage1/stage2 planning + dispatch)
  - `src/integrations/core/build-index/sqlite.js` (the `buildSqliteIndex` implementation)

**Compatibility requirements**
- Keep exports stable from `src/integrations/core/index.js`.
- Keep the existing `buildIndex(repoRoot, options)` and `buildSqliteIndex(repoRoot, options)` signatures intact.

**Callers**
- `bin/pairofcleats.js` (via integration layer)
- `tools/mcp/tools.js` uses `coreBuildIndex` / `coreBuildSqliteIndex`
- Tests that invoke `build_index.js` script (various E2E tests)

**Tests to run**
- `node tests/run.js --match build-index --match index-lock --match watch-atomicity` (minimum)
- `node tests/run.js --lane pr` (recommended)

#### R.4.3 Runtime refactor
- [x] Runtime has been split into:
  - `src/index/build/runtime/config.js`, `policy.js`, `stage.js`, `workers.js`, `hash.js`, etc.
- [x] `src/index/build/runtime/runtime.js` remains large (~680 LOC) but is primarily orchestrator + normalization.

**Optional follow-up**
- [x] Extract “option normalization” helpers from `runtime.js` into `runtime/normalize.js` if `runtime.js` continues to grow.
- [x] Add a unit test for “caps/policy merges” if regressions occu.

#### R.4.4 Validate split
- [x] `src/index/validate.js` delegates to `src/index/validate/*` modules (`manifest`, `sqlite`, `lmdb`, etc.)
- Tests (existing): search for `validate` lane/scripts in `tests/script-coverage` actions.

#### R.4.5 Artifacts build split
- [x] `src/index/build/artifacts.js` delegates into `src/index/build/artifacts/*` (filter-index, postings, bundles, etc.)
- Ensure any new artifact type also updates:
  - `docs/contracts/artifact-contract.md`
  - `src/contracts/schemas/artifacts.js` (if schema is used)
  - relevant validation in `src/index/validate/*`

#### R.4.6 Worker pool split
- [x] Worker pool logic is now under `src/index/build/workers/*`
- `src/index/build/worker-pool.js` is a facade.

#### R.4.7 File processor split (CPU + chunk processing)

**Current state**
- [x] `src/index/build/file-processor/cpu.js` is ~586 LOC and already delegates chunking to:
  - `src/index/build/file-processor/cpu/chunking.js`
- **New monolith candidate:** `src/index/build/file-processor/process-chunks.js` (~650 LOC)

**Plan**
- [x] Keep `cpu.js` as the “single-file CPU orchestration” entrypoint (export `processFileCpu(...)`), but extract:
  - tokenization setup / caching → `cpu/tokenizer.js`
  - AST/tree-sitter analysis pass wrappers → `cpu/analyze.js`
  - metadata v2 enrichment steps → `cpu/meta.js`
  - keep `cpu/chunking.js` as-is

- [x] Split `process-chunks.js` into:
  - `file-processor/process-chunks/index.js` (orchestrator)
  - `file-processor/process-chunks/enrichment.js` (enrich + merge docmeta)
  - `file-processor/process-chunks/dedupe.js` (dedupe + normalization)
  - `file-processor/process-chunks/limits.js` (chunk limits + truncation policy)
  - `file-processor/process-chunks/ids.js` (chunk id assignment + stability rules)

**Callers**
- `src/index/build/indexer/steps/process-files.js`
- any tests building indexes (`tests/e2e-smoke.js`, etc.)

**Tests to run**
- `node tests/run.js --match segment-pipeline --match chunking-limits --match metadata-v2`
- plus at least one full index build smoke (`tests/e2e-smoke.js` or `tests/build-index-all.js` if present)

#### R.4.8 Piece assembly split
- [x] `src/index/build/piece-assembly.js` is still ~500 LOC; helpers exist at `src/index/build/piece-assembly/helpers.js`.

**Remaining extraction (recommended)**
- [x] Extract the IO-heavy loader to `src/index/build/piece-assembly/load.js`
  - Move `loadIndexArtifacts(...)` and any “find pieces / read manifest / read artifacts” logic.
- [x] Extract merge logic to `src/index/build/piece-assembly/merge.js`
  - “merge postings / merge bundles / merge filter index / merge relations” helpers
- [x] Keep `assembleIndexPieces(...)` in `piece-assembly.js` as orchestrator (or move to `piece-assembly/index.js` with a facade).

**Callers**
- `tools/assemble-pieces.js` (CLI tool)
- `tests/contracts/index-compatibility-key-federation-block.test.js`

**Tests to run**
- `node tests/run.js --match compact-pieces --match index-compatibility-key-federation-block`

---

### R.5 Retrieval refactors

#### R.5.1 `filterChunks` split (`src/retrieval/output/filters.js`)

**Current state**
- [x] `src/retrieval/output/filters.js` now delegates to `src/retrieval/output/filters/*` helpers; `filterChunks` remains the orchestrator.
- [x] Candidate selection helpers already extracted:
  - `src/retrieval/output/filters/candidates.js` exports `createCandidateHelpers(...)`
- The file implements:
  - meta filters (`meta.*`, risk fields, etc.)
  - structural filters (`structPack`, `structRule`, `structTag`)
  - file/path/ext/lang prefiltering using `filterIndex` chargrams + roaring bitmaps
  - relation filters (`uses`, `imports`, `calls`) via `fileRelations`

**Specs to follow**
- File prefilter semantics: `docs/guides/search.md` (“File Filter Prefilter (Substring/Regex)”)
- Search filter contract: `docs/contracts/search-contract.md` + `docs/contracts/search-cli.md`
- Structural filter doc: `docs/guides/structural-search.md`

**Public entrypoint**
- Keep: `export function filterChunks(meta, filters = {}, filterIndex = null, fileRelations = null)`

**Callers**
- `src/retrieval/output.js` re-exports it
- `src/retrieval/pipeline.js` calls it
- Many tests import from `src/retrieval/output.js`

**Refactor plan (safe + incremental)**
- [x] **Step 1: fix formatting drift** in `filters.js` (indentation currently broken in destructuring blocks).
- [x] **Step 2: extract pure predicates** to `src/retrieval/output/filters/predicates.js`
  - `matchList`, `matchAny`, `truthy`, and any “normalize list” helpers.
- [x] **Step 3: extract structural matching** to `src/retrieval/output/filters/structural.js`
  - `matchStructural(chunk, { structPack, structRule, structTag })`
  - Must match semantics verified by `tests/structural-filters.js`.
- [x] **Step 4: extract meta matching** to `src/retrieval/output/filters/meta.js`
  - `matchMetaFilters(chunk, metaFilters, riskFilters, options)`
  - Preserve support for:
    - `meta` (k/v string or regex) and `caseMeta`
    - risk selectors: `risk`, `riskTag`, `riskCategory`, `riskSource`, `riskSink`, `riskFlow`
    - inferred types: `inferredType`, `returnType`, `param`
- [x] **Step 5: extract file/path filter evaluation** to `src/retrieval/output/filters/file.js`
  - Build final exact predicate for:
    - `file`/`caseFile` (substring or regex; supports list)
    - `ext`, `lang`
  - Keep **final exact match** always enforced even when prefilter narrows candidates.
- [x] **Step 6: extract file prefilter (chargram/roaring)** to `src/retrieval/output/filters/file-prefilter.js`
  - `collectFilePrefilterMatches({ filterIndex, fileMatchers, caseFile, fileChargramN, roaring })`
  - Must implement doc semantics:
    - longest stable literal from regex; skip if none
    - case-insensitive prefilter; exact match still checks case when `caseFile` is true
- [x] **Step 7: keep filterChunks orchestrator** in `filters.js` (or move to `filters/index.js` and re-export from `filters.js`)
  - It should:
    - normalize filters once
    - construct candidate sets using `createCandidateHelpers`
    - loop candidates and apply exact predicates
    - handle `fileRelations` expansion for `uses/imports/calls` filters

**Tests to run (existing, must pass unchanged)**
- `tests/filter-index.js`
- `tests/filter-strictness.js`
- `tests/filter-structural.js` / `tests/structural-filters.js`
- `tests/file-case-sensitive.js`
- `tests/filters-file.js`
- `tests/lang-filter.js`

*(Search for additional filter tests in `/tests` prefixed with `filter-` and run them too.)*

#### R.5.2 Search CLI split (`src/retrieval/cli.js`)
- [x] `runSearchCli(...)` now delegates inline helpers and run-config normalization to `src/retrieval/cli/*`; `cli.js` is orchestration glue.

**Refactor goal**
- Keep `runSearchCli(...)` export stable (callers: `src/integrations/core/search.js`).
- Reduce `cli.js` to “parse → normalize → run session → render/persist” glue.

**Plan**
- [x] Extract inline helpers inside `runSearchCli` to `src/retrieval/cli/runner.js`:
  - `inferJsonOutputFromArgs`
  - `emitError` / `bail`
  - `throwIfAborted`
- [x] Extract the giant `normalized` destructuring + derived flags into:
  - `src/retrieval/cli/resolve-run-config.js`
  - Return a single `runConfig` object (typed by convention / JSDoc) consumed by `runSearchSession`.
- [x] Keep `src/retrieval/cli.js` as the orchestrator that wires modules together.

**Tests to run**
- `node tests/run.js --match search-cli --match sqlite-fts-eligibility --match search-symbol-boost`

#### R.5.3 Language registry split
- [x] `src/index/language-registry/registry.js` is now small; data lives in `registry-data.js`.
- Ensure any future registry edits update:
  - `src/index/language-registry/registry-data.js`
  - tests that validate language ids / aliases (search for `language-registry` in tests)

#### R.5.4 Search pipeline split (`src/retrieval/pipeline.js`)

**Current state**
- [x] `src/retrieval/pipeline.js` now delegates query-AST, ANN backend normalization, and fusion helpers to `src/retrieval/pipeline/*`.
- `src/retrieval/pipeline.js` still mixes:
  - query-AST phrase checks
  - backend selection (ANN, sqlite FTS, etc.)
  - scoring logic (RRF, blend, symbol boosts, phrase boosts)
  - context-expansion

**Specs to follow**
- `docs/contracts/search-contract.md`
- `docs/guides/search.md`
- `docs/contracts/search-cli.md`

**Public entrypoint**
- Keep: `export function createSearchPipeline(context = {})`

**Callers**
- `src/retrieval/cli/run-search-session.js`
- tests: `tests/search-symbol-boost.js`, `tests/retrieval/sqlite-fts-eligibility.js`, and others

**Refactor plan**
- [x] Extract query-AST helpers to `src/retrieval/pipeline/query-ast.js`
  - move `matchesQueryAst(...)`
  - move `getPhraseMatchInfo(...)`
  - keep the exact signatures to avoid churn
- [x] Extract ANN backend normalization to `src/retrieval/pipeline/ann-backends.js`
  - move `normalizeAnnBackend(...)`, `resolveAnnOrder(...)`
- [x] Extract score fusion to `src/retrieval/pipeline/fusion.js`
  - a pure function that takes ranked sparse list, ranked dense list, config → fused list + breakdowns
  - keep existing behavior: default RRF, optional normalized blending via `search.scoreBlend.*`
- [x] Keep `pipeline.js` as orchestrator:
  - loads providers (BM25, sqlite fts, ann, minhash)
  - delegates to extracted helpers
  - keeps `createSearchPipeline` signature stable

**Tests to run**
- `tests/search-symbol-boost.js`
- `tests/retrieval/sqlite-fts-eligibility.js`
- `tests/search-rrf-parity.js` (if present)
- `tests/search-explain-schema.js` (if present)
- plus `node tests/run.js --lane pr`

#### R.5.5 JSON stream split
- [x] `src/shared/json-stream.js` is a facade over `src/shared/json-stream/*`

#### R.5.6 Filter merge module
- [x] `src/retrieval/filters.js` uses `src/shared/filter/merge.js`

---

### R.6 Tooling & services refactors

#### R.6.1 MCP tool dispatcher split (`tools/mcp/tools.js`)

**Current state**
- [x] `tools/mcp/tools.js` now delegates to `tools/mcp/tools/handlers/*` with a handler map.
- Helpers already extracted to: `tools/mcp/tools/helpers.js`

**Specs to follow**
- Tool defs + schemas are the source of truth:
  - `src/integrations/mcp/defs.js`
- Tests that enforce handler coverage:
  - `tests/mcp/tools-registry.test.js`
  - `tests/mcp/tools-normalize-meta.test.js`

**Public entrypoints (must remain exported)**
- `buildIndex`
- `runSearch`
- `downloadModels`, `downloadDictionaries`, `downloadExtensions`, `verifyExtensions`
- `buildSqliteIndex`, `compactSqliteIndex`
- `cacheGc`, `cleanArtifacts`, `runBootstrap`, `reportArtifacts`
- `triageIngest`, `triageDecision`, `triageContextPack`
- `handleToolCall`
- `normalizeMetaFilters` (re-export)

**Refactor plan**
- [x] Create folder: `tools/mcp/tools/handlers/`
  - `index-status.js` → `indexStatus`, `configStatus` (or keep in `tools/mcp/repo.js` if already there)
  - `indexing.js` → `buildIndex`, `buildSqliteIndex`, `compactSqliteIndex`
  - `search.js` → `runSearch`
  - `downloads.js` → `downloadModels`, `downloadDictionaries`, `downloadExtensions`, `verifyExtensions`
  - `artifacts.js` → `cleanArtifacts`, `reportArtifacts`, `cacheGc`
  - `bootstrap.js` → `runBootstrap`
  - `triage.js` → `triageIngest`, `triageDecision`, `triageContextPack`
- [x] Replace the `handleToolCall` switch with a map:
  - `const TOOL_HANDLERS = new Map([ ['search', runSearch], ... ])`
  - `handleToolCall(name, args, ctx)` looks up handler and throws unknown tool error if missing.
- [x] Update `tests/mcp/tools-registry.test.js` accordingly:
  - Instead of parsing switch cases, assert:
    - every tool name in `getToolDefs({ ... })` has a handler in the map
    - no extra handlers exist for undefined tools

**Compatibility requirements**
- Preserve handler behavior (progress callbacks, env resolution, JSON parsing errors).
- Keep error messages stable enough for tests (if tests assert substrings, keep them).

#### R.6.2 API router split
- [x] `tools/api/router.js` already delegates to `tools/api/router/*`

#### R.6.3 build-embeddings split
- [x] `tools/build-embeddings/run.js` delegates to `tools/build-embeddings/*`

#### R.6.4 build-sqlite-index split
- [x] `tools/build-sqlite-index/run.js` delegates to `tools/build-sqlite-index/*`

#### R.6.5 config-inventory split
- [x] `tools/config-inventory.js` delegates to `tools/config-inventory/*`

#### R.6.6 dict-utils split
- [x] `tools/dict-utils.js` is the public facade; internal helpers live in `tools/dict-utils/*`

---

### R.7 UI refactors

#### R.7.1 Map isometric edge assembly split (`src/map/isometric/client/edges.js`)

**Current state**
- [x] `edges.js` now delegates to `edges/aggregate.js`, `edges/endpoints.js`, `edges/style.js` plus existing helpers.
  - `src/map/isometric/client/edges/resolvers.js` (`createEdgeResolvers`)
  - `src/map/isometric/client/edges/routing.js` (`createRoutingHelpers`)
- Remaining in `edges.js`: aggregation + rendering shape logic.

**Public entrypoint**
- Keep: `export function buildEdges({...})`

**Refactor plan**
- [x] Extract edge aggregation to `src/map/isometric/client/edges/aggregate.js`
  - logic that builds per-edge segments + dedupes
- [x] Extract “endpoint dots” to `src/map/isometric/client/edges/endpoints.js`
- [x] Extract styling/resolution to `src/map/isometric/client/edges/style.js`
  - color/opacity decisions based on selection, hover, depth, etc.
- [x] Keep `edges.js` as orchestrator that wires:
  - resolvers + routing + aggregation + endpoints + style

**Tests (missing today)**
- [x] Add a small unit test suite under `tests/map/edges.test.js`:
  - route helper produces deterministic paths given fixed nodes
  - edge resolver consistently assigns inbound/outbound per node orientation
  - aggregation is stable (same input → same output ordering)

---

### R.8 Post-refactor follow-ups

- [x] Update `docs/guides/architecture.md` if module boundaries materially change (filters/pipeline/tools).
- [x] Update `docs/guides/commands.md` and `docs/tooling/script-inventory.json` if any script entrypoints changed.

---

### R.9 Current monolith snapshot (2026-01-30)

Top refactor candidates by size/complexity (non-generated, behavior-heavy):
1. `src/integrations/core/build-index.js` (~735 LOC) → split per **R.4.2.2**
2. `src/retrieval/cli.js` (~719 LOC) → reduce glue per **R.5.2**
3. `src/index/build/watch.js` (~703 LOC, but already modular) → optional further extraction
4. `src/index/build/runtime/runtime.js` (~683 LOC, mostly orchestrator) → optional normalize split
5. `src/index/build/file-processor/process-chunks.js` (~650 LOC) → split per **R.4.7**
6. `tools/mcp/tools.js` (~650 LOC) → split per **R.6.1**
7. `src/retrieval/pipeline.js` (~638 LOC) → split per **R.5.4**
8. `src/retrieval/output/filters.js` (~570 LOC) → split per **R.5.1**
9. `src/index/build/piece-assembly.js` (~500 LOC) → split per **R.4.8**
10. `src/map/isometric/client/edges.js` (~500 LOC) → split per **R.7.1**

---


## Phase 6 -- Finalization

> **Important:** A meaningful portion of this phase may already be implemented in this repo.  
> Before writing new code, **audit the referenced files/tests** and only add/modify what’s missing or incorrect.

### Goals

1. **Determinism & portability:** VFS virtual paths and “call_sites” output must be stable across runs/OSes.
2. **Artifact correctness:** VFS manifest and metaV2 must be correct, schema-valid, and consistent with post-processing.
3. **Noise reduction:** Improve call/usage heuristics and tokenization so keyword noise is controlled without losing queryability.
4. **CI completeness:** CI lanes must always run schema/validator coverage; long tests must be runnable in a dedicated lane.

---

## 6.0 Audit checklist (do this first)

- [x] Confirm these Phase 6 tests already exist and are green:
  - `tests/vfs/virtual-path-stability.test.js`
  - `tests/vfs/vfs-manifest-roundtrip.test.js`
  - `tests/indexer/call-sites-determinism.test.js`
  - `tests/indexer/metav2-recompute-equivalence.test.js`
- [x] Confirm VFS manifest is actually produced during an index build:
  - Collection: `src/index/build/file-processor/process-chunks.js` → `buildVfsManifestRowsForFile()`
  - State aggregation: `src/index/build/indexer/steps/process-files.js` → `state.vfsManifestRows`
  - Emission: `src/index/build/artifacts/writers/vfs-manifest.js` → `enqueueVfsManifestArtifacts()`
  - Manifest wiring: `src/index/build/artifacts.js` adds piece `vfs_manifest`
- [x] Confirm metaV2 finalization happens *after* any mutation steps:
  - Cross-file inference: `src/index/build/indexer/steps/relations.js` → `runCrossFileInference()` mutates `chunk.docmeta` / `chunk.codeRelations`
  - Finalization: `src/index/build/indexer/steps/write.js` → `finalizeMetaV2({ chunks })` **before** writing artifacts
- [x] Confirm GitHub Actions PR CI runs `ci-lite` (and thus includes contracts + validate coverage):
  - Workflow: `.github/workflows/ci.yml`
  - Test command: `npm run test:ci-lite`
  - Source of truth list: `tests/ci-lite/ci-lite.order.txt`

If any item above is missing, fix it as part of Phase 6 (details below).

---

## 6.1 VFS hardening: stable virtual paths + manifest roundtrip

### 6.1.1 VFS Virtual Path specification (source of truth)

**Primary implementation:** `src/index/tooling/vfs.js`

- `VFS_PREFIX` is `".poc-vfs"`.
- `buildVfsVirtualPath({ containerPath, segmentUid, ext, effectiveExt })` must be:
  - **Pure & deterministic** (same inputs → same output across runs/OS).
  - **Path-safe for LSP/tooling** (no OS separators except `/`).
  - **Stable across host paths**: uses `normalizeRelPath()` and `encodeContainerPath()`:
    - `encodeContainerPath()` base64url-encodes the normalized relative path.
    - `decodeContainerPath()` reverses it.
  - **Segment addressing is explicit**:
    - If `segmentUid` is present: suffix is `"#seg:<segmentUid>"`.
    - Otherwise, no segment suffix.
  - **Extension selection rules**:
    - `effectiveExt` (if non-empty) takes precedence over `ext`.
    - Both are normalized to include a leading dot when present.
    - If neither exists, no extension suffix is added.

**Disk path mapping for tooling (not “virtual path”):**
- `resolveVfsDiskPath({ baseDir, virtualPath })`:
  - Splits the virtual path on `/` into components.
  - Encodes Windows-illegal characters in each component via `encodeURIComponent()` for `[:*?"<>|]`.
  - Joins using `path.sep` and roots at `baseDir`.

The **stable spec** is: *virtual paths are posix-style with `/`, disk paths are OS-safe via escaping.*

---

### 6.1.2 Task: Virtual path stability test

**Test file (must exist and pass):** `tests/vfs/virtual-path-stability.test.js`

**Must validate:**
- [x] Determinism: multiple invocations with identical inputs are string-equal.
- [x] Segment switching: changing `segmentUid` changes output only in the `#seg:` suffix.
- [x] Effective extension: `effectiveExt` overrides `ext`.
- [x] Cross-platform invariants:
  - The returned string always starts with `".poc-vfs/"`.
  - It never contains `\` (backslash), even on Windows.
  - It does not include raw absolute paths.

**Key implementation references:**
- `src/index/tooling/vfs.js`:
  - `buildVfsVirtualPath()`
  - `encodeContainerPath()`, `decodeContainerPath()`
  - `normalizeRelPath()` (imported from `../../shared/paths.js`)

If the existing test doesn’t cover the invariants above, extend it.

---

### 6.1.3 Task: VFS manifest roundtrip test (unsharded + sharded)

**Test file (must exist and pass):** `tests/vfs/vfs-manifest-roundtrip.test.js`

**Manifest schema reference (authoritative):**
- `src/contracts/schemas/artifacts.js` → `vfsManifestRow` schema
- Manifest writer uses:
  - `src/index/build/artifacts/writers/vfs-manifest.js`
  - `VFS_MANIFEST_SCHEMA_VERSION` from `src/index/tooling/vfs.js`

**Roundtrip requirements:**
- [x] **Unsharded mode**: writing `vfs_manifest.jsonl` and reading it back returns identical rows.
- [x] **Sharded mode**: forcing shard split via `maxJsonBytes` writes:
  - `vfs_manifest.meta.json`
  - `vfs_manifest.parts/…`
  - reading back yields the same rows.
- [x] Ordering:
  - Writer sorts rows with `sortVfsManifestRows()` so output is deterministic.
- [x] Row trimming:
  - Writer enforces `MAX_ROW_BYTES` (32 KB). Oversized rows must be trimmed in a deterministic way (`maybeTrimRow()`).

**Key implementation references:**
- Writer: `src/index/build/artifacts/writers/vfs-manifest.js`
  - `createVfsManifestRows()`
  - `sortVfsManifestRows()`
  - `buildManifestRow()` / `maybeTrimRow()`
  - `enqueueVfsManifestArtifacts()`
- Reader: `src/index/tooling/vfs.js`
  - `readVfsManifestRowsFromDisk()`
  - `readVfsManifestFromIndexRoot()`

---

### 6.1.4 Task: Add a minimal VFS disk-path safety test (recommended)

**Why:** `resolveVfsDiskPath()` is used on Windows, macOS, Linux. It must not create illegal filename components.

**New test (add):**
- `tests/vfs/vfs-disk-path-safety.test.js`

**Test cases:**
- [x] A virtual path containing illegal Windows characters in a component (e.g. `":"`, `"*"`, `"?"`, `"|"`) is converted to a disk path where those characters are percent-encoded.
- [x] Returned disk path is under `baseDir` (no traversal).
- [x] `virtualPath` containing `..` as a segment is treated as a literal component (still joined under baseDir), not as traversal.
  - If you consider `..` unsafe, then explicitly encode it or reject it; document the decision and test accordingly.

**Key implementation reference:** `src/index/tooling/vfs.js` → `resolveVfsDiskPath()`.

---

## 6.2 CI coverage: schema validation + clearer CI OS lanes

### 6.2.1 Task: Ensure schema & index validation always run in PR CI

**Goal:** If artifact schemas or validators break, PR CI must fail.

**What must be covered by the PR CI lane (`ci-lite`):**
- [x] **Contract/schema tests** (minimum):
  - `tests/contracts/schema-registry-single-source.test.js`
  - `tests/contracts/public-artifact-surface-doc.test.js`
  - `tests/contracts/artifact-surface-version.test.js`
- [x] **Index validator tests** (minimum):
  - `tests/validate/index-validate-strict.test.js`
  - `tests/validate/index-validate-load-manifest.test.js`
  - `tests/validate/index-validate-missing-pieces.test.js`
  - `tests/validate/index-validate-unknown-piece.test.js`

**Source of truth for what runs in `ci-lite`:**
- `tests/ci-lite/ci-lite.order.txt`  
  CI-lite is special-cased in `tests/run.js` and uses this order file verbatim.

**Acceptance criteria:**
- The list above is present in `ci-lite.order.txt`.
- `npm run test:ci-lite` fails when you intentionally break a schema or validator check.

**Implementation references:**
- Workflow: `.github/workflows/ci.yml`
- Test runner: `tests/run.js` (ci-lite order-file logic)

---

### 6.2.2 Task: Refine GitHub Actions CI job naming and OS coverage

**Workflow file:** `.github/workflows/ci.yml`

**Problems to address:**
- Job name `test` is ambiguous (it is really **Ubuntu**).
- Windows job is named `test-windows` but uses different OS runner (`windows-2022`) than nightly (`windows-latest`).
- macOS is covered in nightly, but not PR CI.

**Required changes:**
- [x] Rename job ids + display names:
  - `test` → `ubuntu`
  - `test-windows` → `windows`
- [x] Add a `macos` job running `npm run test:ci-lite`:
  - Runner: `macos-latest`
  - Keep it blocking if it’s fast enough; otherwise make it non-blocking but visible.
- [x] Align Windows runner choice with nightly unless you have a reason:
  - Prefer `windows-latest` unless a specific toolchain requires `windows-2022`.

**Acceptance criteria:**
- PR CI UI clearly shows `ubuntu`, `windows`, and `macos`.
- All jobs run the same Node version and `npm run test:ci-lite`.

**Related workflow:** `.github/workflows/nightly.yml` (already includes macOS).

---

## 6.3 Determinism + metaV2 correctness after post-processing

### 6.3.1 Task: call_sites determinism test

**Test file (must exist and pass):** `tests/indexer/call-sites-determinism.test.js`

**What the test must guarantee:**
- [x] Two consecutive builds of the same fixture repository produce `call_sites.jsonl` output that is **line-identical**.
- [x] The fixture repo must be stable and self-contained (no network).
- [x] The test must not depend on wall-clock timestamps:
  - Compare content files, not meta `generatedAt` timestamps.

**Key implementation references:**
- Writer: `src/index/build/artifacts/writers/call-sites.js`
  - Determinism is primarily controlled by `sortCallSites(rows)`.
- Call detail production:
  - Call details are stored on `chunk.codeRelations.callDetails`.
  - Cross-file inference may add `targetChunkUid`/`targetDocId`/`targetCandidates`.

If determinism fails on Windows, inspect any path normalization differences and ensure ordering sort keys use normalized file paths (posix style `src/...`) rather than OS paths.

---

### 6.3.2 Task: Ensure metaV2 is finalized after cross-file inference mutations

**Why:** `metaV2` is a “flattened” structure derived from `chunk` + `chunk.docmeta` + `chunk.codeRelations`.  
Cross-file inference **mutates** those, so stale metaV2 would be a correctness bug.

**How it currently must work:**
- First metaV2 build (per-chunk) happens during assembly:
  - `src/index/build/file-processor/assemble.js` → `buildMetaV2(chunk)`
- Mutations happen later:
  - `src/index/build/indexer/steps/relations.js` → `runCrossFileInference()` (calls `applyCrossFileInference()`)
- Final metaV2 rebuild must happen at the end:
  - `src/index/build/indexer/steps/write.js` → `finalizeMetaV2({ chunks })`

**Acceptance criteria:**
- `finalizeMetaV2()` is invoked for every write mode (`code`, `prose`) **after** all mutation steps.
- Any artifact that includes `chunk.metaV2` is written after this finalization.

**Add/extend an integration assertion (recommended):**
- Update `tests/indexing/type-inference/crossfile-output.integration.test.js` to also assert:
  - `buildWidget.metaV2.docmeta.inferredTypes.returns` includes `{ type: "Widget", source: "flow" }`
  - `buildWidget.metaV2.codeRelations.callLinks` includes the link to `createWidget`
  - `buildWidget.metaV2.codeRelations.usageLinks` includes the link to `Widget`
- This specifically catches stale metaV2 after inference.

---

## 6.4 Heuristic noise reduction: reserved words + code dictionaries + token classification

This subsection affects:
- Call/usage extraction in heuristic parsers (C-like, Go, Java, Kotlin, C#, Lua, Perl, PHP, Ruby, Shell, TypeScript).
- Tokenization quality (identifier splitting / keyword noise).

### 6.4.1 Task: Promote per-language reserved word sets to “complete” keyword lists

**Current problem:** the existing `*_CALL_KEYWORDS` and `*_USAGE_SKIP` sets are partial.  
This causes false-positive calls/usages for keywords and builtin type names.

**Primary implementation locations to update:**
- C-like:
  - `src/index/constants.js` → `CLIKE_CALL_KEYWORDS`, `CLIKE_USAGE_SKIP`
- TypeScript:
  - `src/lang/typescript/constants.js` → `TS_CALL_KEYWORDS`, `TS_USAGE_SKIP`, `TS_FLOW_SKIP`
- Others (inline in file):
  - `src/lang/csharp.js` → `CSHARP_CALL_KEYWORDS`, `CSHARP_USAGE_SKIP`
  - `src/lang/go.js` → `GO_CALL_KEYWORDS`, `GO_USAGE_SKIP`
  - `src/lang/java.js` → `JAVA_CALL_KEYWORDS`, `JAVA_USAGE_SKIP`
  - `src/lang/kotlin.js` → `KOTLIN_CALL_KEYWORDS`, `KOTLIN_USAGE_SKIP`
  - `src/lang/lua.js` → `LUA_CALL_KEYWORDS`, `LUA_USAGE_SKIP`
  - `src/lang/perl.js` → `PERL_CALL_KEYWORDS`, `PERL_USAGE_SKIP`
  - `src/lang/php.js` → `PHP_CALL_KEYWORDS`, `PHP_USAGE_SKIP`
  - `src/lang/ruby.js` → `RUBY_CALL_KEYWORDS`, `RUBY_USAGE_SKIP`
  - `src/lang/shell.js` → `SHELL_CALL_KEYWORDS`, `SHELL_USAGE_SKIP`
  - Rust (flow/dataflow only):
    - `src/lang/rust.js` → `RUST_USAGE_SKIP`

**Missing comprehensive reserved-word sets (add these):**
- Objective-C (`src/lang/clike.js` / `src/lang/tree-sitter` usage; no `*_RESERVED_WORDS` yet)
- Swift (`src/lang/swift.js` only has `SWIFT_DECL_KEYWORDS` + tiny skip set)
- C++ (currently only covered implicitly by `CLIKE_RESERVED_WORDS`)
- JavaScript (`src/lang/javascript.js` has no reserved-word set)
- Python (`src/lang/python.js` has no reserved-word set)
- Rust (has `RUST_USAGE_SKIP` only; no full reserved list)
- SQL dialects: Postgres / MySQL / SQLite (`src/lang/sql.js` has no reserved-word sets)
- CSS (`src/lang/css.js` has no reserved-word set)
- HTML (`src/lang/html.js` has no reserved-word set)

**Required refactor (recommended for maintainability):**
- [x] For each language module above, introduce a single exported `*_RESERVED_WORDS` (or `*_KEYWORDS`) set that is the **superset**.
- [x] Define:
  - `*_CALL_KEYWORDS = RESERVED_WORDS ∩ {things that can appear before “(” in syntax but are not calls}`
  - `*_USAGE_SKIP = RESERVED_WORDS ∪ {primitive types, literals, ultra-common words}`  
    (keep it *strictly* a superset to reduce false positives)
- [x] Ensure all sets are:
  - lowercased where language is case-sensitive (except where language semantics require case, e.g., Rust `Self`)
  - sorted in source for readability (alphabetical)
  - have no duplicates

**Acceptance criteria:**
- Fewer false positives in `calls`/`usages` for the targeted languages.
- No existing tests regress.

**Add regression tests (must add):**
- `tests/relations/keyword-skip-heuristics.test.js` (new)

Design:
- For each language that uses regex `\bNAME\s*\(` call extraction, feed a snippet that contains:
  - control structures that look like calls: `if(...)`, `for(...)`, `while(...)`, etc
  - real calls: `foo(...)`, `obj.foo(...)`
- Assert that:
  - control structure keywords are **not** included in `calls`
  - `foo`/`obj.foo` **are** included

Implementation hint:
- Use the existing relation entrypoints:
  - C-like: `src/lang/clike.js` exports `buildCLikeRelations` (or equivalent; see file exports)
  - Go: `buildGoRelations(...)` or the module export that returns `{ calls, usages }`
  - etc.

If you don’t have a clean exported function, test the internal `collect*CallsAndUsages()` functions directly.

---

### 6.4.2 Task: Per-language “code dictionaries” for identifier segmentation

**Goal:** Improve identifier splitting (e.g., `HTTPRequest` → `http` + `request`, `userID` → `user` + `id`)  
**without changing core scoring/ranking logic** (only segmentation quality).

**Current segmentation engine:** `src/shared/tokenize.js`
- `splitWordsWithDict(token, dictWords, config)` is already used by:
  - index-time tokenization: `src/index/build/tokenization.js`
  - query-time tokenization: `src/retrieval/query.js`

**Proposed design:**
- [x] Add a second dictionary source: **code dictionaries**, separate from natural-language dictionaries.
- [x] Code dictionaries are loaded, and applied only when tokenizing code (index mode `code`).
- [x] Provide:
  - `common-code.txt` (shared abbreviations): `http`, `url`, `uuid`, `json`, `yaml`, `html`, `css`, `sql`, `api`, `cli`, `ui`, `db`, `rpc`, `grpc`, `tls`, `ssl`, `jwt`, `oauth`, etc.
  - Per-language additions: `go.txt`, `java.txt`, `typescript.txt`, etc.

**Where to implement:**
- Dictionary path discovery:
  - Extend `tools/dict-utils/paths/dictionaries.js` (or add sibling `code-dictionaries.js`)
  - Add config shape to `tools/dict-utils/config/schema` (if present) or document it in roadmap.
- Runtime load:
  - `src/index/build/runtime/runtime.js` → `loadDictionaryWords(...)` currently loads `dictWords`
  - Add `codeDictWords` and/or `codeDictWordsByLanguage`
- Tokenization:
  - `src/index/build/tokenization.js`:
    - When `mode === "code"`, pass a dictionary set that unions:
      - natural dict words (`dictWords`)
      - common code dict
      - effective-language-specific code dict (if any)
  - Ensure worker tokenization has access too:
    - `src/index/build/workers/indexer-worker.js` uses `createTokenizationContext()`

**Acceptance criteria:**
- Turning on code dictionaries improves segmentation for representative identifiers.
- Prose segmentation is unaffected unless explicitly configured.

**Add tests (must add):**
- `tests/tokenize-code-dictionaries.test.js` (new)
  - Verify that with a code dictionary containing `http` and `request`, `HTTPRequest` splits to include `http` and `request`.
  - Verify that with code dictionaries disabled, splitting falls back to existing behavior.

---

### 6.4.3 Task: Token classification (keyword vs identifier vs operator) + weighting

**Goal:** Keep keywords/operators searchable but reduce their ranking impact (keyword-noise control).

**Core requirements:**
- [x] Add classification for code tokens into at least:
  - `identifier`
  - `keyword`
  - `operator`
  - `literal` (numbers/strings)
- [x] Use Tree-sitter token/node types when available, **fallback** to keyword lists only when necessary.
  - Tree-sitter config: `src/lang/tree-sitter/config.js` lists supported `TREE_SITTER_LANGUAGE_IDS`.
- [x] Keep keywords indexable but **down-weight** them relative to identifiers.

#### Proposed implementation strategy (fits current architecture)

**A) Extend tokenization output to carry typed token buckets**
- Modify `src/index/build/tokenization.js`:
  - Currently returns `{ tokens, frequencies, positions, totalTokens }`
  - Extend to also return:
    - `identifierTokens` (array)
    - `keywordTokens` (array)
    - `operatorTokens` (array)
  - `tokens` should continue to exist for backward compatibility (initially keep it as the union).

**B) Feed typed buckets into `fieldTokens`**
- Modify `src/index/build/file-processor/assemble.js` `buildChunkPayload()`:
  - Currently sets `fieldTokens = { name, signature, doc, comment, body }`
  - Add new fields:
    - `fieldTokens.keyword = keywordTokens`
    - `fieldTokens.operator = operatorTokens`
  - Decide what `body` should contain:
    - **Recommended final shape:** `body = identifierTokens` only
    - But do this behind a config flag for compatibility (see below).

**C) Build field postings for new token fields**
- Modify `src/index/build/state.js`:
  - `fieldPostings` currently has `name`, `signature`, `doc`, `comment`, `body`.
  - Add `keyword` and `operator` maps (or make this dynamic by iterating keys from `chunk.fieldTokens`).
- Ensure `src/index/build/postings.js` writes `field_postings.json` with the additional fields.

**D) Retrieval: add default weights for new fields**
- Modify `src/retrieval/query-intent.js`:
  - Extend `DEFAULT_FIELD_WEIGHTS` to include:
    - `keyword`: small weight (e.g., 0.15–0.35)
    - `operator`: tiny weight (e.g., 0.05) or 0 (indexable but not scoring)
- Ensure `src/retrieval/pipeline.js` still operates if these fields are missing (older index).

**E) Compatibility plan**
- Add config flag (suggested):
  - `indexing.postings.tokenClassification.enabled` (default: `false` initially)
- When disabled:
  - Keep current behavior: `body = tokens` (union), no new fields required.
- When enabled:
  - `body = identifierTokens`
  - `keyword`/`operator` fields populated and weighted.

**Acceptance criteria:**
- Queries with only identifiers behave the same or better.
- Queries that are mostly keywords (e.g., `async await`) still return results, but keyword-only matches don’t dominate ranking.

**New tests (must add):**
1. `tests/tokenization/token-classification-tree-sitter.test.js`
   - Feed a small snippet in a Tree-sitter-supported language (e.g., JS or Go).
   - Assert that tokens are classified as expected:
     - identifiers go to `identifierTokens`
     - `if`, `for`, `return` go to `keywordTokens`
     - `=>`, `.`, `::`, `(`, `)` go to `operatorTokens` (depending on which operators you choose to index)
2. `tests/retrieval/keyword-downweighting.test.js`
   - Build a tiny synthetic index with two chunks:
     - Chunk A: many keyword tokens, few identifiers
     - Chunk B: fewer keywords, matching identifiers
   - Query for identifiers + keyword; assert chunk B ranks above A when classification is enabled.

---

## 6.5 CI-Long lane: isolate long-running tests

### 6.5.1 Task: Create a “CI-Long” lane that runs only tests tagged `long`

**Why:** Long tests slow PR feedback; they belong in scheduled/nightly lanes.

**Source of truth for “long”:**
- Tag rules in `tests/run.rules.jsonc` under `"tagRules"` include tag `"long"`.

**Required changes (recommended design: lane alias)**
- [x] Update `tests/run.rules.jsonc`:
  - Add `"ci-long"` to `"knownLanes"`.
- [x] Update `tests/run-discovery.js` `resolveLanes()`:
  - Treat `ci-long` the same as `ci` (expand to `unit`, `integration`, `services`).
- [x] Update `tests/run.js`:
  - When lane `ci-long` is requested, automatically add `--tag long` (as if user passed it).
  - Ensure `--exclude-tag` still works as expected.
- [x] Add npm script in `package.json`:
  - `"test:ci-long": "node tests/run.js --lane ci-long"`
- [x] Add a GitHub Actions workflow lane/job (choose one):
  - **Option A:** Add to `.github/workflows/nightly.yml` (best): run `npm run test:ci-long` on all OSes.
  - **Option B:** Add a separate scheduled workflow `.github/workflows/ci-long.yml`.

**Acceptance criteria:**
- `npm run test:ci-long` runs **only** tests tagged `long`.
- PR CI remains fast (ci-lite).
- Nightly (or scheduled) runs include ci-long.

**Implementation references:**
- Tags/lane system:
  - `tests/run.rules.jsonc`
  - `tests/run-discovery.js`
  - `tests/run.js`

---

## Appendix: Suggested “complete” reserved word lists (copy/paste seeds)

> These are intended as **seed lists** to prevent having to web-search during implementation.  
> Prefer Tree-sitter classification where possible, but keep these sets for heuristic parsers.

### JavaScript / TypeScript (seed keywords)
```
await break case catch class const continue debugger default delete do else enum export extends false finally for function if import in instanceof new null return super switch this throw true try typeof var void while with yield let
as implements interface package private protected public static
any boolean bigint number object string symbol unknown never
keyof readonly infer satisfies asserts is require namespace module type from of get set constructor declare abstract override
```

### C / C++ (seed keywords)
```
auto break case char const continue default do double else enum extern float for goto if inline int long register restrict return short signed sizeof static struct switch typedef union unsigned void volatile while
_Alignas _Alignof _Atomic _Bool _Complex _Generic _Imaginary _Noreturn _Static_assert _Thread_local
alignas alignof and and_eq asm bitand bitor bool catch char8_t char16_t char32_t class compl concept const_cast consteval constexpr constinit co_await co_return co_yield decltype delete dynamic_cast explicit export false friend import module mutable namespace new noexcept not not_eq nullptr operator or or_eq private protected public reinterpret_cast requires static_assert static_cast template this thread_local throw true try typeid typename using virtual wchar_t xor xor_eq final override
```

### Go (seed keywords + predeclared)
```
break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var
nil true false iota
append cap close complex copy delete imag len make new panic print println real recover
bool byte complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr any
```

### Java (seed)
```
abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while
true false null
var record yield sealed permits non-sealed
module open requires exports opens to uses provides with transitive
```

### Kotlin (seed)
```
as as? break class continue do else false for fun if in !in interface is !is null object package return super this throw true try typealias val var when while
by catch constructor delegate dynamic field file finally get import init param property receiver set setparam where
actual abstract annotation companion const crossinline data enum expect external final infix inline inner internal lateinit noinline open operator out override private protected public reified sealed suspend tailrec vararg value
```

### C# (seed)
```
abstract as base bool break byte case catch char checked class const continue decimal default delegate do double else enum event explicit extern false finally fixed float for foreach goto if implicit in int interface internal is lock long namespace new null object operator out override params private protected public readonly ref return sbyte sealed short sizeof stackalloc static string struct switch this throw true try typeof uint ulong unchecked unsafe ushort using virtual void volatile while
add alias ascending async await by descending dynamic equals from get global group into join let nameof on orderby partial remove select set value var when where yield record init with
```

### Lua (seed)
```
and break do else elseif end false for function goto if in local nil not or repeat return then true until while
```

### PHP (seed)
```
__halt_compiler abstract and array as break callable case catch class clone const continue declare default die do echo else elseif empty enddeclare endfor endforeach endif endswitch endwhile eval exit extends final finally fn for foreach function global goto if implements include include_once instanceof insteadof interface isset list match namespace new or print private protected public readonly require require_once return static switch throw trait try unset use var while xor yield yield from
true false null
```

### Ruby (seed)
```
BEGIN END alias and begin break case class def defined? do else elsif end ensure false for if in module next nil not or redo rescue retry return self super then true undef unless until when while yield
__FILE__ __LINE__ __ENCODING__
```

### Shell (bash/sh seed)
```
if then else elif fi for while until do done case esac in select function time coproc
break continue return exit shift eval exec trap wait local declare typeset readonly export set unset source
true false
```

### Perl (seed)
```
my our use sub package if elsif else unless while until for foreach continue do given when default
next last redo goto return
BEGIN END INIT CHECK UNITCHECK
die warn print say
```

---

