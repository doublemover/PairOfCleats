diff -ruN a/src/lang/css.js b/src/lang/css.js
--- a/src/lang/css.js	2026-01-16 16:26:57.000000000 +0000
+++ b/src/lang/css.js	2026-01-16 17:03:01.314758600 +0000
@@ -1,6 +1,7 @@
 import { buildLineIndex, offsetToLine } from '../shared/lines.js';
 import { extractDocComment, sliceSignature } from './shared.js';
 import { getTreeSitterParser } from './tree-sitter.js';
+import { treeSitterState } from './tree-sitter/state.js';
 import { getNamedChild, getNamedChildCount } from './tree-sitter/ast.js';
 
 const RULE_NODES = new Set([
@@ -97,6 +98,21 @@
     } catch {
       // ignore disposal failures
     }
+
+    // Some tree-sitter builds retain internal parse stack allocations across parses.
+    // Cleanup keeps memory bounded across long-running indexing jobs (especially on Windows).
+    try {
+      if (process.platform === 'win32') {
+        if (parser && typeof parser.delete === 'function') parser.delete();
+        if (treeSitterState.sharedParser === parser) treeSitterState.sharedParser = null;
+        treeSitterState.sharedParserLanguageId = null;
+        treeSitterState.parserCache?.clear?.();
+      } else if (parser && typeof parser.reset === 'function') {
+        parser.reset();
+      }
+    } catch {
+      // ignore cleanup failures
+    }
   }
 }
 
diff -ruN a/src/lang/tree-sitter/chunking.js b/src/lang/tree-sitter/chunking.js
--- a/src/lang/tree-sitter/chunking.js	2026-01-16 16:26:57.000000000 +0000
+++ b/src/lang/tree-sitter/chunking.js	2026-01-16 16:58:44.017622361 +0000
@@ -26,6 +26,51 @@
 
 const JS_TS_LANGUAGE_IDS = new Set(['javascript', 'typescript', 'tsx', 'jsx']);
 
+const DEFAULT_PARSER_CLEANUP_MODE = process.platform === 'win32' ? 'hard' : 'soft';
+
+function resolveParserCleanupMode(options) {
+  const cfg = options?.treeSitter || {};
+  const raw = cfg.parserCleanup ?? cfg.parserReset ?? cfg.resetParser ?? cfg.parserResetMode;
+  const normalized = typeof raw === 'string' ? raw.trim().toLowerCase() : raw;
+  if (normalized === false || normalized === 0
+    || normalized === 'none' || normalized === 'off'
+    || normalized === 'disabled' || normalized === 'disable') {
+    return 'none';
+  }
+  if (normalized === 'hard' || normalized === 'recreate' || normalized === 'delete') return 'hard';
+  if (normalized === true || normalized === 'soft' || normalized === 'reset') return 'soft';
+  return DEFAULT_PARSER_CLEANUP_MODE;
+}
+
+function cleanupParserAfterParse(parser, options) {
+  const mode = resolveParserCleanupMode(options);
+  if (mode === 'none') return;
+  if (mode === 'soft') {
+    try {
+      if (parser && typeof parser.reset === 'function') parser.reset();
+    } catch {
+      // ignore
+    }
+    return;
+  }
+
+  // Hard reset: drop the shared parser instance to release native/WASM allocations.
+  try {
+    if (parser && typeof parser.delete === 'function') parser.delete();
+  } catch {
+    // ignore
+  }
+  if (treeSitterState.sharedParser === parser) {
+    treeSitterState.sharedParser = null;
+  }
+  treeSitterState.sharedParserLanguageId = null;
+  try {
+    treeSitterState.parserCache?.clear?.();
+  } catch {
+    // ignore
+  }
+}
+
 function resolveTraversalBudget(options, resolvedId) {
   const config = options?.treeSitter || {};
   const perLanguage = config.byLanguage?.[resolvedId] || {};
@@ -390,13 +435,9 @@
     }
 
     // Some tree-sitter builds retain internal parse stack allocations across parses.
-    // Resetting keeps memory bounded across long-running indexing jobs.
-    try {
-      const parserRef = treeSitterState?.parserCache?.get?.(resolvedId);
-      if (parserRef && typeof parserRef.reset === 'function') parserRef.reset();
-    } catch {
-      // ignore reset failures
-    }
+    // Ensure we release parser-side allocations between parses to avoid V8 'Zone' OOMs
+    // in long-running indexing jobs (especially on Windows).
+    cleanupParserAfterParse(parser, options);
   }
 }
 
diff -ruN a/src/lang/tree-sitter/runtime.js b/src/lang/tree-sitter/runtime.js
--- a/src/lang/tree-sitter/runtime.js	2026-01-16 16:26:57.000000000 +0000
+++ b/src/lang/tree-sitter/runtime.js	2026-01-16 17:01:18.598117174 +0000
@@ -1,6 +1,7 @@
 import fs from 'node:fs/promises';
 import os from 'node:os';
 import path from 'node:path';
+import { pathToFileURL } from 'node:url';
 import { createRequire } from 'node:module';
 import { LANGUAGE_WASM_FILES, TREE_SITTER_LANGUAGE_IDS } from './config.js';
 import { treeSitterState } from './state.js';
@@ -132,14 +133,29 @@
     }
     try {
       const wasmPath = path.join(resolveWasmRoot(), wasmFile);
-      // Prefer path-based loading to avoid retaining large WASM buffers in JS.
-      // (Some web-tree-sitter builds accept a file path.)
+      // Prefer URL/path based loading to avoid retaining large WASM buffers in JS.
+      // Different web-tree-sitter builds accept either a file:// URL or a filesystem path.
       let language;
+      const wasmUrl = (() => {
+        try {
+          return pathToFileURL(wasmPath).href;
+        } catch {
+          return null;
+        }
+      })();
       try {
-        language = await treeSitterState.TreeSitterLanguage.load(wasmPath);
+        language = await treeSitterState.TreeSitterLanguage.load(wasmUrl || wasmPath);
       } catch {
-        const wasmBytes = await fs.readFile(wasmPath);
-        language = await treeSitterState.TreeSitterLanguage.load(wasmBytes);
+        try {
+          language = await treeSitterState.TreeSitterLanguage.load(wasmPath);
+        } catch {
+          const wasmBytes = await fs.readFile(wasmPath);
+          const wasmArrayBuffer = wasmBytes.buffer.slice(
+            wasmBytes.byteOffset,
+            wasmBytes.byteOffset + wasmBytes.byteLength
+          );
+          language = await treeSitterState.TreeSitterLanguage.load(wasmArrayBuffer);
+        }
       }
       const entry = { language, error: null };
       treeSitterState.languageCache.set(resolvedId, entry);
