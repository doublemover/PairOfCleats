diff --git a/src/index/build/runtime/runtime.js b/src/index/build/runtime/runtime.js
index 73d9819..461ac15 100644
--- a/src/index/build/runtime/runtime.js
+++ b/src/index/build/runtime/runtime.js
@@ -163,6 +163,7 @@ export async function createBuildRuntime({ root, argv, rawArgv }) {
     treeSitterByLanguage,
     treeSitterPreload,
     treeSitterPreloadConcurrency,
+    treeSitterMaxLoadedLanguages,
     treeSitterWorker
   } = resolveTreeSitterRuntime(indexingConfig);
   const sqlConfig = userConfig.sql || {};
@@ -328,6 +329,7 @@ export async function createBuildRuntime({ root, argv, rawArgv }) {
       treeSitterLanguages,
       treeSitterPreload,
       treeSitterPreloadConcurrency,
+      treeSitterMaxLoadedLanguages,
       log
     });
   }
@@ -451,6 +453,7 @@ export async function createBuildRuntime({ root, argv, rawArgv }) {
       byLanguage: treeSitterByLanguage,
       preload: treeSitterPreload,
       preloadConcurrency: treeSitterPreloadConcurrency,
+      maxLoadedLanguages: treeSitterMaxLoadedLanguages,
       worker: treeSitterWorker
     },
     resolveSqlDialect,
diff --git a/src/index/build/runtime/tree-sitter.js b/src/index/build/runtime/tree-sitter.js
index 82b1c37..21ad47a 100644
--- a/src/index/build/runtime/tree-sitter.js
+++ b/src/index/build/runtime/tree-sitter.js
@@ -8,6 +8,27 @@ import {
   normalizeTreeSitterByLanguage
 } from './caps.js';
 
+const normalizePreloadMode = (raw) => {
+  if (raw === true) return 'parallel';
+  if (raw === false || raw === undefined || raw === null) return 'none';
+
+  if (typeof raw === 'number') {
+    if (raw === 0) return 'none';
+    if (raw === 1) return 'serial';
+  }
+
+  if (typeof raw === 'string') {
+    const v = raw.trim().toLowerCase();
+    if (!v) return 'none';
+    if (['none', 'off', 'false', '0', 'no', 'disabled'].includes(v)) return 'none';
+    if (['serial', 'seq', 'sequential'].includes(v)) return 'serial';
+    if (['parallel', 'par'].includes(v)) return 'parallel';
+  }
+
+  // Safe default: avoid eager preloading unless explicitly requested.
+  return 'none';
+};
+
 export const resolveTreeSitterRuntime = (indexingConfig) => {
   const treeSitterConfig = indexingConfig.treeSitter || {};
   const treeSitterEnabled = treeSitterConfig.enabled !== false;
@@ -19,13 +40,20 @@ export const resolveTreeSitterRuntime = (indexingConfig) => {
     treeSitterConfig.byLanguage || {}
   );
   const treeSitterConfigChunking = treeSitterConfig.configChunking === true;
-  const treeSitterPreloadRaw = typeof treeSitterConfig.preload === 'string'
-    ? treeSitterConfig.preload.trim().toLowerCase()
-    : (treeSitterConfig.preload === true ? 'parallel' : '');
-  const treeSitterPreload = treeSitterPreloadRaw === 'parallel' ? 'parallel' : 'serial';
+
+  // IMPORTANT: Tree-sitter WASM grammar loading can consume non-trivial memory.
+  // Default to *on-demand* loading rather than preloading every enabled grammar.
+  const treeSitterPreload = normalizePreloadMode(treeSitterConfig.preload);
   const treeSitterPreloadConcurrency = normalizeOptionalLimit(
     treeSitterConfig.preloadConcurrency
   );
+
+  // Optional cap for the number of loaded WASM grammars retained in memory.
+  // When null, the tree-sitter runtime will use its conservative internal defaults.
+  const treeSitterMaxLoadedLanguages = normalizeOptionalLimit(
+    treeSitterConfig.maxLoadedLanguages
+  );
+
   return {
     treeSitterEnabled,
     treeSitterLanguages,
@@ -36,6 +64,7 @@ export const resolveTreeSitterRuntime = (indexingConfig) => {
     treeSitterByLanguage,
     treeSitterPreload,
     treeSitterPreloadConcurrency,
+    treeSitterMaxLoadedLanguages,
     treeSitterWorker: treeSitterConfig.worker || null
   };
 };
@@ -45,16 +74,23 @@ export const preloadTreeSitterRuntimeLanguages = async ({
   treeSitterLanguages,
   treeSitterPreload,
   treeSitterPreloadConcurrency,
+  treeSitterMaxLoadedLanguages,
   log
 }) => {
   if (!treeSitterEnabled) return;
+  if (treeSitterPreload === 'none') return;
+
   const enabledTreeSitterLanguages = resolveEnabledTreeSitterLanguages({
     enabled: treeSitterEnabled,
     languages: treeSitterLanguages
   });
+
+  if (!enabledTreeSitterLanguages.length) return;
+
   await preloadTreeSitterLanguages(enabledTreeSitterLanguages, {
     log,
     parallel: treeSitterPreload === 'parallel',
-    concurrency: treeSitterPreloadConcurrency
+    concurrency: treeSitterPreloadConcurrency,
+    maxLoadedLanguages: treeSitterMaxLoadedLanguages
   });
 };
diff --git a/src/lang/tree-sitter/chunking.js b/src/lang/tree-sitter/chunking.js
index 77405a6..34f7c3b 100644
--- a/src/lang/tree-sitter/chunking.js
+++ b/src/lang/tree-sitter/chunking.js
@@ -8,7 +8,7 @@ import {
 } from './ast.js';
 import { LANG_CONFIG } from './config.js';
 import { isTreeSitterEnabled } from './options.js';
-import { getTreeSitterParser } from './runtime.js';
+import { getTreeSitterParser, preloadTreeSitterLanguages } from './runtime.js';
 import { treeSitterState } from './state.js';
 import { getTreeSitterWorkerPool, sanitizeTreeSitterOptions } from './worker.js';
 
@@ -413,6 +413,14 @@ export async function buildTreeSitterChunksAsync({ text, languageId, ext, option
 
   const pool = await getTreeSitterWorkerPool(options?.treeSitter?.worker, options);
   if (!pool) {
+    try {
+      await preloadTreeSitterLanguages([resolvedId], {
+        log: options?.log,
+        maxLoadedLanguages: options?.treeSitter?.maxLoadedLanguages
+      });
+    } catch {
+      // If the runtime or grammar load fails, fall back to heuristic chunking.
+    }
     return buildTreeSitterChunks({ text, languageId, ext, options });
   }
 
@@ -438,12 +446,28 @@ export async function buildTreeSitterChunksAsync({ text, languageId, ext, option
     if (Array.isArray(result) && result.length) return result;
 
     // Null/empty results from a worker are treated as a failure signal; retry in-thread for determinism.
+    try {
+      await preloadTreeSitterLanguages([resolvedId], {
+        log: options?.log,
+        maxLoadedLanguages: options?.treeSitter?.maxLoadedLanguages
+      });
+    } catch {
+      // ignore preload failures; buildTreeSitterChunks will fall back upstream.
+    }
     return buildTreeSitterChunks({ text, languageId, ext, options: fallbackOptions });
   } catch (err) {
     if (options?.log && !treeSitterState.loggedWorkerFailures.has('run')) {
       options.log(`[tree-sitter] Worker parse failed; falling back to main thread (${err?.message || err}).`);
       treeSitterState.loggedWorkerFailures.add('run');
     }
+    try {
+      await preloadTreeSitterLanguages([resolvedId], {
+        log: options?.log,
+        maxLoadedLanguages: options?.treeSitter?.maxLoadedLanguages
+      });
+    } catch {
+      // ignore preload failures; buildTreeSitterChunks will fall back upstream.
+    }
     return buildTreeSitterChunks({ text, languageId, ext, options: fallbackOptions });
   } finally {
     if (shouldRecordMetrics) {
diff --git a/src/lang/tree-sitter/runtime.js b/src/lang/tree-sitter/runtime.js
index d26376f..541611c 100644
--- a/src/lang/tree-sitter/runtime.js
+++ b/src/lang/tree-sitter/runtime.js
@@ -1,22 +1,27 @@
 import fs from 'node:fs/promises';
 import os from 'node:os';
 import path from 'node:path';
+import { isMainThread } from 'node:worker_threads';
 import { createRequire } from 'node:module';
 import { LANGUAGE_WASM_FILES, TREE_SITTER_LANGUAGE_IDS } from './config.js';
 import { treeSitterState } from './state.js';
 
 const require = createRequire(import.meta.url);
 
+const clampPositiveInt = (value, { min = 1, max = 64 } = {}) => {
+  const parsed = Number(value);
+  if (!Number.isFinite(parsed) || parsed <= 0) return null;
+  return Math.max(min, Math.min(max, Math.floor(parsed)));
+};
+
 // Tree-sitter Parser instances can hold non-trivial native/WASM memory.
 // In multi-language repos this can balloon quickly if we cache one Parser per
 // language indefinitely. We cap the parser cache and evict LRU entries.
 const DEFAULT_MAX_PARSER_CACHE = (() => {
   try {
     const envRaw = process.env.POC_TREE_SITTER_MAX_PARSERS;
-    const envMax = Number(envRaw);
-    if (Number.isFinite(envMax) && envMax > 0) {
-      return Math.max(1, Math.min(16, Math.floor(envMax)));
-    }
+    const envMax = clampPositiveInt(envRaw, { min: 1, max: 16 });
+    if (envMax) return envMax;
 
     const cpuCount = Array.isArray(os.cpus?.()) ? os.cpus().length : 0;
     // Keep this intentionally small; we only parse on the main thread.
@@ -26,6 +31,95 @@ const DEFAULT_MAX_PARSER_CACHE = (() => {
   }
 })();
 
+// Default cap for retained WASM grammars.
+//
+// - On the main thread we default to retaining all supported grammars because
+//   synchronous chunkers may rely on preloaded grammars.
+// - On worker threads we keep a conservative cap by default because caches are
+//   multiplied per thread.
+const DEFAULT_MAX_WASM_LANGUAGE_CACHE = (() => {
+  // Environment override applies everywhere.
+  try {
+    const envRaw = process.env.POC_TREE_SITTER_MAX_LANGUAGES
+      || process.env.PAIR_OF_CLEATS_TREE_SITTER_MAX_LANGUAGES;
+    const envMax = clampPositiveInt(envRaw, { min: 1, max: 64 });
+    if (envMax) return envMax;
+  } catch {
+    // ignore
+  }
+
+  if (isMainThread) return TREE_SITTER_LANGUAGE_IDS.length;
+  return process.platform === 'win32' ? 6 : 8;
+})();
+
+function resolveMaxLoadedLanguages(options = {}) {
+  const raw = options?.maxLoadedLanguages
+    ?? options?.treeSitter?.maxLoadedLanguages
+    ?? null;
+  const parsed = clampPositiveInt(raw, { min: 1, max: 64 });
+  return parsed || DEFAULT_MAX_WASM_LANGUAGE_CACHE;
+}
+
+function touchWasmLanguageCacheEntry(wasmKey) {
+  if (!wasmKey || !treeSitterState.wasmLanguageCache.has(wasmKey)) return;
+  const value = treeSitterState.wasmLanguageCache.get(wasmKey);
+  treeSitterState.wasmLanguageCache.delete(wasmKey);
+  treeSitterState.wasmLanguageCache.set(wasmKey, value);
+}
+
+function removeLanguageCacheEntriesForWasmKey(wasmKey) {
+  if (!wasmKey) return;
+  const toDelete = [];
+  for (const langId of treeSitterState.languageCache.keys()) {
+    if (LANGUAGE_WASM_FILES[langId] === wasmKey) toDelete.push(langId);
+  }
+  for (const langId of toDelete) {
+    treeSitterState.languageCache.delete(langId);
+  }
+}
+
+function disposeWasmLanguageEntry(entry) {
+  const language = entry?.language;
+  if (language && typeof language.delete === 'function') {
+    try {
+      language.delete();
+    } catch {
+      // ignore disposal failures
+    }
+  }
+}
+
+function evictOldWasmLanguages(maxSize, options = {}) {
+  const max = Number(maxSize);
+  if (!Number.isFinite(max) || max <= 0) return;
+
+  // Never evict the grammar currently active on the shared parser.
+  const activeLangId = treeSitterState.sharedParserLanguageId;
+  const activeWasmKey = activeLangId ? LANGUAGE_WASM_FILES[activeLangId] : null;
+
+  let guard = 0;
+  while (treeSitterState.wasmLanguageCache.size > max && guard < 1024) {
+    const oldestKey = treeSitterState.wasmLanguageCache.keys().next().value;
+    if (!oldestKey) break;
+
+    if (activeWasmKey && oldestKey === activeWasmKey) {
+      // Move the active grammar to the back and try the next.
+      touchWasmLanguageCacheEntry(oldestKey);
+      guard += 1;
+      continue;
+    }
+
+    const entry = treeSitterState.wasmLanguageCache.get(oldestKey);
+    treeSitterState.wasmLanguageCache.delete(oldestKey);
+    removeLanguageCacheEntriesForWasmKey(oldestKey);
+    disposeWasmLanguageEntry(entry);
+  }
+
+  if (guard >= 1024 && options?.log) {
+    options.log('[tree-sitter] WASM grammar eviction guard tripped; cache may remain oversized.');
+  }
+}
+
 function resolveLanguageId(languageId) {
   return typeof languageId === 'string' ? languageId : null;
 }
@@ -92,10 +186,16 @@ async function loadWasmLanguage(languageId, options = {}) {
   if (!resolvedId) {
     return { language: null, error: new Error('Missing tree-sitter language id') };
   }
-  const cached = treeSitterState.languageCache.get(resolvedId);
-  if (cached?.language || cached?.error) return cached;
 
   const wasmFile = LANGUAGE_WASM_FILES[resolvedId];
+  const wasmKey = wasmFile || null;
+
+  const cached = treeSitterState.languageCache.get(resolvedId);
+  if (cached?.language || cached?.error) {
+    if (wasmKey) touchWasmLanguageCacheEntry(wasmKey);
+    return cached;
+  }
+
   if (!wasmFile) {
     const entry = { language: null, error: new Error(`Missing WASM file for ${resolvedId}`) };
     treeSitterState.languageCache.set(resolvedId, entry);
@@ -103,9 +203,9 @@ async function loadWasmLanguage(languageId, options = {}) {
   }
 
   // Deduplicate aliases that share the same wasm (e.g. javascript/jsx).
-  const wasmKey = wasmFile;
   const wasmCached = treeSitterState.wasmLanguageCache.get(wasmKey);
   if (wasmCached?.language || wasmCached?.error) {
+    touchWasmLanguageCacheEntry(wasmKey);
     treeSitterState.languageCache.set(resolvedId, wasmCached);
     return wasmCached;
   }
@@ -116,9 +216,11 @@ async function loadWasmLanguage(languageId, options = {}) {
       if (entry && !treeSitterState.languageCache.has(resolvedId)) {
         treeSitterState.languageCache.set(resolvedId, entry);
       }
+      touchWasmLanguageCacheEntry(wasmKey);
       return entry;
     });
   }
+
   const promise = (async () => {
     const ok = await initTreeSitterWasm(options);
     if (!ok) {
@@ -128,8 +230,11 @@ async function loadWasmLanguage(languageId, options = {}) {
       };
       treeSitterState.languageCache.set(resolvedId, entry);
       treeSitterState.wasmLanguageCache.set(wasmKey, entry);
+      touchWasmLanguageCacheEntry(wasmKey);
+      evictOldWasmLanguages(resolveMaxLoadedLanguages(options), options);
       return entry;
     }
+
     try {
       const wasmPath = path.join(resolveWasmRoot(), wasmFile);
       // Prefer path-based loading to avoid retaining large WASM buffers in JS.
@@ -144,11 +249,15 @@ async function loadWasmLanguage(languageId, options = {}) {
       const entry = { language, error: null };
       treeSitterState.languageCache.set(resolvedId, entry);
       treeSitterState.wasmLanguageCache.set(wasmKey, entry);
+      touchWasmLanguageCacheEntry(wasmKey);
+      evictOldWasmLanguages(resolveMaxLoadedLanguages(options), options);
       return entry;
     } catch (err) {
       const entry = { language: null, error: err };
       treeSitterState.languageCache.set(resolvedId, entry);
       treeSitterState.wasmLanguageCache.set(wasmKey, entry);
+      touchWasmLanguageCacheEntry(wasmKey);
+      evictOldWasmLanguages(resolveMaxLoadedLanguages(options), options);
       return entry;
     } finally {
       treeSitterState.languageLoadPromises.delete(wasmKey);
@@ -162,11 +271,26 @@ async function loadWasmLanguage(languageId, options = {}) {
 export async function preloadTreeSitterLanguages(languageIds = TREE_SITTER_LANGUAGE_IDS, options = {}) {
   const ok = await initTreeSitterWasm(options);
   if (!ok) return false;
+
   const unique = Array.from(new Set(languageIds || []));
+
+  const maxLoaded = resolveMaxLoadedLanguages(options);
+  if (options?.log && maxLoaded && unique.length > maxLoaded && treeSitterState.loggedEvictionWarnings) {
+    const key = `preload:${unique.length}:${maxLoaded}`;
+    if (!treeSitterState.loggedEvictionWarnings.has(key)) {
+      options.log(
+        `[tree-sitter] Preloading ${unique.length} grammars with maxLoadedLanguages=${maxLoaded}; `
+          + 'older grammars may be evicted during preload.'
+      );
+      treeSitterState.loggedEvictionWarnings.add(key);
+    }
+  }
+
   const parallel = options.parallel === true;
   const concurrency = Number.isFinite(Number(options.concurrency))
     ? Math.max(1, Math.floor(Number(options.concurrency)))
     : unique.length;
+
   if (!parallel || concurrency <= 1) {
     for (const id of unique) {
       // Load sequentially to avoid wasm runtime contention.
@@ -174,6 +298,7 @@ export async function preloadTreeSitterLanguages(languageIds = TREE_SITTER_LANGU
     }
     return true;
   }
+
   const pending = new Set();
   for (const id of unique) {
     const task = loadWasmLanguage(id, options)
@@ -221,8 +346,10 @@ export function getTreeSitterParser(languageId, options = {}) {
     }
     return null;
   }
+
   const resolvedId = resolveLanguageId(languageId);
   if (!resolvedId) return null;
+
   const entry = treeSitterState.languageCache.get(resolvedId) || null;
   const language = entry?.language || null;
   if (!language) {
@@ -238,6 +365,10 @@ export function getTreeSitterParser(languageId, options = {}) {
     return null;
   }
 
+  // Keep grammar LRU fresh.
+  const wasmKey = LANGUAGE_WASM_FILES[resolvedId];
+  if (wasmKey) touchWasmLanguageCacheEntry(wasmKey);
+
   // IMPORTANT: Keep a single shared Parser instance and switch languages.
   // Keeping multiple parsers alive (even with an LRU cache) can balloon WASM
   // memory in polyglot repos and trigger V8 "Zone" OOMs on Windows.
@@ -245,6 +376,7 @@ export function getTreeSitterParser(languageId, options = {}) {
     if (!treeSitterState.sharedParser) {
       treeSitterState.sharedParser = new treeSitterState.TreeSitter();
       treeSitterState.sharedParserLanguageId = null;
+
       // Clear and dispose the legacy per-language cache to avoid keeping extra Parsers alive.
       if (treeSitterState.parserCache && typeof treeSitterState.parserCache.values === 'function') {
         for (const cached of treeSitterState.parserCache.values()) {
@@ -269,6 +401,7 @@ export function getTreeSitterParser(languageId, options = {}) {
       treeSitterState.sharedParser.setLanguage(language);
       treeSitterState.sharedParserLanguageId = resolvedId;
     }
+
     return treeSitterState.sharedParser;
   } catch (err) {
     // If the shared parser becomes unusable, drop it and try to recreate on the next call.
diff --git a/src/lang/tree-sitter/state.js b/src/lang/tree-sitter/state.js
index e096669..808ea01 100644
--- a/src/lang/tree-sitter/state.js
+++ b/src/lang/tree-sitter/state.js
@@ -21,6 +21,7 @@ export const treeSitterState = {
   wasmLanguageCache: new Map(),
   languageLoadPromises: new Map(),
   loggedMissing: new Set(),
+  loggedEvictionWarnings: new Set(),
   loggedInitFailure: new Set(),
   loggedWorkerFailures: new Set(),
   treeSitterWorkerPool: null,
diff --git a/src/lang/tree-sitter/worker.js b/src/lang/tree-sitter/worker.js
index ebee06a..12a3503 100644
--- a/src/lang/tree-sitter/worker.js
+++ b/src/lang/tree-sitter/worker.js
@@ -36,6 +36,7 @@ export const sanitizeTreeSitterOptions = (treeSitter) => {
     maxBytes: config.maxBytes ?? null,
     maxLines: config.maxLines ?? null,
     maxParseMs: config.maxParseMs ?? null,
+    maxLoadedLanguages: config.maxLoadedLanguages ?? null,
     maxAstNodes: config.maxAstNodes ?? null,
     maxAstStack: config.maxAstStack ?? null,
     maxChunkNodes: config.maxChunkNodes ?? null,
diff --git a/src/lang/workers/tree-sitter-worker.js b/src/lang/workers/tree-sitter-worker.js
index e67679e..0b4320c 100644
--- a/src/lang/workers/tree-sitter-worker.js
+++ b/src/lang/workers/tree-sitter-worker.js
@@ -70,7 +70,9 @@ export async function parseTreeSitter(payload = {}) {
     const resolvedId = resolveLanguageForExt(languageId, ext);
     if (resolvedId && isLanguageEnabled(treeSitter, resolvedId)) {
       // Cached by the runtime module within this worker thread.
-      await preloadTreeSitterLanguages([resolvedId]);
+      await preloadTreeSitterLanguages([resolvedId], {
+        maxLoadedLanguages: treeSitter?.maxLoadedLanguages
+      });
     }
   } catch {
     // If init/preload fails in this worker, fall back to heuristic chunking upstream.
