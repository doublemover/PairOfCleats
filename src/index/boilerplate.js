import { checksumString } from '../shared/hash.js';

const LEADING_SCAN_MAX_LINES = 160;
const TRAILING_SCAN_MAX_LINES = 160;
const MAX_BLOCK_LINES = 120;

const LICENSE_SIGNAL_RE = /(spdx-license-identifier|licensed under|copyright|all rights reserved|license information|this source file is part of|contributors|permission is hereby granted|apache license|mit license|bsd|gpl|lgpl|mozilla public license|eclipse public license|llvm-exception|runtime library exception)/i;
const GENERATED_SIGNAL_RE = /(generated by|auto-generated|autogenerated|do not edit|this code was generated by)/i;
const COMMENT_LINE_RE = /^(\/\/|#|\*|\/\*|\*\/|--|;|<!--|\s*\*)/;
const DECORATIVE_RE = /^[-=*_#/;<>.\s]+$/;

const splitLinesWithOffsets = (text) => {
  const source = typeof text === 'string' ? text : '';
  const lines = [];
  const re = /.*(?:\r\n|\n|$)/g;
  let offset = 0;
  for (const match of source.matchAll(re)) {
    const raw = match[0];
    if (!raw && offset >= source.length) break;
    const line = raw.replace(/\r?\n$/, '');
    lines.push({
      line,
      start: offset,
      end: offset + line.length
    });
    offset += raw.length;
  }
  return lines;
};

const stripCommentPrefix = (line) => String(line || '')
  .replace(/^\s*\/\/+\s?/, '')
  .replace(/^\s*#\s?/, '')
  .replace(/^\s*;\s?/, '')
  .replace(/^\s*--\s?/, '')
  .replace(/^\s*\/\*+\s?/, '')
  .replace(/^\s*\*\/\s?/, '')
  .replace(/^\s*\*\s?/, '')
  .replace(/^\s*<!--\s?/, '')
  .replace(/\s*-->\s*$/, '')
  .trim();

const isCommentOrBlankLine = (line) => {
  const trimmed = String(line || '').trim();
  if (!trimmed) return true;
  return COMMENT_LINE_RE.test(trimmed);
};

const normalizeBlockText = (lines) => {
  const cleaned = [];
  for (const rawLine of lines || []) {
    const normalizedLine = stripCommentPrefix(rawLine);
    if (!normalizedLine) continue;
    if (DECORATIVE_RE.test(normalizedLine)) continue;
    cleaned.push(normalizedLine);
  }
  if (!cleaned.length) return '';
  if (
    cleaned.length > 1
    && /\.[A-Za-z0-9]{1,8}\b/.test(cleaned[0])
    && !LICENSE_SIGNAL_RE.test(cleaned[0])
  ) {
    cleaned.shift();
  }
  return cleaned
    .join('\n')
    .toLowerCase()
    .replace(/\b(19|20)\d{2}(\s*[-/]\s*(19|20)\d{2})?\b/g, '<year>')
    .replace(/\b[A-Za-z0-9_.-]+\.(c|cc|cpp|cxx|h|hpp|hh|swift|m|mm|java|kt|js|ts|tsx|py|rb|go|rs|cs|php|scala|sh|lua)\b/g, '<file>')
    .replace(/\s+/g, ' ')
    .trim();
};

const detectTags = (normalizedText) => {
  const text = typeof normalizedText === 'string' ? normalizedText : '';
  const tags = new Set();
  const spdxMatch = text.match(/spdx-license-identifier\s*:\s*([^\n]+)/i);
  if (spdxMatch && spdxMatch[1]) {
    const value = spdxMatch[1].trim().toLowerCase().replace(/\s+/g, '-');
    if (value) tags.add(`spdx:${value}`);
  }
  if (/apache/.test(text)) tags.add('license:apache');
  if (/mit\b/.test(text)) tags.add('license:mit');
  if (/\bgpl\b|gnu general public license/.test(text)) tags.add('license:gpl');
  if (/\blgpl\b/.test(text)) tags.add('license:lgpl');
  if (/\bbsd\b/.test(text)) tags.add('license:bsd');
  if (/mozilla public license|\bmpl\b/.test(text)) tags.add('license:mpl');
  if (/eclipse public license|\bepl\b/.test(text)) tags.add('license:epl');
  if (/llvm-exception|runtime library exception/.test(text)) tags.add('license:exception');
  if (GENERATED_SIGNAL_RE.test(text)) tags.add('boilerplate:generated');
  if (LICENSE_SIGNAL_RE.test(text)) tags.add('boilerplate:license');
  return Array.from(tags).sort();
};

const collectLeadingCommentBlock = (lines) => {
  const maxLines = Math.min(lines.length, LEADING_SCAN_MAX_LINES);
  let first = -1;
  for (let i = 0; i < maxLines; i += 1) {
    const trimmed = lines[i].line.trim();
    if (!trimmed) continue;
    first = i;
    break;
  }
  if (first < 0) return null;
  if (!COMMENT_LINE_RE.test(lines[first].line.trim())) return null;
  const collected = [];
  let lastIndex = first;
  for (let i = first; i < maxLines && collected.length < MAX_BLOCK_LINES; i += 1) {
    const value = lines[i].line;
    if (!isCommentOrBlankLine(value)) break;
    collected.push(value);
    lastIndex = i;
  }
  if (!collected.length) return null;
  return {
    position: 'header',
    lines: collected,
    startOffset: lines[first].start,
    endOffset: lines[lastIndex].end,
    startLine: first + 1,
    endLine: lastIndex + 1
  };
};

const collectTrailingCommentBlock = (lines) => {
  const minIndex = Math.max(0, lines.length - TRAILING_SCAN_MAX_LINES);
  let last = -1;
  for (let i = lines.length - 1; i >= minIndex; i -= 1) {
    const trimmed = lines[i].line.trim();
    if (!trimmed) continue;
    last = i;
    break;
  }
  if (last < 0) return null;
  if (!COMMENT_LINE_RE.test(lines[last].line.trim())) return null;
  const collected = [];
  let firstIndex = last;
  for (let i = last; i >= minIndex && collected.length < MAX_BLOCK_LINES; i -= 1) {
    const value = lines[i].line;
    if (!isCommentOrBlankLine(value)) break;
    collected.push(value);
    firstIndex = i;
  }
  collected.reverse();
  if (!collected.length) return null;
  return {
    position: 'footer',
    lines: collected,
    startOffset: lines[firstIndex].start,
    endOffset: lines[last].end,
    startLine: firstIndex + 1,
    endLine: last + 1
  };
};

const buildBoilerplateEntry = async (candidate) => {
  if (!candidate || !Array.isArray(candidate.lines) || !candidate.lines.length) return null;
  const normalizedText = normalizeBlockText(candidate.lines);
  if (!normalizedText) return null;
  const looksLicense = LICENSE_SIGNAL_RE.test(normalizedText);
  const looksGenerated = GENERATED_SIGNAL_RE.test(normalizedText);
  if (!looksLicense && !looksGenerated) return null;
  const hash = await checksumString(normalizedText);
  const signature = hash?.value ? `xxh64:${hash.value}` : null;
  if (!signature) return null;
  const tags = detectTags(normalizedText);
  return {
    signature,
    position: candidate.position,
    tags,
    startOffset: candidate.startOffset,
    endOffset: candidate.endOffset,
    startLine: candidate.startLine,
    endLine: candidate.endLine,
    normalizedText
  };
};

/**
 * Detect reusable boilerplate comment blocks (license/generated headers/footers).
 * @param {{text:string}} input
 * @returns {Promise<Array<object>>}
 */
export const detectBoilerplateCommentBlocks = async ({ text }) => {
  if (typeof text !== 'string' || !text) return [];
  const lines = splitLinesWithOffsets(text);
  if (!lines.length) return [];
  const [header, footer] = await Promise.all([
    buildBoilerplateEntry(collectLeadingCommentBlock(lines)),
    buildBoilerplateEntry(collectTrailingCommentBlock(lines))
  ]);
  const out = [];
  if (header) out.push(header);
  if (footer && (!header || footer.signature !== header.signature || footer.position !== header.position)) {
    out.push(footer);
  }
  return out;
};

/**
 * Find the dominant boilerplate overlap for a given chunk range.
 * @param {{blocks:Array<object>,start:number,end:number}} input
 * @returns {{ref:string,tags:Array<string>,position:string,coverage:number,startLine:number,endLine:number}|null}
 */
export const resolveChunkBoilerplateMatch = ({ blocks, start, end }) => {
  if (!Array.isArray(blocks) || !blocks.length) return null;
  if (!Number.isFinite(start) || !Number.isFinite(end) || end <= start) return null;
  const chunkLen = end - start;
  let best = null;
  for (const block of blocks) {
    const overlapStart = Math.max(start, block.startOffset);
    const overlapEnd = Math.min(end, block.endOffset);
    const overlap = Math.max(0, overlapEnd - overlapStart);
    if (overlap <= 0) continue;
    const coverage = overlap / chunkLen;
    if (!best || coverage > best.coverage) {
      best = {
        ref: block.signature,
        tags: Array.isArray(block.tags) ? block.tags : [],
        position: block.position,
        coverage,
        startLine: block.startLine,
        endLine: block.endLine
      };
    }
  }
  return best;
};
