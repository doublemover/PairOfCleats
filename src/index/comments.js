import { parse as parseYaml } from 'yaml';
import { parse as parseToml } from 'smol-toml';
import { parse as parseJsonc } from 'jsonc-parser';
import { offsetToLine } from '../shared/lines.js';

const DEFAULT_COMMENT_CONFIG = {
  extract: 'doc',
  includeLicense: false,
  minDocChars: 15,
  minInlineChars: 30,
  minTokens: 5,
  maxPerChunk: 5,
  maxBytesPerChunk: 8 * 1024,
  headerMaxLines: 200,
  licensePattern: 'copyright|license|spdx|apache|mit|gpl|bsd',
  generatedPattern: 'generated by|do not edit|@generated|autogenerated',
  linterPattern: 'eslint-disable|prettier-ignore|noinspection',
  skipGenerated: true,
  skipLinter: true
};

const COMMENT_STYLES = [
  {
    ids: new Set([
      'javascript',
      'typescript',
      'jsx',
      'tsx',
      'java',
      'c',
      'cpp',
      'csharp',
      'go',
      'rust',
      'php',
      'kotlin',
      'swift',
      'objc',
      'objective-c',
      'protobuf',
      'dart',
      'scala',
      'groovy'
    ]),
    line: ['//'],
    block: [{ start: '/*', end: '*/', stripStar: true }],
    strings: ['"', '\'', '`']
  },
  {
    ids: new Set(['css', 'scss', 'sass', 'less']),
    line: ['//'],
    block: [{ start: '/*', end: '*/', stripStar: true }],
    strings: ['"', '\'']
  },
  {
    ids: new Set(['nix']),
    line: ['#'],
    block: [{ start: '/*', end: '*/', stripStar: true }],
    strings: ['"', '\'', '`']
  },
  {
    ids: new Set(['julia']),
    line: ['#'],
    block: [{ start: '#=', end: '=#', stripStar: false }],
    strings: ['"', '\'', '`']
  },
  {
    ids: new Set([
      'python',
      'shell',
      'ruby',
      'yaml',
      'toml',
      'ini',
      'dockerfile',
      'makefile',
      'graphql',
      'cmake',
      'starlark',
      'r'
    ]),
    line: ['#'],
    block: [],
    strings: ['"', '\'']
  },
  {
    ids: new Set(['sql']),
    line: ['--'],
    block: [{ start: '/*', end: '*/', stripStar: true }],
    strings: ['"', '\'']
  },
  {
    ids: new Set(['handlebars', 'mustache']),
    line: [],
    block: [
      { start: '{{!--', end: '--}}', stripStar: false },
      { start: '{{!', end: '}}', stripStar: false }
    ],
    strings: ['"', '\'']
  },
  {
    ids: new Set(['jinja']),
    line: [],
    block: [{ start: '{#', end: '#}', stripStar: false }],
    strings: ['"', '\'']
  },
  {
    ids: new Set(['razor']),
    line: [],
    block: [{ start: '@*', end: '*@', stripStar: false }],
    strings: ['"', '\'']
  },
  {
    ids: new Set(['markdown', 'html', 'xml', 'astro', 'vue', 'svelte']),
    line: [],
    block: [{ start: '<!--', end: '-->', stripStar: false }],
    strings: ['"', '\'']
  }
];

const EXT_OVERRIDES = new Map([
  ['.js', 'javascript'],
  ['.jsx', 'jsx'],
  ['.ts', 'typescript'],
  ['.tsx', 'tsx'],
  ['.c', 'c'],
  ['.h', 'c'],
  ['.cpp', 'cpp'],
  ['.hpp', 'cpp'],
  ['.cs', 'csharp'],
  ['.go', 'go'],
  ['.rs', 'rust'],
  ['.java', 'java'],
  ['.kt', 'kotlin'],
  ['.swift', 'swift'],
  ['.m', 'objc'],
  ['.mm', 'objc'],
  ['.php', 'php'],
  ['.css', 'css'],
  ['.scss', 'scss'],
  ['.sass', 'sass'],
  ['.less', 'less'],
  ['.py', 'python'],
  ['.rb', 'ruby'],
  ['.sh', 'shell'],
  ['.bash', 'shell'],
  ['.yml', 'yaml'],
  ['.yaml', 'yaml'],
  ['.toml', 'toml'],
  ['.ini', 'ini'],
  ['.cfg', 'ini'],
  ['.conf', 'ini'],
  ['.sql', 'sql'],
  ['.md', 'markdown'],
  ['.mdx', 'markdown'],
  ['.html', 'html'],
  ['.xml', 'xml'],
  ['.vue', 'vue'],
  ['.svelte', 'svelte'],
  ['.astro', 'astro'],
  ['.dockerfile', 'dockerfile'],
  ['.makefile', 'makefile'],
  ['.proto', 'protobuf'],
  ['.graphql', 'graphql'],
  ['.gql', 'graphql'],
  ['.cmake', 'cmake'],
  ['.bzl', 'starlark'],
  ['.bazel', 'starlark'],
  ['.star', 'starlark'],
  ['.nix', 'nix'],
  ['.dart', 'dart'],
  ['.scala', 'scala'],
  ['.sc', 'scala'],
  ['.groovy', 'groovy'],
  ['.gradle', 'groovy'],
  ['.gvy', 'groovy'],
  ['.r', 'r'],
  ['.jl', 'julia'],
  ['.hbs', 'handlebars'],
  ['.handlebars', 'handlebars'],
  ['.mustache', 'mustache'],
  ['.jinja', 'jinja'],
  ['.jinja2', 'jinja'],
  ['.j2', 'jinja'],
  ['.django', 'jinja'],
  ['.djhtml', 'jinja'],
  ['.razor', 'razor'],
  ['.cshtml', 'razor']
]);

const normalizeLimit = (value, fallback) => {
  const num = Number(value);
  if (!Number.isFinite(num)) return fallback;
  return Math.max(0, Math.floor(num));
};

const normalizePattern = (value, fallback) => {
  if (value === null || value === undefined) return fallback;
  if (value instanceof RegExp) return value;
  if (typeof value === 'string' && value.trim()) return new RegExp(value, 'i');
  return fallback;
};

export function normalizeCommentConfig(input = {}) {
  const cfg = input && typeof input === 'object' ? input : {};
  const extractRaw = typeof cfg.extract === 'string' ? cfg.extract.toLowerCase() : '';
  const extract = ['off', 'doc', 'all'].includes(extractRaw) ? extractRaw : DEFAULT_COMMENT_CONFIG.extract;
  return {
    extract,
    includeLicense: cfg.includeLicense === true,
    minDocChars: normalizeLimit(cfg.minDocChars, DEFAULT_COMMENT_CONFIG.minDocChars),
    minInlineChars: normalizeLimit(cfg.minInlineChars, DEFAULT_COMMENT_CONFIG.minInlineChars),
    minTokens: normalizeLimit(cfg.minTokens, DEFAULT_COMMENT_CONFIG.minTokens),
    maxPerChunk: normalizeLimit(cfg.maxPerChunk, DEFAULT_COMMENT_CONFIG.maxPerChunk),
    maxBytesPerChunk: normalizeLimit(cfg.maxBytesPerChunk, DEFAULT_COMMENT_CONFIG.maxBytesPerChunk),
    headerMaxLines: normalizeLimit(cfg.headerMaxLines, DEFAULT_COMMENT_CONFIG.headerMaxLines),
    licensePattern: normalizePattern(cfg.licensePattern, new RegExp(DEFAULT_COMMENT_CONFIG.licensePattern, 'i')),
    generatedPattern: normalizePattern(cfg.generatedPattern, new RegExp(DEFAULT_COMMENT_CONFIG.generatedPattern, 'i')),
    linterPattern: normalizePattern(cfg.linterPattern, new RegExp(DEFAULT_COMMENT_CONFIG.linterPattern, 'i')),
    skipGenerated: cfg.skipGenerated !== false,
    skipLinter: cfg.skipLinter !== false
  };
}

const resolveCommentStyle = ({ ext, languageId }) => {
  const resolvedId = languageId || (ext && EXT_OVERRIDES.get(ext)) || null;
  if (!resolvedId) return null;
  const match = COMMENT_STYLES.find((entry) => entry.ids.has(resolvedId));
  return match || null;
};

const splitLinesWithOffsets = (raw, baseOffset) => {
  const lines = [];
  let start = 0;
  for (let i = 0; i < raw.length; i += 1) {
    if (raw[i] === '\n') {
      lines.push({ raw: raw.slice(start, i), offset: baseOffset + start });
      start = i + 1;
    }
  }
  lines.push({ raw: raw.slice(start), offset: baseOffset + start });
  return lines;
};

const stripLineComment = (line, marker) => {
  let value = line;
  let offset = marker.length;
  if (value.startsWith(marker)) {
    value = value.slice(marker.length);
  }
  if (value.startsWith(' ')) {
    value = value.slice(1);
    offset += 1;
  }
  return { value, offset };
};

const stripBlockCommentLines = (lines, markerStart, markerEnd, stripStar) => {
  const trimmed = [];
  for (let i = 0; i < lines.length; i += 1) {
    const line = lines[i];
    let rawLine = line.raw;
    let offset = 0;
    if (i === 0 && rawLine.startsWith(markerStart)) {
      rawLine = rawLine.slice(markerStart.length);
      offset += markerStart.length;
    }
    if (i === lines.length - 1 && markerEnd && rawLine.endsWith(markerEnd)) {
      rawLine = rawLine.slice(0, -markerEnd.length);
    }
    const leading = rawLine.match(/^\s*/)?.[0]?.length || 0;
    rawLine = rawLine.slice(leading);
    offset += leading;
    if (stripStar && rawLine.startsWith('*')) {
      rawLine = rawLine.slice(1);
      offset += 1;
      if (rawLine.startsWith(' ')) {
        rawLine = rawLine.slice(1);
        offset += 1;
      }
    }
    trimmed.push({
      content: rawLine,
      contentStartOffset: line.offset + offset
    });
  }
  return trimmed;
};

const classifyCommentType = (raw, kind, headerLine, config) => {
  if (headerLine && config.licensePattern?.test(raw)) {
    return 'license';
  }
  if (kind === 'block') {
    if (raw.startsWith('/**') || raw.startsWith('/*!')) return 'doc';
  } else if (kind === 'line') {
    if (raw.startsWith('///') || raw.startsWith('//!') || raw.startsWith('##')) return 'doc';
  }
  return kind === 'line' ? 'inline' : 'block';
};

const hasEnoughChars = (text, minChars) => {
  if (!text) return false;
  const nonWhitespace = text.replace(/\s/g, '');
  return nonWhitespace.length >= minChars;
};

const shouldSkipNoise = (text, config) => {
  if (!text) return true;
  if (config.skipGenerated && config.generatedPattern?.test(text)) return true;
  if (config.skipLinter && config.linterPattern?.test(text)) return true;
  return false;
};

const isConfigParsable = (lang, text) => {
  if (!text) return false;
  try {
    if (lang === 'json') {
      const errors = [];
      parseJsonc(text, errors, { allowTrailingComma: true, allowEmptyContent: false });
      return errors.length === 0;
    }
    if (lang === 'yaml') {
      parseYaml(text);
      return true;
    }
    if (lang === 'toml') {
      parseToml(text);
      return true;
    }
  } catch {
    return false;
  }
  return false;
};

const scanComments = (text, style) => {
  const lineMarkers = style?.line || [];
  const blockMarkers = style?.block || [];
  const stringDelims = style?.strings || [];
  const out = [];
  let inString = null;
  let escaped = false;
  let i = 0;
  while (i < text.length) {
    const ch = text[i];
    if (inString) {
      if (escaped) {
        escaped = false;
      } else if (ch === '\\') {
        escaped = true;
      } else if (ch === inString) {
        inString = null;
      }
      i += 1;
      continue;
    }
    let matched = null;
    for (const block of blockMarkers) {
      if (text.startsWith(block.start, i)) {
        matched = { ...block, kind: 'block' };
        break;
      }
    }
    if (matched) {
      const start = i;
      const endIndex = text.indexOf(matched.end, i + matched.start.length);
      const end = endIndex === -1 ? text.length : endIndex + matched.end.length;
      out.push({
        start,
        end,
        raw: text.slice(start, end),
        kind: 'block',
        markerStart: matched.start,
        markerEnd: matched.end,
        stripStar: matched.stripStar === true
      });
      i = end;
      continue;
    }
    let lineMatch = null;
    for (const marker of lineMarkers) {
      if (text.startsWith(marker, i)) {
        lineMatch = marker;
        break;
      }
    }
    if (lineMatch) {
      const start = i;
      let end = text.indexOf('\n', i + lineMatch.length);
      if (end === -1) end = text.length;
      out.push({
        start,
        end,
        raw: text.slice(start, end),
        kind: 'line',
        markerStart: lineMatch,
        markerEnd: null,
        stripStar: false
      });
      i = end;
      continue;
    }
    if (stringDelims.includes(ch)) {
      inString = ch;
      i += 1;
      continue;
    }
    i += 1;
  }
  return out;
};

export function extractComments({
  text,
  ext,
  languageId,
  lineIndex,
  config: rawConfig
}) {
  const config = normalizeCommentConfig(rawConfig || {});
  if (config.extract === 'off') {
    return { comments: [], configSegments: [] };
  }
  const style = resolveCommentStyle({ ext, languageId });
  if (!style) {
    return { comments: [], configSegments: [] };
  }
  const comments = [];
  const configSegments = [];
  const rawComments = scanComments(text, style);
  for (const entry of rawComments) {
    const startLine = offsetToLine(lineIndex, entry.start);
    const endLine = offsetToLine(lineIndex, Math.max(entry.start, entry.end - 1));
    const headerLine = Number.isFinite(config.headerMaxLines)
      ? startLine <= config.headerMaxLines
      : false;
    const commentLines = splitLinesWithOffsets(entry.raw, entry.start);
    let contentLines = [];
    if (entry.kind === 'line') {
      const stripped = stripLineComment(commentLines[0].raw, entry.markerStart);
      contentLines = [{
        content: stripped.value,
        contentStartOffset: commentLines[0].offset + stripped.offset
      }];
    } else {
      contentLines = stripBlockCommentLines(
        commentLines,
        entry.markerStart,
        entry.markerEnd,
        entry.stripStar
      );
    }
    const contentText = contentLines.map((line) => line.content).join('\n').trim();
    const commentType = classifyCommentType(entry.raw, entry.kind, headerLine, config);
    const minChars = commentType === 'doc' || commentType === 'license'
      ? config.minDocChars
      : config.minInlineChars;
    if (!hasEnoughChars(contentText, minChars)) continue;
    if (shouldSkipNoise(contentText, config)) continue;
    if (config.extract === 'doc' && commentType !== 'doc' && commentType !== 'license') {
      continue;
    }
    comments.push({
      type: commentType,
      style: entry.kind,
      languageId: languageId || null,
      start: entry.start,
      end: entry.end,
      startLine,
      endLine,
      text: contentText,
      raw: entry.raw
    });
    for (let i = 0; i < contentLines.length; i += 1) {
      const line = contentLines[i].content;
      const fenceMatch = line.match(/^\s*```+\s*([A-Za-z0-9_-]+)?/);
      if (!fenceMatch) continue;
      const fenceLang = fenceMatch[1] ? fenceMatch[1].toLowerCase() : '';
      const lang = ['json', 'yaml', 'yml', 'toml'].includes(fenceLang) ? fenceLang : null;
      if (!lang) continue;
      let endFence = -1;
      for (let j = i + 1; j < contentLines.length; j += 1) {
        if (/^\s*```/.test(contentLines[j].content)) {
          endFence = j;
          break;
        }
      }
      if (endFence === -1 || endFence <= i + 1) continue;
      const startLineEntry = contentLines[i + 1];
      const endLineEntry = contentLines[endFence - 1];
      if (!startLineEntry || !endLineEntry) continue;
      const startOffset = startLineEntry.contentStartOffset
        + (startLineEntry.content.match(/^\s*/)?.[0]?.length || 0);
      const endOffset = endLineEntry.contentStartOffset + endLineEntry.content.length;
      if (!Number.isFinite(startOffset) || !Number.isFinite(endOffset) || endOffset <= startOffset) {
        continue;
      }
      const blockText = contentLines
        .slice(i + 1, endFence)
        .map((entryLine) => entryLine.content)
        .join('\n');
      const normalizedLang = lang === 'yml' ? 'yaml' : lang;
      if (!isConfigParsable(normalizedLang, blockText)) continue;
      configSegments.push({
        type: 'embedded',
        languageId: normalizedLang,
        start: startOffset,
        end: endOffset,
        parentSegmentId: null,
        embeddingContext: 'config',
        meta: {
          fenceInfo: fenceLang || null,
          source: 'comment'
        }
      });
    }
  }
  return { comments, configSegments };
}
