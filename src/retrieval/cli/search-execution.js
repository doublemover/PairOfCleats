import { color } from './ansi.js';
import { recordSearchArtifacts } from './persist.js';
import { renderSearchOutput } from './render.js';
import { runSearchSession } from './run-search-session.js';

/**
 * Execute retrieval, render output, and persist query artifacts.
 *
 * @param {object} input
 * @returns {Promise<object>}
 */
export async function executeSearchAndEmit(input) {
  const {
    t0,
    emitOutput,
    jsonOutput,
    jsonCompact,
    explain,
    rootDir,
    userConfig,
    metricsDir,
    queryCacheDir,
    query,
    searchMode,
    runCode,
    runProse,
    runExtractedProse,
    runRecords,
    joinComments,
    extractedProseLoaded,
    topN,
    useSqlite,
    annEnabledEffective,
    annActive,
    annBackend,
    lancedbConfig,
    vectorExtension,
    vectorAnnEnabled,
    vectorAnnState,
    vectorAnnUsed,
    hnswConfig,
    hnswAnnState,
    hnswAnnUsed,
    lanceAnnState,
    lanceAnnUsed,
    sqliteFtsEnabled,
    sqliteFtsNormalize,
    sqliteFtsProfile,
    sqliteFtsWeights,
    sqliteFtsTrigram,
    sqliteFtsStemming,
    sqliteCodePath,
    sqliteProsePath,
    sqliteExtractedProsePath,
    bm25K1,
    bm25B,
    queryPlan,
    symbolBoostEnabled,
    symbolBoostDefinitionWeight,
    symbolBoostExportWeight,
    relationBoostEnabled,
    relationBoostPerCall,
    relationBoostPerUse,
    relationBoostMaxBoost,
    annCandidateCap,
    annCandidateMinDocCount,
    annCandidateMaxDocCount,
    maxCandidates,
    scoreBlendEnabled,
    scoreBlendSparseWeight,
    scoreBlendAnnWeight,
    rrfEnabled,
    rrfK,
    graphRankingConfig,
    minhashMaxDocs,
    sparseBackend,
    sqliteHelpers,
    profilePolicyByMode,
    profileWarnings,
    idxProse,
    idxExtractedProse,
    idxCode,
    idxRecords,
    modelConfig,
    modelIdForCode,
    modelIdForProse,
    modelIdForExtractedProse,
    modelIdForRecords,
    embeddingProvider,
    embeddingOnnx,
    useStubEmbeddings,
    contextExpansionEnabled,
    contextExpansionOptions,
    contextExpansionRespectFilters,
    queryCacheEnabled,
    queryCacheMaxEntries,
    queryCacheTtlMs,
    backendLabel,
    backendPolicyInfo,
    showStats,
    showMatched,
    verboseCache,
    stageTracker,
    asOfContext
  } = input;

  const modelIds = {
    code: modelIdForCode,
    prose: modelIdForProse,
    extractedProse: modelIdForExtractedProse,
    records: modelIdForRecords
  };

  const searchStart = stageTracker.mark();
  const searchResult = await runSearchSession({
    rootDir,
    userConfig,
    metricsDir,
    queryCacheDir,
    query,
    searchMode,
    runCode,
    runProse,
    runExtractedProse,
    runRecords,
    commentsEnabled: joinComments,
    extractedProseLoaded,
    topN,
    useSqlite,
    annEnabled: annEnabledEffective,
    annActive,
    annBackend,
    lancedbConfig,
    vectorExtension,
    vectorAnnEnabled,
    vectorAnnState,
    vectorAnnUsed,
    hnswConfig,
    hnswAnnState,
    hnswAnnUsed,
    lanceAnnState,
    lanceAnnUsed,
    sqliteFtsRequested: sqliteFtsEnabled,
    sqliteFtsNormalize,
    sqliteFtsProfile,
    sqliteFtsWeights,
    sqliteFtsTrigram,
    sqliteFtsStemming,
    sqliteCodePath,
    sqliteProsePath,
    sqliteExtractedProsePath,
    bm25K1,
    bm25B,
    fieldWeights: queryPlan.fieldWeights,
    postingsConfig: input.postingsConfig,
    queryTokens: queryPlan.queryTokens,
    queryAst: queryPlan.queryAst,
    phraseNgramSet: queryPlan.phraseNgramSet,
    phraseRange: queryPlan.phraseRange,
    symbolBoost: {
      enabled: symbolBoostEnabled,
      definitionWeight: symbolBoostDefinitionWeight,
      exportWeight: symbolBoostExportWeight
    },
    relationBoost: {
      enabled: relationBoostEnabled,
      perCall: relationBoostPerCall,
      perUse: relationBoostPerUse,
      maxBoost: relationBoostMaxBoost
    },
    annCandidateCap,
    annCandidateMinDocCount,
    annCandidateMaxDocCount,
    maxCandidates,
    filters: queryPlan.filters,
    filtersActive: queryPlan.filtersActive,
    filterPredicates: queryPlan.filterPredicates,
    explain,
    scoreBlend: {
      enabled: scoreBlendEnabled,
      sparseWeight: scoreBlendSparseWeight,
      annWeight: scoreBlendAnnWeight
    },
    rrf: {
      enabled: rrfEnabled,
      k: rrfK
    },
    graphRankingConfig,
    minhashMaxDocs,
    sparseBackend,
    buildCandidateSetSqlite: sqliteHelpers.buildCandidateSetSqlite,
    getTokenIndexForQuery: sqliteHelpers.getTokenIndexForQuery,
    rankSqliteFts: sqliteHelpers.rankSqliteFts,
    rankVectorAnnSqlite: sqliteHelpers.rankVectorAnnSqlite,
    sqliteHasFts: sqliteHelpers?.hasFtsTable,
    sqliteHasTable: sqliteHelpers?.hasTable,
    sqliteHasDb: sqliteHelpers?.hasDb,
    profilePolicyByMode,
    profileWarnings,
    idxProse,
    idxExtractedProse,
    idxCode,
    idxRecords,
    modelConfig,
    modelIds,
    embeddingProvider,
    embeddingOnnx,
    embeddingQueryText: queryPlan.embeddingQueryText,
    useStubEmbeddings,
    contextExpansionEnabled,
    contextExpansionOptions,
    contextExpansionRespectFilters,
    cacheFilters: queryPlan.cacheFilters,
    queryCacheEnabled,
    queryCacheMaxEntries,
    queryCacheTtlMs,
    backendLabel,
    resolvedDenseVectorMode: queryPlan.resolvedDenseVectorMode,
    intentInfo: queryPlan.intentInfo,
    asOfContext,
    indexDirByMode: asOfContext?.strict ? asOfContext.indexDirByMode : null,
    indexBaseRootByMode: asOfContext?.strict ? asOfContext.indexBaseRootByMode : null,
    explicitRef: asOfContext?.strict === true,
    signal: input.signal,
    stageTracker
  });
  stageTracker.record('startup.search', searchStart, { mode: 'all' });

  const elapsedMs = Date.now() - t0;

  const payload = renderSearchOutput({
    emitOutput,
    jsonOutput,
    jsonCompact,
    explain,
    color,
    rootDir,
    backendLabel,
    backendPolicyInfo,
    routingPolicy: searchResult.routingPolicy || null,
    runCode,
    runProse,
    runExtractedProse,
    runRecords,
    topN,
    queryTokens: queryPlan.queryTokens,
    highlightRegex: queryPlan.highlightRegex,
    contextExpansionEnabled,
    expandedHits: {
      prose: searchResult.proseExpanded,
      extractedProse: searchResult.extractedProseExpanded,
      code: searchResult.codeExpanded,
      records: searchResult.recordExpanded
    },
    baseHits: {
      proseHits: searchResult.proseHits,
      extractedProseHits: searchResult.extractedProseHits,
      codeHits: searchResult.codeHits,
      recordHits: searchResult.recordHits
    },
    annEnabled: annEnabledEffective,
    annActive,
    annBackend: searchResult.annBackend,
    vectorExtension,
    vectorAnnEnabled,
    vectorAnnState,
    vectorAnnUsed,
    hnswConfig,
    hnswAnnState,
    lanceAnnState,
    modelIds,
    embeddingProvider,
    embeddingOnnx,
    cacheInfo: searchResult.cache,
    profileInfo: searchResult.profile || null,
    intentInfo: queryPlan.intentInfo,
    resolvedDenseVectorMode: queryPlan.resolvedDenseVectorMode,
    fieldWeights: queryPlan.fieldWeights,
    contextExpansionStats: searchResult.contextExpansionStats,
    idxProse,
    idxExtractedProse,
    idxCode,
    idxRecords,
    showStats,
    showMatched,
    verboseCache,
    elapsedMs,
    stageTracker,
    outputBudget: userConfig?.search?.outputBudget || null,
    asOfContext
  });

  await recordSearchArtifacts({
    metricsDir,
    query,
    queryTokens: queryPlan.queryTokens,
    proseHits: searchResult.proseHits,
    extractedProseHits: searchResult.extractedProseHits,
    codeHits: searchResult.codeHits,
    recordHits: searchResult.recordHits,
    elapsedMs,
    cacheHit: searchResult.cache.hit,
    asOf: asOfContext
      ? {
        type: asOfContext.type || 'latest',
        identityHash: asOfContext.identityHash || null
      }
      : null
  });

  return payload;
}
