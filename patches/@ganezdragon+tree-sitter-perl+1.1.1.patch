diff --git a/node_modules/@ganezdragon/tree-sitter-perl/src/scanner.c b/node_modules/@ganezdragon/tree-sitter-perl/src/scanner.c
index 58b5c40..ca82475 100644
--- a/node_modules/@ganezdragon/tree-sitter-perl/src/scanner.c
+++ b/node_modules/@ganezdragon/tree-sitter-perl/src/scanner.c
@@ -100,158 +100,160 @@ static char *my_strdup(const char *str) {
   return duplicate; // Return a pointer to the duplicated string
 }
 
-// START OF --- a array implementation of STRING queue in C
+// START OF --- dynamic STRING queue in C
 typedef struct
 {
-  int front, rear, size;
-  int capacity;
+  uint32_t len;
+  uint32_t cap;
   char **data;
 } StringQueue;
 
-// function to create a queue
-// of given capacity.
-// It initializes size of queue as 0
+static bool ensureStringQueueCapacity(StringQueue *queue, uint32_t needed) {
+  if (queue == NULL) return false;
+  if (needed <= queue->cap) return true;
+  uint32_t new_cap = queue->cap > 0 ? queue->cap : 4;
+  while (new_cap < needed) {
+    new_cap *= 2;
+  }
+  char **next = (char **)realloc(queue->data, sizeof(char *) * new_cap);
+  if (next == NULL) return false;
+  memset(next + queue->cap, 0, sizeof(char *) * (new_cap - queue->cap));
+  queue->data = next;
+  queue->cap = new_cap;
+  return true;
+}
+
 static StringQueue *createStringQueue() {
   StringQueue *queue = calloc(1, sizeof(StringQueue));
-
-  queue->capacity = 1;
-  queue->front = queue->size = 0;
-
-  queue->rear = queue->capacity - 1;
-  queue->data = (char **)calloc(1, queue->capacity * sizeof(char));
+  if (queue == NULL) return NULL;
+  queue->cap = 4;
+  queue->data = (char **)calloc(queue->cap, sizeof(char *));
+  if (queue->data == NULL) {
+    free(queue);
+    return NULL;
+  }
   return queue;
 }
 
-// StringQueue is full when size becomes
-// equal to the capacity
-static int isStringQueueFull(StringQueue *queue) {
-  return (queue->size == queue->capacity);
-}
-
-// StringQueue is empty when size is 0
 static int isStringQueueEmpty(StringQueue *queue) {
-  return (queue->size == 0);
+  return queue == NULL || queue->len == 0;
 }
 
-// Function to add an item to the queue.
-// It changes rear and size
 static void enqueueStringQueue(StringQueue *queue, String *item) {
-  if (isStringQueueFull(queue))
-    queue->capacity = queue->capacity + 1;;
-  queue->rear = (queue->rear + 1) % queue->capacity;
-  queue->data[queue->rear] = my_strdup(item->data);
-  queue->size = queue->size + 1;
+  if (queue == NULL || item == NULL || item->data == NULL) return;
+  if (!ensureStringQueueCapacity(queue, queue->len + 1)) return;
+  char *dup = my_strdup(item->data);
+  if (dup == NULL) return;
+  queue->data[queue->len++] = dup;
 }
 
-// Function to remove an item from queue.
-// It changes front and size
 static char *dequeueStringQueue(StringQueue *queue) {
-  if (isStringQueueEmpty(queue))
-    return NULL;
-  char *item = queue->data[queue->front];
-  queue->front = (queue->front + 1) % queue->capacity;
-  queue->size = queue->size - 1;
-  queue->capacity = queue->capacity - 1;
+  if (isStringQueueEmpty(queue)) return NULL;
+  char *item = queue->data[0];
+  if (queue->len > 1) {
+    memmove(queue->data, queue->data + 1, sizeof(char *) * (queue->len - 1));
+  }
+  queue->len--;
+  queue->data[queue->len] = NULL;
   return item;
 }
 
-// Function to get front of queue
 static char *front(StringQueue *queue) {
-  // if (isQueueEmpty(queue))
-  //   return CHAR_MIN;
-  // return queue->data[queue->front];
-  if (queue->data[queue->front]) {
-    return queue->data[queue->front];
+  if (isStringQueueEmpty(queue)) return NULL;
+  return queue->data[0];
+}
+
+static void clearStringQueue(StringQueue *queue) {
+  if (queue == NULL || queue->data == NULL) return;
+  for (uint32_t i = 0; i < queue->len; i++) {
+    free(queue->data[i]);
+    queue->data[i] = NULL;
   }
-  return NULL;
+  queue->len = 0;
 }
 
 void deleteStringQueue(StringQueue *queue) {
-  if (queue != NULL) {
-    // Free the dynamically allocated data array
-    free(queue->data);
-    // Free the BoolQueue structure itself
-    free(queue);
-  }
+  if (queue == NULL) return;
+  clearStringQueue(queue);
+  free(queue->data);
+  free(queue);
 }
 
-// END OF --- a array implementation of STRING queue in C
+// END OF --- dynamic STRING queue in C
 
-// START OF --- a array implementation of Boolean queue in C
+// START OF --- dynamic Boolean queue in C
 typedef struct
 {
-  int front, rear, size;
-  int capacity;
+  uint32_t len;
+  uint32_t cap;
   bool *data;
 } BoolQueue;
 
-// function to create a queue
-// of given capacity.
-// It initializes size of queue as 0
+static bool ensureBoolQueueCapacity(BoolQueue *queue, uint32_t needed) {
+  if (queue == NULL) return false;
+  if (needed <= queue->cap) return true;
+  uint32_t new_cap = queue->cap > 0 ? queue->cap : 4;
+  while (new_cap < needed) {
+    new_cap *= 2;
+  }
+  bool *next = (bool *)realloc(queue->data, sizeof(bool) * new_cap);
+  if (next == NULL) return false;
+  memset(next + queue->cap, 0, sizeof(bool) * (new_cap - queue->cap));
+  queue->data = next;
+  queue->cap = new_cap;
+  return true;
+}
+
 static BoolQueue *createBoolQueue() {
   BoolQueue *queue = calloc(1, sizeof(BoolQueue));
-
-  queue->capacity = 1;
-  queue->front = queue->size = 0;
-
-  // This is important, see the enqueue
-  queue->rear = queue->capacity - 1;
-  queue->data = (bool *)calloc(1, queue->capacity * sizeof(bool));
+  if (queue == NULL) return NULL;
+  queue->cap = 4;
+  queue->data = (bool *)calloc(queue->cap, sizeof(bool));
+  if (queue->data == NULL) {
+    free(queue);
+    return NULL;
+  }
   return queue;
 }
 
-// BoolQueue is full when size becomes
-// equal to the capacity
-static int isBoolQueueFull(BoolQueue *queue) {
-  return (queue->size == queue->capacity);
-}
-
-// BoolQueue is empty when size is 0
 static int isBoolQueueEmpty(BoolQueue *queue) {
-  return (queue->size == 0);
+  return queue == NULL || queue->len == 0;
 }
 
-// Function to add an item to the queue.
-// It changes rear and size
 static void enqueueBoolQueue(BoolQueue *queue, bool item) {
-  if (isBoolQueueFull(queue))
-    queue->capacity = queue->capacity + 1;;
-  queue->rear = (queue->rear + 1) % queue->capacity;
-  queue->data[queue->rear] = item;
-  queue->size = queue->size + 1;
+  if (queue == NULL) return;
+  if (!ensureBoolQueueCapacity(queue, queue->len + 1)) return;
+  queue->data[queue->len++] = item;
 }
 
-// Function to remove an item from queue.
-// It changes front and size
 static bool dequeueBoolQueue(BoolQueue *queue) {
-  if (isBoolQueueEmpty(queue))
-    return false;
-  bool item = queue->data[queue->front];
-  queue->front = (queue->front + 1) % queue->capacity;
-  queue->size = queue->size - 1;
+  if (isBoolQueueEmpty(queue)) return false;
+  bool item = queue->data[0];
+  if (queue->len > 1) {
+    memmove(queue->data, queue->data + 1, sizeof(bool) * (queue->len - 1));
+  }
+  queue->len--;
+  queue->data[queue->len] = false;
   return item;
 }
 
-// Function to get front of queue
 static bool frontBoolQueue(BoolQueue *queue) {
-  // if (isBoolQueueEmpty(queue))
-  //   return CHAR_MIN;
-  if (queue->data[queue->front]) {
-    return queue->data[queue->front];
-  }
-  return NULL;
+  if (isBoolQueueEmpty(queue)) return false;
+  return queue->data[0];
+}
+
+static void clearBoolQueue(BoolQueue *queue) {
+  if (queue == NULL) return;
+  queue->len = 0;
 }
 
 void deleteBoolQueue(BoolQueue *queue) {
-  if (queue != NULL) {
-    // Free the dynamically allocated data array
-    free(queue->data);
-    // Free the BoolQueue structure itself
-    free(queue);
-  }
+  if (queue == NULL) return;
+  free(queue->data);
+  free(queue);
 }
 
-// END OF --- a array implementation of Boolean queue in C
+// END OF --- dynamic Boolean queue in C
 
 typedef struct {
   bool started_heredoc;
@@ -578,7 +580,8 @@ static bool exit_if_heredoc_end_delimiter(Scanner *scanner, TSLexer *lexer) {
     // unset stuffs
     scanner->heredoc.started_heredoc = false;
     scanner->heredoc.started_heredoc_body = false;
-    dequeueStringQueue(scanner->heredoc.heredoc_identifier_queue);
+    char *popped = dequeueStringQueue(scanner->heredoc.heredoc_identifier_queue);
+    free(popped);
     dequeueBoolQueue(scanner->heredoc.heredoc_allows_interpolation);
     return true;
   }
@@ -1013,28 +1016,23 @@ static inline bool scan(Scanner *scanner, TSLexer *lexer, const bool *valid_symb
 }
 
 static unsigned serialize(Scanner *scanner, char *buffer) {
-  uint32_t size = 0;
-
-  return size;
-}
-
-static inline void reset_heredoc(StringQueue *queue) {
-  queue->data = NULL;
+  (void)scanner;
+  (void)buffer;
+  return 0;
 }
 
 static void reset (Scanner *scanner) {
   scanner->heredoc.started_heredoc = false;
   scanner->heredoc.started_heredoc_body = false;
-  for (int i = 0; i < scanner->heredoc.heredoc_identifier_queue->size; i++) {
-    reset_heredoc(&scanner->heredoc.heredoc_identifier_queue[i]);
-  }
+  clearStringQueue(scanner->heredoc.heredoc_identifier_queue);
+  clearBoolQueue(scanner->heredoc.heredoc_allows_interpolation);
+  clearBoolQueue(scanner->heredoc.heredoc_allows_indent);
 }
 
 static void deserialize(Scanner *scanner, const char *buffer, unsigned length) {
-  // printf("sdf %d \n", length);
-  // if (length == 0) {
-  //   reset(scanner);
-  // }
+  (void)buffer;
+  (void)length;
+  reset(scanner);
 }
 
 void *tree_sitter_perl_external_scanner_create() {
