# PairOfCleats GigaRoadmap

    ## Status legend
    
    Checkboxes represent the state of the work, update them to reflect the state of work as its being done:
    - [x] Implemented and appears complete/correct based on code inspection and existing test coverage
    - [@] In Progress, this work has been started
    - [.] Work has been completed but has Not been tested
    - [?] There is a correctness gap **or** there is missing/insufficient test proving behavior
    - [ ] Not complete
    
    Completed Phases: `COMPLETED_PHASES.md`

## Roadmap List
### Foundational
- Phase R -- Make Monoliths Modular, My Man

## Phase R -- Refactor MegaCut 

---

### R.0 Refactor playbook (applies to every subtask)

**Goal:** Split “fat” modules into cohesive, testable, side-effect-minimized modules **without changing behavior**.

**Hard rules**
- **No behavior changes** unless explicitly called out in the task’s “Behavior deltas” section.
- **Preserve public entrypoints.** If you move code, keep a tiny compatibility shim at the old path that re-exports the same names.
- **Keep ESM import style** (repo is `"type": "module"`; keep `.js` extensions on relative imports).
- **No new global state**; prefer pure helpers and dependency injection (pass `log`, `signal`, configs, caches).
- **Avoid circular imports** by extracting shared primitives to `src/shared/**` and keeping “leaf” modules free of imports from high-level orchestrators.

**PR checklist**
- [ ] New modules have a single responsibility and minimal export surface.
- [ ] All call sites updated (or compatibility re-export added).
- [ ] All relevant tests pass:
  - `node tests/run.js --lane pr` (preferred) or `npm run test:pr`
  - plus any targeted tests called out per task.
- [ ] `npm run lint` passes.
- [ ] File sizes: prefer < ~500 LOC for “leaf” modules; orchestrators may be larger but should be mostly glue.

---

### R.1 Script surface policy + docs (package.json sprawl)

**Spec conflict (resolved):** The original Phase R.1 demanded `package.json` scripts be reduced to <10.  
The current repo has already adopted a **policy-based approach** instead:
- `tools/script-inventory.js` generates `docs/tooling/script-inventory.json` and `docs/guides/commands.md`.
- `tests/policy/script-surface-policy.test.js` enforces that the inventory matches `package.json`.

This is a better trade-off than “<10 scripts” because:
- Many scripts are intentionally “debuggable entrypoints” for specific tests/tools.
- The repo has explicit policy + inventory tooling already; rewriting the entire script surface would be noisy and high-churn.

#### R.1.1 Script inventory + policy enforcement
- [x] Keep `tools/script-inventory.js` as the single generator for:
  - `docs/tooling/script-inventory.json`
  - `docs/guides/commands.md`
- [x] Keep `tests/policy/script-surface-policy.test.js` enforcing inventory ↔ package parity.

**Callouts**
- Generator: `tools/script-inventory.js`
- Inventory: `docs/tooling/script-inventory.json`
- Policy test: `tests/policy/script-surface-policy.test.js`

#### R.1.2 Fix doc drift: commands.md must be reproducible
- [ ] Resolve the current mismatch where `docs/guides/commands.md` contains a “Phase 3 specs” section that **is not emitted** by `tools/script-inventory.js`.
  - **Best choice:** make `commands.md` purely generated; either:
    1) Update generator to also emit a “Phase specs” section (recommended), or  
    2) Remove the non-generated section from `commands.md` and move it to a separate doc (less ideal; increases doc surface).
- [ ] Add a policy test to prevent future drift:
  - New test file: `tests/policy/script-inventory-docs.test.js`
  - It should run the generator in-memory and compare against `docs/guides/commands.md` OR at minimum assert:
    - the “generated by” header is present
    - the “Stable entrypoints” block matches the generator’s output
    - the script table contains the same script names as inventory

**Why option (1) is recommended:**  
The repo already treats `commands.md` as generated. Making the generator responsible for *all* its sections is the only way to keep it deterministic and enforceable.

#### R.1.3 Tighten the “stable entrypoints” contract
- [ ] Document (and keep stable) the following script entrypoints:
  - `test`, `test:pr`, `test:nightly`, `lint`, `format`, `config:budget`, `env:check`, `verify`
- [ ] Update any user-facing docs / error messages that reference non-stable scripts to prefer:
  - `pairofcleats ...` CLI entrypoints (preferred for users)
  - or `node <script>` for internal tools
- [ ] Add a lightweight test that fails if “stable entrypoints” are removed/renamed without updating docs/tooling/script-inventory.json.

---

### R.2 Repo hygiene + drift-proofing

#### R.2.1 AGENTS.md coverage
- [x] Ensure `AGENTS.md` lists the primary docs to read and how to run tests/lint.
- [ ] Add an explicit pointer to the script policy docs:
  - `docs/tooling/script-inventory.json`
  - `docs/guides/commands.md`
  - The enforcement test: `tests/policy/script-surface-policy.test.js`

#### R.2.2 Drift-proofing for docs ↔ code contracts
- [x] Keep the existing “policy tests” approach (see `tests/policy/**`) for anything that otherwise drifts silently.

#### R.2.3 Optional: sweep stale files (low-risk cleanup)
- [ ] Add a non-destructive report script (no deletions) that inventories:
  - orphan docs (not referenced by any “Docs to read” list)
  - orphan tools (not referenced by any script/CLI)
  - orphan scripts (not referenced by docs/CI/tests)
- Suggested location: `tools/repo-inventory.js`
- Output: `docs/tooling/repo-inventory.json`
- Add a policy test that only checks the file exists + JSON schema sanity (don’t gate PRs on the contents yet).

---

### R.3 Shared primitives (extract early, reuse everywhere)

These have landed and should be used as the canonical helpers.

#### R.3.1 Backoff/retry helper
- [x] `src/shared/retry.js` exports `retryWithBackoff({ attempts, minDelayMs, maxDelayMs, factor, jitter, shouldRetry, operation, signal })`
- [x] Used by `src/index/build/watch/lock.js` to implement `acquireIndexLockWithBackoff(...)`.
- Tests (existing): `tests/watch-lock-backoff.js`

**Follow-up**
- [ ] Add a small direct unit test for `retryWithBackoff` itself (optional but improves locality):
  - New: `tests/retry-with-backoff.js`
  - Cover: abort signal, shouldRetry false, jitter bounds, attempts=1 behavior.

#### R.3.2 Debounce scheduler
- [x] `src/shared/scheduler/debounce.js` exports `createDebouncedScheduler({ delayMs, maxDelayMs, onFlush })`
- [x] Used by watch pipeline (via `src/index/build/watch.js`).
- Tests (existing): `tests/watch-debounce.js`

#### R.3.3 Ignore matcher helper (path + chokidar semantics)
- [x] `src/shared/fs/ignore.js` exports `buildIgnoredMatcher({ root, ignoreMatcher })` for chokidar-compatible ignores.
- [ ] Add a dedicated test for “directory ignore vs file ignore” semantics:
  - New: `tests/ignore-matcher.js`
  - Cases:
    - ignoreMatcher matches a directory: should ignore descendants (simulate `stats.isDirectory()` true)
    - ignoreMatcher matches a file path: should ignore only that path
    - Windows path normalization (`\` → `/`) must not break matching
  - Import the helper directly from `src/shared/fs/ignore.js`.

#### R.3.4 Filter list merge helper
- [x] `src/shared/filter/merge.js` exports `mergeFilterLists(a, b)`
- [x] Used by `src/retrieval/filters.js` (`mergeExtFilters`, `mergeLangFilters`) and tested via:
  - `tests/lang-filter.js`

---

### R.4 Core indexing + build pipeline refactors

#### R.4.1 Watch pipeline split
- [x] `src/index/build/watch.js` is now an orchestrator that delegates to:
  - `src/index/build/watch/args.js` (args normalization)
  - `src/index/build/watch/chokidar-backend.js` / `polling-backend.js`
  - `src/index/build/watch/watch-event-queue.js`
  - `src/index/build/watch/stability.js` (stability guard)
  - `src/index/build/watch/lock.js` (index lock + backoff)
  - `src/index/build/watch/rebuild.js` (rebuild trigger)
- Tests (existing):
  - `tests/watch-backend-selection.js`
  - `tests/watch-debounce.js`
  - `tests/watch-lock-backoff.js`
  - `tests/watch-stability-guard.js`
  - (plus several watch E2E/atomicity tests)

**Remaining (optional)**
- [ ] If `watch.js` grows again, prefer extracting additional “pure helpers” to `src/index/build/watch/*.js` rather than re-introducing large inline blocks. Note this in the docs for watch/build

#### R.4.2 Integrations/core split (spec drift fix)

**Spec drift:** The old roadmap targeted `src/integrations/core/index.js` as a 700+ LOC monolith.  
In the current codebase, `src/integrations/core/index.js` is a tiny re-export façade, and the largest module is now:

- **Current monolith target:** `src/integrations/core/build-index.js` (~735 LOC)

##### R.4.2.1 Keep the facade pattern
- [x] `src/integrations/core/index.js` should remain a small re-export surface for:
  - `buildIndex`, `buildSqliteIndex` (from `build-index.js`)
  - `search` (from `search.js`)
  - `status` (from `status.js`)
- [x] Other integration helpers already live in `src/integrations/core/*.js`

##### R.4.2.2 Split build-index integration logic
- [ ] Refactor `src/integrations/core/build-index.js` into a folder:
  - `src/integrations/core/build-index/index.js` (orchestrator; exports `buildIndex`, `buildSqliteIndex`)
  - `src/integrations/core/build-index/progress.js` (overall progress aggregation; current inline “overallProgress” logic)
  - `src/integrations/core/build-index/compatibility.js` (compat key computation)
  - `src/integrations/core/build-index/runtime.js` (runtime bootstrap/teardown helpers)
  - `src/integrations/core/build-index/stages.js` (stage1/stage2 planning + dispatch)
  - `src/integrations/core/build-index/sqlite.js` (the `buildSqliteIndex` implementation)

**Compatibility requirements**
- Keep exports stable from `src/integrations/core/index.js`.
- Keep the existing `buildIndex(repoRoot, options)` and `buildSqliteIndex(repoRoot, options)` signatures intact.

**Callers**
- `bin/pairofcleats.js` (via integration layer)
- `tools/mcp/tools.js` uses `coreBuildIndex` / `coreBuildSqliteIndex`
- Tests that invoke `build_index.js` script (various E2E tests)

**Tests to run**
- `node tests/run.js --match build-index --match index-lock --match watch-atomicity` (minimum)
- `node tests/run.js --lane pr` (recommended)

#### R.4.3 Runtime refactor
- [x] Runtime has been split into:
  - `src/index/build/runtime/config.js`, `policy.js`, `stage.js`, `workers.js`, `hash.js`, etc.
- [.] `src/index/build/runtime/runtime.js` remains large (~680 LOC) but is primarily orchestrator + normalization.

**Optional follow-up**
- [ ] Extract “option normalization” helpers from `runtime.js` into `runtime/normalize.js` if `runtime.js` continues to grow.
- [ ] Add a unit test for “caps/policy merges” if regressions occu.

#### R.4.4 Validate split
- [x] `src/index/validate.js` delegates to `src/index/validate/*` modules (`manifest`, `sqlite`, `lmdb`, etc.)
- Tests (existing): search for `validate` lane/scripts in `tests/script-coverage` actions.

#### R.4.5 Artifacts build split
- [x] `src/index/build/artifacts.js` delegates into `src/index/build/artifacts/*` (filter-index, postings, bundles, etc.)
- Ensure any new artifact type also updates:
  - `docs/contracts/artifact-contract.md`
  - `src/contracts/schemas/artifacts.js` (if schema is used)
  - relevant validation in `src/index/validate/*`

#### R.4.6 Worker pool split
- [x] Worker pool logic is now under `src/index/build/workers/*`
- `src/index/build/worker-pool.js` is a façade.

#### R.4.7 File processor split (CPU + chunk processing)

**Current state**
- [.] `src/index/build/file-processor/cpu.js` is ~586 LOC and already delegates chunking to:
  - `src/index/build/file-processor/cpu/chunking.js`
- **New monolith candidate:** `src/index/build/file-processor/process-chunks.js` (~650 LOC)

**Plan**
- [ ] Keep `cpu.js` as the “single-file CPU orchestration” entrypoint (export `processFileCpu(...)`), but extract:
  - tokenization setup / caching → `cpu/tokenizer.js`
  - AST/tree-sitter analysis pass wrappers → `cpu/analyze.js`
  - metadata v2 enrichment steps → `cpu/meta.js`
  - keep `cpu/chunking.js` as-is

- [ ] Split `process-chunks.js` into:
  - `file-processor/process-chunks/index.js` (orchestrator)
  - `file-processor/process-chunks/enrichment.js` (enrich + merge docmeta)
  - `file-processor/process-chunks/dedupe.js` (dedupe + normalization)
  - `file-processor/process-chunks/limits.js` (chunk limits + truncation policy)
  - `file-processor/process-chunks/ids.js` (chunk id assignment + stability rules)

**Callers**
- `src/index/build/indexer/steps/process-files.js`
- any tests building indexes (`tests/e2e-smoke.js`, etc.)

**Tests to run**
- `node tests/run.js --match segment-pipeline --match chunking-limits --match metadata-v2`
- plus at least one full index build smoke (`tests/e2e-smoke.js` or `tests/build-index-all.js` if present)

#### R.4.8 Piece assembly split
- [.] `src/index/build/piece-assembly.js` is still ~500 LOC; helpers exist at `src/index/build/piece-assembly/helpers.js`.

**Remaining extraction (recommended)**
- [ ] Extract the IO-heavy loader to `src/index/build/piece-assembly/load.js`
  - Move `loadIndexArtifacts(...)` and any “find pieces / read manifest / read artifacts” logic.
- [ ] Extract merge logic to `src/index/build/piece-assembly/merge.js`
  - “merge postings / merge bundles / merge filter index / merge relations” helpers
- [ ] Keep `assembleIndexPieces(...)` in `piece-assembly.js` as orchestrator (or move to `piece-assembly/index.js` with a façade).

**Callers**
- `tools/assemble-pieces.js` (CLI tool)
- `tests/contracts/index-compatibility-key-federation-block.test.js`

**Tests to run**
- `node tests/run.js --match compact-pieces --match index-compatibility-key-federation-block`

---

### R.5 Retrieval refactors

#### R.5.1 `filterChunks` split (`src/retrieval/output/filters.js`)

**Current state**
- [.] `src/retrieval/output/filters.js` (~570 LOC) is still a large “everything bagel”.
- [x] Candidate selection helpers already extracted:
  - `src/retrieval/output/filters/candidates.js` exports `createCandidateHelpers(...)`
- The file implements:
  - meta filters (`meta.*`, risk fields, etc.)
  - structural filters (`structPack`, `structRule`, `structTag`)
  - file/path/ext/lang prefiltering using `filterIndex` chargrams + roaring bitmaps
  - relation filters (`uses`, `imports`, `calls`) via `fileRelations`

**Specs to follow**
- File prefilter semantics: `docs/guides/search.md` (“File Filter Prefilter (Substring/Regex)”)
- Search filter contract: `docs/contracts/search-contract.md` + `docs/contracts/search-cli.md`
- Structural filter doc: `docs/guides/structural-search.md`

**Public entrypoint**
- Keep: `export function filterChunks(meta, filters = {}, filterIndex = null, fileRelations = null)`

**Callers**
- `src/retrieval/output.js` re-exports it
- `src/retrieval/pipeline.js` calls it
- Many tests import from `src/retrieval/output.js`

**Refactor plan (safe + incremental)**
- [ ] **Step 1: fix formatting drift** in `filters.js` (indentation currently broken in destructuring blocks).
- [ ] **Step 2: extract pure predicates** to `src/retrieval/output/filters/predicates.js`
  - `matchList`, `matchAny`, `truthy`, and any “normalize list” helpers.
- [ ] **Step 3: extract structural matching** to `src/retrieval/output/filters/structural.js`
  - `matchStructural(chunk, { structPack, structRule, structTag })`
  - Must match semantics verified by `tests/structural-filters.js`.
- [ ] **Step 4: extract meta matching** to `src/retrieval/output/filters/meta.js`
  - `matchMetaFilters(chunk, metaFilters, riskFilters, options)`
  - Preserve support for:
    - `meta` (k/v string or regex) and `caseMeta`
    - risk selectors: `risk`, `riskTag`, `riskCategory`, `riskSource`, `riskSink`, `riskFlow`
    - inferred types: `inferredType`, `returnType`, `param`
- [ ] **Step 5: extract file/path filter evaluation** to `src/retrieval/output/filters/file.js`
  - Build final exact predicate for:
    - `file`/`caseFile` (substring or regex; supports list)
    - `ext`, `lang`
  - Keep **final exact match** always enforced even when prefilter narrows candidates.
- [ ] **Step 6: extract file prefilter (chargram/roaring)** to `src/retrieval/output/filters/file-prefilter.js`
  - `collectFilePrefilterMatches({ filterIndex, fileMatchers, caseFile, fileChargramN, roaring })`
  - Must implement doc semantics:
    - longest stable literal from regex; skip if none
    - case-insensitive prefilter; exact match still checks case when `caseFile` is true
- [ ] **Step 7: keep filterChunks orchestrator** in `filters.js` (or move to `filters/index.js` and re-export from `filters.js`)
  - It should:
    - normalize filters once
    - construct candidate sets using `createCandidateHelpers`
    - loop candidates and apply exact predicates
    - handle `fileRelations` expansion for `uses/imports/calls` filters

**Tests to run (existing, must pass unchanged)**
- `tests/filter-index.js`
- `tests/filter-strictness.js`
- `tests/filter-structural.js` / `tests/structural-filters.js`
- `tests/file-case-sensitive.js`
- `tests/filters-file.js`
- `tests/lang-filter.js`

*(Search for additional filter tests in `/tests` prefixed with `filter-` and run them too.)*

#### R.5.2 Search CLI split (`src/retrieval/cli.js`)
- [.] The CLI already delegates many responsibilities to `src/retrieval/cli/*`, but `src/retrieval/cli.js` is still ~700 LOC because `runSearchCli(...)` contains large inline glue (nested helpers + massive destructure).

**Refactor goal**
- Keep `runSearchCli(...)` export stable (callers: `src/integrations/core/search.js`).
- Reduce `cli.js` to “parse → normalize → run session → render/persist” glue.

**Plan**
- [ ] Extract inline helpers inside `runSearchCli` to `src/retrieval/cli/runner.js`:
  - `inferJsonOutputFromArgs`
  - `emitError` / `bail`
  - `throwIfAborted`
- [ ] Extract the giant `normalized` destructuring + derived flags into:
  - `src/retrieval/cli/resolve-run-config.js`
  - Return a single `runConfig` object (typed by convention / JSDoc) consumed by `runSearchSession`.
- [ ] Keep `src/retrieval/cli.js` as the orchestrator that wires modules together.

**Tests to run**
- `node tests/run.js --match search-cli --match sqlite-fts-eligibility --match search-symbol-boost`

#### R.5.3 Language registry split
- [x] `src/index/language-registry/registry.js` is now small; data lives in `registry-data.js`.
- Ensure any future registry edits update:
  - `src/index/language-registry/registry-data.js`
  - tests that validate language ids / aliases (search for `language-registry` in tests)

#### R.5.4 Search pipeline split (`src/retrieval/pipeline.js`)

**Current state**
- [.] Candidate-building has been extracted to `src/retrieval/pipeline/candidates.js`.
- `src/retrieval/pipeline.js` is still ~640 LOC and mixes:
  - query-AST phrase checks
  - backend selection (ANN, sqlite FTS, etc.)
  - scoring logic (RRF, blend, symbol boosts, phrase boosts)
  - context-expansion

**Specs to follow**
- `docs/contracts/search-contract.md`
- `docs/guides/search.md`
- `docs/contracts/search-cli.md`

**Public entrypoint**
- Keep: `export function createSearchPipeline(context = {})`

**Callers**
- `src/retrieval/cli/run-search-session.js`
- tests: `tests/search-symbol-boost.js`, `tests/retrieval/sqlite-fts-eligibility.js`, and others

**Refactor plan**
- [ ] Extract query-AST helpers to `src/retrieval/pipeline/query-ast.js`
  - move `matchesQueryAst(...)`
  - move `getPhraseMatchInfo(...)`
  - keep the exact signatures to avoid churn
- [ ] Extract ANN backend normalization to `src/retrieval/pipeline/ann-backends.js`
  - move `normalizeAnnBackend(...)`, `resolveAnnOrder(...)`
- [ ] Extract score fusion to `src/retrieval/pipeline/fusion.js`
  - a pure function that takes ranked sparse list, ranked dense list, config → fused list + breakdowns
  - keep existing behavior: default RRF, optional normalized blending via `search.scoreBlend.*`
- [ ] Keep `pipeline.js` as orchestrator:
  - loads providers (BM25, sqlite fts, ann, minhash)
  - delegates to extracted helpers
  - keeps `createSearchPipeline` signature stable

**Tests to run**
- `tests/search-symbol-boost.js`
- `tests/retrieval/sqlite-fts-eligibility.js`
- `tests/search-rrf-parity.js` (if present)
- `tests/search-explain-schema.js` (if present)
- plus `node tests/run.js --lane pr`

#### R.5.5 JSON stream split
- [x] `src/shared/json-stream.js` is a façade over `src/shared/json-stream/*`

#### R.5.6 Filter merge module
- [x] `src/retrieval/filters.js` uses `src/shared/filter/merge.js`

---

### R.6 Tooling & services refactors

#### R.6.1 MCP tool dispatcher split (`tools/mcp/tools.js`)

**Current state**
- [.] `tools/mcp/tools.js` (~650 LOC) exports many handlers and a large `handleToolCall` switch.
- Helpers already extracted to: `tools/mcp/tools/helpers.js`

**Specs to follow**
- Tool defs + schemas are the source of truth:
  - `src/integrations/mcp/defs.js`
- Tests that enforce handler coverage:
  - `tests/mcp/tools-registry.test.js`
  - `tests/mcp/tools-normalize-meta.test.js`

**Public entrypoints (must remain exported)**
- `buildIndex`
- `runSearch`
- `downloadModels`, `downloadDictionaries`, `downloadExtensions`, `verifyExtensions`
- `buildSqliteIndex`, `compactSqliteIndex`
- `cacheGc`, `cleanArtifacts`, `runBootstrap`, `reportArtifacts`
- `triageIngest`, `triageDecision`, `triageContextPack`
- `handleToolCall`
- `normalizeMetaFilters` (re-export)

**Refactor plan**
- [ ] Create folder: `tools/mcp/tools/handlers/`
  - `index-status.js` → `indexStatus`, `configStatus` (or keep in `tools/mcp/repo.js` if already there)
  - `indexing.js` → `buildIndex`, `buildSqliteIndex`, `compactSqliteIndex`
  - `search.js` → `runSearch`
  - `downloads.js` → `downloadModels`, `downloadDictionaries`, `downloadExtensions`, `verifyExtensions`
  - `artifacts.js` → `cleanArtifacts`, `reportArtifacts`, `cacheGc`
  - `bootstrap.js` → `runBootstrap`
  - `triage.js` → `triageIngest`, `triageDecision`, `triageContextPack`
- [ ] Replace the `handleToolCall` switch with a map:
  - `const TOOL_HANDLERS = new Map([ ['search', runSearch], ... ])`
  - `handleToolCall(name, args, ctx)` looks up handler and throws unknown tool error if missing.
- [ ] Update `tests/mcp/tools-registry.test.js` accordingly:
  - Instead of parsing switch cases, assert:
    - every tool name in `getToolDefs({ ... })` has a handler in the map
    - no extra handlers exist for undefined tools

**Compatibility requirements**
- Preserve handler behavior (progress callbacks, env resolution, JSON parsing errors).
- Keep error messages stable enough for tests (if tests assert substrings, keep them).

#### R.6.2 API router split
- [x] `tools/api/router.js` already delegates to `tools/api/router/*`

#### R.6.3 build-embeddings split
- [x] `tools/build-embeddings/run.js` delegates to `tools/build-embeddings/*`

#### R.6.4 build-sqlite-index split
- [x] `tools/build-sqlite-index/run.js` delegates to `tools/build-sqlite-index/*`

#### R.6.5 config-inventory split
- [x] `tools/config-inventory.js` delegates to `tools/config-inventory/*`

#### R.6.6 dict-utils split
- [x] `tools/dict-utils.js` is the public façade; internal helpers live in `tools/dict-utils/*`

---

### R.7 UI refactors

#### R.7.1 Map isometric edge assembly split (`src/map/isometric/client/edges.js`)

**Current state**
- [.] `edges.js` (~500 LOC) already extracted:
  - `src/map/isometric/client/edges/resolvers.js` (`createEdgeResolvers`)
  - `src/map/isometric/client/edges/routing.js` (`createRoutingHelpers`)
- Remaining in `edges.js`: aggregation + rendering shape logic.

**Public entrypoint**
- Keep: `export function buildEdges({...})`

**Refactor plan**
- [ ] Extract edge aggregation to `src/map/isometric/client/edges/aggregate.js`
  - logic that builds per-edge segments + dedupes
- [ ] Extract “endpoint dots” to `src/map/isometric/client/edges/endpoints.js`
- [ ] Extract styling/resolution to `src/map/isometric/client/edges/style.js`
  - color/opacity decisions based on selection, hover, depth, etc.
- [ ] Keep `edges.js` as orchestrator that wires:
  - resolvers + routing + aggregation + endpoints + style

**Tests (missing today)**
- [ ] Add a small unit test suite under `tests/map/edges.test.js`:
  - route helper produces deterministic paths given fixed nodes
  - edge resolver consistently assigns inbound/outbound per node orientation
  - aggregation is stable (same input → same output ordering)

---

### R.8 Post-refactor follow-ups

- [ ] After the above splits, re-evaluate `eslint.config.js` `max-lines`:
  - Optionally lower the threshold for non-generated files if monoliths are under control.
- [ ] Update `docs/guides/architecture.md` if module boundaries materially change (filters/pipeline/tools).
- [ ] Update `docs/guides/commands.md` and `docs/tooling/script-inventory.json` if any script entrypoints changed.

---

### R.9 Current monolith snapshot (2026-01-30)

Top refactor candidates by size/complexity (non-generated, behavior-heavy):
1. `src/integrations/core/build-index.js` (~735 LOC) → split per **R.4.2.2**
2. `src/retrieval/cli.js` (~719 LOC) → reduce glue per **R.5.2**
3. `src/index/build/watch.js` (~703 LOC, but already modular) → optional further extraction
4. `src/index/build/runtime/runtime.js` (~683 LOC, mostly orchestrator) → optional normalize split
5. `src/index/build/file-processor/process-chunks.js` (~650 LOC) → split per **R.4.7**
6. `tools/mcp/tools.js` (~650 LOC) → split per **R.6.1**
7. `src/retrieval/pipeline.js` (~638 LOC) → split per **R.5.4**
8. `src/retrieval/output/filters.js` (~570 LOC) → split per **R.5.1**
9. `src/index/build/piece-assembly.js` (~500 LOC) → split per **R.4.8**
10. `src/map/isometric/client/edges.js` (~500 LOC) → split per **R.7.1**

---
